#line 1 "C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.cpp"
#line 1 "C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.h"
#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"





#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"





#pragma once








#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"































































































































































































































































































































































#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"







#pragma once






















#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"

#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"






    
    

#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
        
            
        

#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
    #line 55 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"













#pragma once







































































































































#line 151 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"



#line 155 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"





























#line 185 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"


#line 188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"

#line 190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"





#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"



#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"






#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"











#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"








#line 228 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
#line 229 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"






























#line 1586 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
























#line 1611 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"












#line 1624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"






































#line 1663 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"















































































































#line 1775 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"






































































































#line 1878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"








































































































































































#line 2047 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"





































































































#line 2149 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"



















































































































































































































#line 2361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
extern "C" {




#line 2367 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"



































































































































































































































#line 2595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"









































































































































































































































#line 2868 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"









#line 2878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"



    
    


#line 2886 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
#line 2887 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"






#line 2894 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
#line 2895 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"






#line 2902 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
#line 2903 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"











#line 2915 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"

































#line 2949 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"






















}
#line 2973 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"











































































































































































































































































#line 292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"



#line 296 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"
















































#line 345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"











































#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"


}
#line 393 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"

#line 395 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concurrencysal.h"
#pragma external_header(pop)
#line 2975 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\sal.h"
#pragma external_header(pop)
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)



    


        
    #line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"
#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"




    


        
    #line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"



    
#line 40 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"




    
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C" {
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"



#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"


    


#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"





#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"



#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"
    
    
#line 94 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"











#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"







#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"











#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"





#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"










#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"










#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"


} 
#line 169 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 

    





#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vadefs.h"

#pragma warning(pop) 
#pragma pack(pop)
#pragma external_header(pop)
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )






    



    





















#line 95 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
















    

#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"

#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
        
    #line 130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    

#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
        
    #line 138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"





#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
    
    
#line 148 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"




    
#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"








    


#line 166 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"



#line 170 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
    
#line 172 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"




    
#line 178 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    
        
        
    

#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 211 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"



    
#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    
#line 220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    
#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"








    
        
    

#line 237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    


#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"



#line 248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"



#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    




#line 272 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    

#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
        
    #line 279 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 280 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    

#line 285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
        
    #line 287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    

#line 293 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
        
    #line 295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 296 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"





#line 302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"



#line 306 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"



    


        
    

#line 316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 317 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    


#line 323 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"






#line 330 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    


        




    #line 341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"



#line 346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    
        
    


#line 354 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    


#line 363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"


#line 366 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    #line 369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#line 370 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 378 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 384 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime.h"
#pragma external_header(pop)
#line 371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"












#line 384 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#pragma once

























#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 51 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 93 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 111 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 117 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 123 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 141 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 153 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 183 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 189 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 195 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 213 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 225 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 231 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 243 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 255 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 261 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 267 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 279 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 291 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"






#line 304 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 322 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 334 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 352 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 358 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 364 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 370 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 376 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 394 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 406 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 412 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 424 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 430 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 436 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 442 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 448 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 454 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 460 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 466 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 472 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 478 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 484 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 490 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 502 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 514 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"






#line 521 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 527 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 539 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"






#line 546 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 558 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"







#line 566 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 572 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 578 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"





#line 584 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"



#line 588 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"

#line 590 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"
#line 591 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xkeycheck.h"
#pragma external_header(pop)
#line 386 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 391 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 393 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 394 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 402 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"










#line 413 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 421 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 425 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 433 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 435 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 436 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 444 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"






#line 451 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"






#line 458 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 462 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"






































#line 501 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"






















#line 524 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 525 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"






#line 532 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"











#line 545 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 549 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 550 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 558 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 560 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 561 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"














#line 576 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 580 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"


#line 583 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"


#line 586 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 591 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 603 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 605 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 612 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 617 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 619 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 629 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 634 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 639 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 647 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 652 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"













#line 666 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 667 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"






#line 674 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"










#line 685 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"










#line 696 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"





#line 702 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 711 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"












#line 726 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 728 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 737 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 739 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"









#line 750 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 752 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"










#line 764 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 766 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"









#line 777 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 779 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"











#line 792 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 794 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"









#line 805 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 807 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 817 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 819 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 829 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 831 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"









#line 842 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 844 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"













#line 859 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 861 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 871 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 873 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"














#line 889 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 891 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
















#line 908 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"













#line 923 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 925 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"










#line 937 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"











#line 951 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"












#line 964 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"










#line 976 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 978 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"









#line 989 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 991 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 1000 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1002 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"









#line 1013 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1015 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 1025 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1027 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 1037 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1039 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 1048 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1050 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 1059 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1061 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"








#line 1071 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1073 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"






#line 1080 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1084 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1088 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1092 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1096 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1100 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1116 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"











#line 1128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"





#line 1134 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 1139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 1144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"


















#line 1163 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

























































#line 1221 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"


































































































#line 1320 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




#line 1325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1327 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 1328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1332 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1334 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1348 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1352 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"















#line 1368 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"




































#line 1405 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"







#line 1413 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"



#line 1421 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"












#line 1434 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"


#line 1437 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"


#line 1440 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 1441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"





#line 1447 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"

#line 1449 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#line 1450 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals_core.h"
#pragma external_header(pop)
#line 10 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdint"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdint.h"







#pragma once






#pragma warning(push)
#pragma warning(disable:   4514 4820 )

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdint.h"









    
    
        
    

#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdint.h"
#line 113 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdint.h"























#pragma warning(pop) 

#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdint.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdint"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
using :: int8_t;
using :: int16_t;
using :: int32_t;
using :: int64_t;
using :: uint8_t;
using :: uint16_t;
using :: uint32_t;
using :: uint64_t;

using :: int_least8_t;
using :: int_least16_t;
using :: int_least32_t;
using :: int_least64_t;
using :: uint_least8_t;
using :: uint_least16_t;
using :: uint_least32_t;
using :: uint_least64_t;

using :: int_fast8_t;
using :: int_fast16_t;
using :: int_fast32_t;
using :: int_fast64_t;
using :: uint_fast8_t;
using :: uint_fast16_t;
using :: uint_fast32_t;
using :: uint_fast64_t;

using :: intmax_t;
using :: intptr_t;
using :: uintmax_t;
using :: uintptr_t;


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using :: int8_t;
    using :: int16_t;
    using :: int32_t;
    using :: int64_t;
    using :: uint8_t;
    using :: uint16_t;
    using :: uint32_t;
    using :: uint64_t;

    using :: int_least8_t;
    using :: int_least16_t;
    using :: int_least32_t;
    using :: int_least64_t;
    using :: uint_least8_t;
    using :: uint_least16_t;
    using :: uint_least32_t;
    using :: uint_least64_t;

    using :: int_fast8_t;
    using :: int_fast16_t;
    using :: int_fast32_t;
    using :: int_fast64_t;
    using :: uint_fast8_t;
    using :: uint_fast16_t;
    using :: uint_fast32_t;
    using :: uint_fast64_t;

    using :: intmax_t;
    using :: intptr_t;
    using :: uintmax_t;
    using :: uintptr_t;
} 
#line 89 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdint"
}



#pragma warning(pop)
#pragma pack(pop)

#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdint"
#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdint"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdlib"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\math.h"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"







#pragma once









    

















        
    #line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    
        
    

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

















    


        
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"














    
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    











        
    #line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    


        
    #line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    

#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
        
    

#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"




    
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    

#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
        
    

#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    


#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



    


#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"









    
#line 201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"













    


        
    #line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    
#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    
        
    

#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"








extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"










    
        
    #line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"








#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



















    

#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
        
    #line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    
#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


 
  

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
   
  #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
 





#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


 

#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
   
 #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"







    __declspec(dllimport) void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );
#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    
        

    













#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"












    


#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    


        


    #line 432 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"









    






        
    #line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    


        
    #line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"













#line 478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"















#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"





    
#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    

#line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    


        


            
        #line 521 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    #line 522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"





#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    


        



    #line 543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    
        
    



#line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

    
        
              
        

#line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    



#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

    
        
    



#line 583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

    
        
    



#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    
#line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"



    
#line 653 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        












        












        
















    














#line 827 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"












































































    













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
    #line 2070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"
#line 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt.h"

} __pragma(pack(pop))


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"
    #line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"










#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"


    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"











#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"












































































void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

      __declspec(dllimport) double    __cdecl acosh(  double _X);
      __declspec(dllimport) double    __cdecl asinh(  double _X);
      __declspec(dllimport) double    __cdecl atanh(  double _X);
      __declspec(dllimport)  double    __cdecl atof(  char const* _String);
      __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
      __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
      __declspec(dllimport) double    __cdecl cbrt(  double _X);
      __declspec(dllimport) double    __cdecl ceil(  double _X);
      __declspec(dllimport) double    __cdecl _chgsign(  double _X);
      __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl erf(  double _X);
      __declspec(dllimport) double    __cdecl erfc(  double _X);
      __declspec(dllimport) double    __cdecl exp2(  double _X);
      __declspec(dllimport) double    __cdecl expm1(  double _X);
      __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl floor(  double _X);
      __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
      __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
      __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
      __declspec(dllimport) int       __cdecl ilogb(  double _X);
      __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
      __declspec(dllimport) double    __cdecl lgamma(  double _X);
      __declspec(dllimport) long long __cdecl llrint(  double _X);
      __declspec(dllimport) long long __cdecl llround(  double _X);
      __declspec(dllimport) double    __cdecl log1p(  double _X);
      __declspec(dllimport) double    __cdecl log2(  double _X);
      __declspec(dllimport) double    __cdecl logb(  double _X);
      __declspec(dllimport) long      __cdecl lrint(  double _X);
      __declspec(dllimport) long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

      __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
      __declspec(dllimport) double __cdecl nan(  char const* _X);
      __declspec(dllimport) double __cdecl nearbyint(  double _X);
      __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
      __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
      __declspec(dllimport) double __cdecl rint(  double _X);
      __declspec(dllimport) double __cdecl round(  double _X);
      __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
      __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
      __declspec(dllimport) double __cdecl tgamma(  double _X);
      __declspec(dllimport) double __cdecl trunc(  double _X);
      __declspec(dllimport) double __cdecl _j0(  double _X );
      __declspec(dllimport) double __cdecl _j1(  double _X );
      __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
      __declspec(dllimport) double __cdecl _y0(  double _X);
      __declspec(dllimport) double __cdecl _y1(  double _X);
      __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

      __declspec(dllimport) float     __cdecl acoshf(  float _X);
      __declspec(dllimport) float     __cdecl asinhf(  float _X);
      __declspec(dllimport) float     __cdecl atanhf(  float _X);
      __declspec(dllimport) float     __cdecl cbrtf(  float _X);
      __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
      __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl erff(  float _X);
      __declspec(dllimport) float     __cdecl erfcf(  float _X);
      __declspec(dllimport) float     __cdecl expm1f(  float _X);
      __declspec(dllimport) float     __cdecl exp2f(  float _X);
      __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
      __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
      __declspec(dllimport) int       __cdecl ilogbf(  float _X);
      __declspec(dllimport) float     __cdecl lgammaf(  float _X);
      __declspec(dllimport) long long __cdecl llrintf(  float _X);
      __declspec(dllimport) long long __cdecl llroundf(  float _X);
      __declspec(dllimport) float     __cdecl log1pf(  float _X);
      __declspec(dllimport) float     __cdecl log2f(  float _X);
      __declspec(dllimport) float     __cdecl logbf(  float _X);
      __declspec(dllimport) long      __cdecl lrintf(  float _X);
      __declspec(dllimport) long      __cdecl lroundf(  float _X);
      __declspec(dllimport) float     __cdecl nanf(  char const* _X);
      __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
      __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
      __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
      __declspec(dllimport) float     __cdecl rintf(  float _X);
      __declspec(dllimport) float     __cdecl roundf(  float _X);
      __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
      __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
      __declspec(dllimport) float     __cdecl tgammaf(  float _X);
      __declspec(dllimport) float     __cdecl truncf(  float _X);

    



#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl _logbf(  float _X);
          __declspec(dllimport) float __cdecl _nextafterf(  float _X,   float _Y);
          __declspec(dllimport) int   __cdecl _finitef(  float _X);
          __declspec(dllimport) int   __cdecl _isnanf(  float _X);
          __declspec(dllimport) int   __cdecl _fpclassf(  float _X);

          __declspec(dllimport) int   __cdecl _set_FMA3_enable(  int _Flag);
          __declspec(dllimport) int   __cdecl _get_FMA3_enable(void);

    




#line 610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"



    

          __declspec(dllimport) float __cdecl acosf(  float _X);
          __declspec(dllimport) float __cdecl asinf(  float _X);
          __declspec(dllimport) float __cdecl atan2f(  float _Y,   float _X);
          __declspec(dllimport) float __cdecl atanf(  float _X);
          __declspec(dllimport) float __cdecl ceilf(  float _X);
          __declspec(dllimport) float __cdecl cosf(  float _X);
          __declspec(dllimport) float __cdecl coshf(  float _X);
          __declspec(dllimport) float __cdecl expf(  float _X);

    









































#line 667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

    



#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl floorf(  float _X);
          __declspec(dllimport) float __cdecl fmodf(  float _X,   float _Y);

    











#line 699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

          __declspec(dllimport) float  __cdecl log10f(  float _X);
          __declspec(dllimport) float  __cdecl logf(  float _X);
          __declspec(dllimport) float  __cdecl modff(  float _X,   float *_Y);
          __declspec(dllimport) float  __cdecl powf(  float _X,   float _Y);
          __declspec(dllimport) float  __cdecl sinf(  float _X);
          __declspec(dllimport) float  __cdecl sinhf(  float _X);
          __declspec(dllimport) float  __cdecl sqrtf(  float _X);
          __declspec(dllimport) float  __cdecl tanf(  float _X);
          __declspec(dllimport) float  __cdecl tanhf(  float _X);

    

















































#line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

      __declspec(dllimport) long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

      __declspec(dllimport) long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

      __declspec(dllimport) long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

      __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

      __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

      __declspec(dllimport) long double __cdecl erfl(  long double _X);
      __declspec(dllimport) long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

      __declspec(dllimport) long double __cdecl exp2l(  long double _X);
      __declspec(dllimport) long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

      __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

      __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
      __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

      __declspec(dllimport) int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

      __declspec(dllimport) long double __cdecl lgammal(  long double _X);
      __declspec(dllimport) long long __cdecl llrintl(  long double _X);
      __declspec(dllimport) long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

      __declspec(dllimport) long double __cdecl log1pl(  long double _X);
      __declspec(dllimport) long double __cdecl log2l(  long double _X);
      __declspec(dllimport) long double __cdecl logbl(  long double _X);
      __declspec(dllimport) long __cdecl lrintl(  long double _X);
      __declspec(dllimport) long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

      __declspec(dllimport) long double __cdecl nanl(  char const* _X);
      __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
      __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

      __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
      __declspec(dllimport) long double __cdecl rintl(  long double _X);
      __declspec(dllimport) long double __cdecl roundl(  long double _X);
      __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
      __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

      __declspec(dllimport) long double __cdecl tgammal(  long double _X);
      __declspec(dllimport) long double __cdecl truncl(  long double _X);

    



#line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    #line 992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

#line 994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#line 999 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_math.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\math.h"




#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdlib"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_malloc.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





































#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_malloc.h"

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
      __declspec(guard(overflow)) size_t _Count,
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
      __declspec(guard(overflow)) size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize_base(
      void* _Block
    ) noexcept;

 
__declspec(dllimport) 
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );


















#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_search.h"










#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stddef.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stddef.h"









#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stddef.h"
    
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stddef.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_search.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_search.h"



 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


































     
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

     
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

     
    __declspec(dllimport) double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) double __cdecl _wtof(
          wchar_t const* _String
        );

     
    __declspec(dllimport) double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) int __cdecl _wtoi(
          wchar_t const* _String
        );

     
    __declspec(dllimport) int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl _wtol(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

         
        __declspec(dllimport) int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits.h"







#pragma once




#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {







    
    



#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits.h"









































    
        
    #line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits.h"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );













    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"


    
    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"












#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning(pop)






__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);



#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"
        
    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

    


        
    #line 841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"



 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 923 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"




















 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




 
__declspec(dllimport) errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );

#line 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"




__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"







    
    
#line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"









      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

    


#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
          char const* _Command
        );

    
    
    #pragma warning(push)
    #pragma warning(disable: 6540)

     
    __declspec(dllimport) int __cdecl _putenv(
          char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning(pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"









    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdlib.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdlib"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )





[[nodiscard]]   inline double abs(  double _Xx) noexcept  {
    return :: fabs(_Xx);
}

[[nodiscard]]   inline float abs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline long double abs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

namespace std {
using :: size_t;
using :: div_t;
using :: ldiv_t;
using :: abort;
using :: abs;
using :: atexit;
using :: atof;
using :: atoi;
using :: atol;
using :: bsearch;
using :: calloc;
using :: div;
using :: exit;
using :: free;
using :: labs;
using :: ldiv;
using :: malloc;
using :: mblen;
using :: mbstowcs;
using :: mbtowc;
using :: qsort;
using :: rand;
using :: realloc;
using :: srand;
using :: strtod;
using :: strtol;
using :: strtoul;
using :: wcstombs;
using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;
#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdlib"

using :: atoll;
using :: llabs;
using :: lldiv;
using :: strtof;
using :: strtold;
using :: strtoll;
using :: strtoull;

using :: _Exit;
using :: at_quick_exit;
using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)

#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdlib"
#line 93 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdlib"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cfloat"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"








#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"
    #line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"



















    






        
    #line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"
























































































































































#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"

    

#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141) 

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);















__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );












 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);


      __declspec(dllimport) float __cdecl _scalbf(  float _X,   long _Y);
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"










    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\float.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cfloat"
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cfloat"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\climits"





#pragma once







#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\climits"
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\climits"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cwchar"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdio"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"




#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"
    
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"


    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"














    








#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"




#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"
    #line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"






#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"


    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"



#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_stdio_config.h"




















} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
    __declspec(dllimport) wint_t __cdecl getwc(
          FILE* _Stream
        );

     
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
     
    __declspec(dllimport) wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __declspec(dllimport) wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
    __declspec(dllimport) FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
    __declspec(dllimport) FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
        __declspec(dllimport) FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 931 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 1283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1719 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"


    
        
        
        #pragma warning(push)
        #pragma warning(disable: 4141 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    




#line 1863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 1949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1995 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    #line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

    


#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstdio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {































    
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"















    
    
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    
    
    
    
    
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
         
        __declspec(dllimport) errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                     char const* _FileName,
                                     char const* _Mode
            );

        
         
        __declspec(dllimport) size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
        __declspec(dllimport) char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fclose(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

     
    __declspec(dllimport) FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
    __declspec(dllimport) int __cdecl feof(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl ferror(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fgetc(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

     
    
    __declspec(dllimport) int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
    __declspec(dllimport) char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl _fileno(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
    __declspec(dllimport) int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
          int _Character
        );

     
    
    __declspec(dllimport) int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
    __declspec(dllimport) int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
    __declspec(dllimport) int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
    __declspec(dllimport) int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
    __declspec(dllimport) long __cdecl ftell(
          FILE* _Stream
        );

     
     
    __declspec(dllimport) __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
    __declspec(dllimport) int __cdecl getc(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl getchar(void);

     
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) int __cdecl _getw(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
        __declspec(dllimport) int __cdecl _pclose(
              FILE* _Stream
            );

         
        __declspec(dllimport) FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
          int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
          char const* _Buffer
        );

     
    
    __declspec(dllimport) int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

    #line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
    __declspec(dllimport) int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#line 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    
    
    
    
    
    __declspec(dllimport) void __cdecl _lock_file(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
    __declspec(dllimport) long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    














#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"



    
    

#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
          int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"


    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"



    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    








#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 1834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    








#line 1916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 2057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable: 6530) 

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

            _Result = vsscanf_s(_Buffer, _Format, _ArgList);

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #line 2299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 6530) 

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
#line 2442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\stdio.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdio"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )
















namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: FILE;
using :: _Mbstatet;

using :: size_t;
using :: fpos_t;
using :: FILE;
using :: clearerr;
using :: fclose;
using :: feof;
using :: ferror;
using :: fflush;
using :: fgetc;
using :: fgetpos;
using :: fgets;
using :: fopen;
using :: fprintf;
using :: fputc;
using :: fputs;
using :: fread;
using :: freopen;
using :: fscanf;
using :: fseek;
using :: fsetpos;
using :: ftell;
using :: fwrite;
using :: getc;
using :: getchar;
using :: perror;
using :: putc;
using :: putchar;
using :: printf;
using :: puts;
using :: remove;
using :: rename;
using :: rewind;
using :: scanf;
using :: setbuf;
using :: setvbuf;
using :: sprintf;
using :: sscanf;
using :: tmpfile;
using :: tmpnam;
using :: ungetc;
using :: vfprintf;
using :: vprintf;
using :: vsprintf;

using :: snprintf;
using :: vsnprintf;
using :: vfscanf;
using :: vscanf;
using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdio"
#line 100 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstdio"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cwchar"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"









#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\errno.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\errno.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\errno.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_string.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )



__pragma(pack(push, 8)) extern "C" {



[[nodiscard]]  
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

[[nodiscard]]  
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

[[nodiscard]]  
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

[[nodiscard]]  
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

[[nodiscard]]    
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

[[nodiscard]]  

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]  
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]    

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_string.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memcpy_s.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memcpy_s.h"




#pragma warning(pop) 
} __pragma(pack(pop))
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_l(_Format, 0, _ArgList);
    }
#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vcwscanf_l(_Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

#line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wconio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wctype.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {











    

#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wctype.h"
        
    #line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wctype.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wctype.h"





















  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wctype.h"


















































































#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wdirect.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wio.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_share.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )











    
    
    
    
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_share.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {










    
    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wio.h"

 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wio.h"

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wio.h"

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wprocess.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wprocess.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"











#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"
    
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"
        



    #line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"



 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 436 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"









    


#line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wstring.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"









    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_wtime.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\stat.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\types.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )



    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\types.h"
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\types.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\types.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\types.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\stat.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\stat.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\sys\\stat.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
          int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

    __declspec(dllimport) int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"

#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\wchar.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cwchar"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




using _Mbstatet = mbstate_t;

namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

using :: mbstate_t;
using :: size_t;
using :: tm;
using :: wint_t;

using :: btowc;
using :: fgetwc;
using :: fgetws;
using :: fputwc;
using :: fputws;
using :: fwide;
using :: fwprintf;
using :: fwscanf;
using :: getwc;
using :: getwchar;
using :: mbrlen;
using :: mbrtowc;
using :: mbsrtowcs;
using :: mbsinit;
using :: putwc;
using :: putwchar;
using :: swprintf;
using :: swscanf;
using :: ungetwc;
using :: vfwprintf;
using :: vswprintf;
using :: vwprintf;
using :: wcrtomb;
using :: wprintf;
using :: wscanf;
using :: wcsrtombs;
using :: wcstol;
using :: wcscat;
using :: wcschr;
using :: wcscmp;
using :: wcscoll;
using :: wcscpy;
using :: wcscspn;
using :: wcslen;
using :: wcsncat;
using :: wcsncmp;
using :: wcsncpy;
using :: wcspbrk;
using :: wcsrchr;
using :: wcsspn;
using :: wcstod;
using :: wcstoul;
using :: wcsstr;
using :: wcstok;
using :: wcsxfrm;
using :: wctob;
using :: wmemchr;
using :: wmemcmp;
using :: wmemcpy;
using :: wmemmove;
using :: wmemset;
using :: wcsftime;

using :: vfwscanf;
using :: vswscanf;
using :: vwscanf;
using :: wcstof;
using :: wcstold;
using :: wcstoll;
using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cwchar"
#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cwchar"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.h"












#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"













#pragma once





#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C" {
#line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"






























#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"


#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"






#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 77 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"






#line 89 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 94 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"




#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"









unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _bittest(long const *, long);


long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedand64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long  _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);



long  _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
__int64 _InterlockedDecrement64(__int64 volatile * _Addend);
__int64 _interlockeddecrement64(__int64 volatile * _Addend);
long  _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);
__int64 _interlockedexchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long  _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);
__int64 _interlockedexchangeadd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long  _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
__int64 _InterlockedIncrement64(__int64 volatile * _Addend);
__int64 _interlockedincrement64(__int64 volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedxor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16 *);
__int32 __iso_volatile_load32(const volatile __int32 *);
__int64 __iso_volatile_load64(const volatile __int64 *);
__int8 __iso_volatile_load8(const volatile __int8 *);
void __iso_volatile_store16(volatile __int16 *, __int16);
void __iso_volatile_store32(volatile __int32 *, __int32);
void __iso_volatile_store64(volatile __int64 *, __int64);
void __iso_volatile_store8(volatile __int8 *, __int8);


unsigned char _interlockedbittestandset(long volatile *, long);



void _mm_pause(void);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);

unsigned int _tzcnt_u32(unsigned int);
unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);
double __ceil(double);
float __ceilf(float);
double __floor(double);
float __floorf(float);
double __round(double);
float __roundf(float);
double __trunc(double);
float __truncf(float);
double __copysign(double, double);
float __copysignf(float, float);
unsigned __signbitvalue(double);
unsigned __signbitvaluef(float);
int _cvt_ftoi_sat (float a);
unsigned _cvt_ftoui_sat (float a);
long long _cvt_ftoll_sat (float a);
unsigned long long _cvt_ftoull_sat (float a);
int _cvt_ftoi_sent (float a);
unsigned _cvt_ftoui_sent (float a);
long long _cvt_ftoll_sent (float a);
unsigned long long _cvt_ftoull_sent (float a);
int _cvt_dtoi_sat (double a);
unsigned _cvt_dtoui_sat (double a);
long long _cvt_dtoll_sat (double a);
unsigned long long _cvt_dtoull_sat (double a);
int _cvt_dtoi_sent (double a);
unsigned _cvt_dtoui_sent (double a);
long long _cvt_dtoll_sent (double a);
unsigned long long _cvt_dtoull_sent (double a);


constexpr void * __cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept;


#line 312 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"
#line 313 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"








}
#line 323 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"
#pragma warning(pop) 
#line 325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.inl.h"
#pragma external_header(pop)
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.h"
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin0.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\isa_availability.h"














enum ISA_AVAILABILITY
{
    __ISA_AVAILABLE_X86   = 0,
    __ISA_AVAILABLE_SSE2  = 1,
    __ISA_AVAILABLE_SSE42 = 2,
    __ISA_AVAILABLE_AVX   = 3,
    __ISA_AVAILABLE_ENFSTRG = 4,
    __ISA_AVAILABLE_AVX2 = 5,
    __ISA_AVAILABLE_AVX512 = 6,

    __ISA_AVAILABLE_ARMNT   = 0,   
    __ISA_AVAILABLE_NEON    = 1,   
    __ISA_AVAILABLE_NEON_ARM64 = 2,
                                   
};








#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\isa_availability.h"






#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\isa_availability.h"

#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\isa_availability.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstddef"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtr1common"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    [[nodiscard]] constexpr value_type operator()() const noexcept {
        return value;
    }
};

template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

using true_type  = bool_constant<true>;
using false_type = bool_constant<false>;

template <bool _Test, class _Ty = void>
struct enable_if {}; 

template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};

template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

template <bool _Test, class _Ty1, class _Ty2>
struct conditional { 
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;








template <class, class>
 constexpr bool is_same_v = false; 
template <class _Ty>
 constexpr bool is_same_v<_Ty, _Ty> = true;

template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtr1common"

template <class _Ty>
struct remove_const { 
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

template <class _Ty>
struct remove_cv { 
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; 
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { 
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct disjunction : false_type {}; 

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    
};

template <class... _Traits>
 constexpr bool disjunction_v = disjunction<_Traits...>::value;

template <class _Ty, class... _Types>
 constexpr bool _Is_any_of_v = 
    disjunction_v<is_same<_Ty, _Types>...>;





#line 173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtr1common"

template <class _Ty>
 constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,



    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_arithmetic_v = 
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t = remove_cv_t<remove_reference_t<_Ty>>;









#line 234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtr1common"

}


#pragma warning(pop)
#pragma pack(pop)
#line 241 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtr1common"
#line 242 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtr1common"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstddef"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
using :: ptrdiff_t;
using :: size_t;
using max_align_t = double; 


































































}

using ::std:: max_align_t; 



#pragma warning(pop)
#pragma pack(pop)

#line 102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstddef"
#line 103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstddef"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\initializer_list"





#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    [[nodiscard]] constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    [[nodiscard]] constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\initializer_list"
#line 70 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\initializer_list"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class>

 constexpr bool _Always_false = false;



template <class _Arg, class _Result>
struct unary_function { 
    using argument_type = _Arg;
    using result_type   = _Result;
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function { 
    using first_argument_type  = _Arg1;
    using second_argument_type = _Arg2;
    using result_type          = _Result;
};
#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"

template <class _Ty = void>
struct plus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};

template <class _Ty = void>
struct minus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};

template <class _Ty = void>
struct multiplies {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};

template <class _Ty = void>
struct equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left == _Right;
    }
};

template <class _Ty = void>
struct not_equal_to {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left != _Right;
    }
};

template <class _Ty = void>
struct greater {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left > _Right;
    }
};

template <class _Ty = void>
struct less {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left < _Right;
    }
};

template <class _Ty = void>
struct greater_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left >= _Right;
    }
};

template <class _Ty = void>
struct less_equal {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left <= _Right;
    }
};

template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { 
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { 
    return _Ptr;
}
}



#line 273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"

#line 275 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"






#line 282 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"




#line 287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"

#line 289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"








#line 298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"






#line 305 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"

























#line 331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"


























#line 358 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"









































#line 400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"



#pragma warning(pop)
#pragma pack(pop)
#line 406 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"
#line 407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstddef"
#pragma external_header(pop)
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
enum float_denorm_style { 
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};

enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};

struct _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;
    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};

template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {}; 

struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};

struct _Num_float_base : _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2;
};

template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept {
        return false;
    }

    [[nodiscard]] static constexpr bool(max)() noexcept {
        return true;
    }

    [[nodiscard]] static constexpr bool lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr bool epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};

template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr signed char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr signed char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr signed char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char(max)() noexcept {
        return 0xff;
    }

    [[nodiscard]] static constexpr unsigned char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};















































template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr char16_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr char32_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept {
        return 0x0000;
    }

    [[nodiscard]] static constexpr wchar_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr wchar_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept {
        return (-32768);
    }

    [[nodiscard]] static constexpr short(max)() noexcept {
        return 32767;
    }

    [[nodiscard]] static constexpr short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept {
        return (-2147483647 - 1);
    }

    [[nodiscard]] static constexpr int(max)() noexcept {
        return 2147483647;
    }

    [[nodiscard]] static constexpr int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept {
        return (-2147483647L - 1);
    }

    [[nodiscard]] static constexpr long(max)() noexcept {
        return 2147483647L;
    }

    [[nodiscard]] static constexpr long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept {
        return (-9223372036854775807i64 - 1);
    }

    [[nodiscard]] static constexpr long long(max)() noexcept {
        return 9223372036854775807i64;
    }

    [[nodiscard]] static constexpr long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};


template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr unsigned short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 711 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"

template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr unsigned int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long(max)() noexcept {
        return 0xffffffffUL;
    }

    [[nodiscard]] static constexpr unsigned long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long(max)() noexcept {
        return 0xffffffffffffffffui64;
    }

    [[nodiscard]] static constexpr unsigned long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};

template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept {
        return 1.175494351e-38F;
    }

    [[nodiscard]] static constexpr float(max)() noexcept {
        return 3.402823466e+38F;
    }

    [[nodiscard]] static constexpr float lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr float epsilon() noexcept {
        return 1.192092896e-07F;
    }

    [[nodiscard]] static constexpr float round_error() noexcept {
        return 0.5F;
    }

    [[nodiscard]] static constexpr float denorm_min() noexcept {
        return 1.401298464e-45F;
    }

    [[nodiscard]] static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    [[nodiscard]] static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    [[nodiscard]] static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }

    static constexpr int digits         = 24;
    static constexpr int digits10       = 6;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent   = (-125);
    static constexpr int min_exponent10 = (-37);
};

template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr double round_error() noexcept {
        return 0.5;
    }

    [[nodiscard]] static constexpr double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};

template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr long double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr long double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr long double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    [[nodiscard]] static constexpr long double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};




template <class _Ty>
[[nodiscard]] constexpr int _Countl_zero_fallback(_Ty _Val) noexcept {
    _Ty _Yy = 0;

    unsigned int _Nn = numeric_limits<_Ty>::digits;
    unsigned int _Cc = numeric_limits<_Ty>::digits / 2;
    do {
        _Yy = static_cast<_Ty>(_Val >> _Cc);
        if (_Yy != 0) {
            _Nn -= _Cc;
            _Val = _Yy;
        }
        _Cc >>= 1;
    } while (_Cc != 0);
    return static_cast<int>(_Nn) - static_cast<int>(_Val);
}




template <class _Ty>
[[nodiscard]] constexpr int _Countr_zero_fallback(const _Ty _Val) noexcept {
    constexpr int _Digits = std::numeric_limits<_Ty>::digits;
    return _Digits - _Countl_zero_fallback(static_cast<_Ty>(static_cast<_Ty>(~_Val) & static_cast<_Ty>(_Val - 1)));
}



template <class _Ty>
[[nodiscard]] constexpr int _Popcount_fallback(_Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    
    _Val = static_cast<_Ty>(_Val - ((_Val >> 1) & static_cast<_Ty>(0x5555'5555'5555'5555ull)));
    _Val = static_cast<_Ty>((_Val & static_cast<_Ty>(0x3333'3333'3333'3333ull))
                            + ((_Val >> 2) & static_cast<_Ty>(0x3333'3333'3333'3333ull)));
    _Val = static_cast<_Ty>((_Val + (_Val >> 4)) & static_cast<_Ty>(0x0F0F'0F0F'0F0F'0F0Full));
    for (int _Shift_digits = 8; _Shift_digits < _Digits; _Shift_digits <<= 1) {
        _Val = static_cast<_Ty>(_Val + static_cast<_Ty>(_Val >> _Shift_digits));
    }
    
    return static_cast<int>(_Val & static_cast<_Ty>(_Digits + _Digits - 1));
}


extern "C" {
extern int __isa_available;






#line 1045 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countr_zero(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;
    constexpr _Ty _Max    = (numeric_limits<_Ty>::max) ();


    
    
    
    if constexpr (_Digits > 16) {
        const bool _Definitely_have_tzcnt = __isa_available >= __ISA_AVAILABLE_AVX2;
        if (!_Definitely_have_tzcnt && _Val == 0) {
            return _Digits;
        }
    }
#line 1063 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"

    if constexpr (_Digits <= 32) {
        
        
        
        return static_cast<int>(_tzcnt_u32(static_cast<unsigned int>(~_Max | _Val)));
    } else {









        return static_cast<int>(_tzcnt_u64(_Val));
#line 1081 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
    }
}


#line 1086 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"





#line 1093 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"


template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_popcount(const _Ty _Val) noexcept {
    constexpr int _Digits = numeric_limits<_Ty>::digits;

    const bool _Definitely_have_popcnt = __isa_available >= __ISA_AVAILABLE_SSE42;
    if (!_Definitely_have_popcnt) {
        return _Popcount_fallback(_Val);
    }
#line 1104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"

    if constexpr (_Digits <= 16) {
        return static_cast<int>(__popcnt16(_Val));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__popcnt(_Val));
    } else {



        return static_cast<int>(__popcnt64(_Val));
#line 1115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
    }
}
#line 1118 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"

template <class _Ty>
constexpr bool _Is_standard_unsigned_integer =
    _Is_any_of_v<remove_cv_t<_Ty>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int _Countr_zero(const _Ty _Val) noexcept {





#line 1131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#line 1132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
    
    return _Countr_zero_fallback(_Val);
}

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> _Enabled = 0>
[[nodiscard]] inline int _Popcount(const _Ty _Val) noexcept {



#line 1142 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
    {
        return _Checked_x86_x64_popcount(_Val);
    }
#line 1146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
    return _Popcount_fallback(_Val);
}



}


#pragma warning(pop)
#pragma pack(pop)
#line 1157 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#line 1158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\limits"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\new"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"





#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new_debug.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )
#pragma warning(disable: 4985) 


extern "C++" {

#pragma pack(push, 8)













    namespace std
    {
        struct nothrow_t {
            explicit nothrow_t() = default;
        };

        


            extern nothrow_t const nothrow;
        #line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new.h"
    }
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new.h"

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;
































































#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
    [[nodiscard]]      
    inline void* __cdecl operator new(size_t _Size,   void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new.h"


    
    [[nodiscard]]      
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma pack(pop)

} 
#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new_debug.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C++" {

#pragma pack(push, 8)






    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_new_debug.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;


























    

        __declspec(dllimport) int*  __cdecl __p__crtDbgFlag(void);
        __declspec(dllimport) long* __cdecl __p__crtBreakAlloc(void);

        
        

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );

    #line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"

    __declspec(dllimport) int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

    __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );

    __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(void);

    __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );

    __declspec(dllimport) void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );

    __declspec(dllimport) int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );

     
    __declspec(dllimport) int __cdecl _CrtReportBlockType(
          void const* _Block
        );

    __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );

    __declspec(dllimport) int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );

#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"
















































    












































    __declspec(dllimport) void __cdecl _aligned_free_dbg(
            void* _Block
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );

    __declspec(dllimport) void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
          char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );


     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
          wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );

    
    

    







#line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"

#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"





















    __declspec(dllimport) int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);

    __declspec(dllimport) int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);


    __declspec(dllimport) int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );

    __declspec(dllimport) int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );

    __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );

    __declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(void);

    __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );

    __declspec(dllimport) int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

    

        extern long _crtAssertBusy;

        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        
        
        
        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );

    #line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"

#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"







































    

    
    
    
        





    #line 741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"

    
        
    #line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"

    
        
    #line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"

    



    



    
    

    
    

    
    

    
    

#line 771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"













    
#line 786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#pragma warning(pop) 
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\crtdbg.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"




















    

#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
        
    #line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"



    

#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
        
    #line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"



    

#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
        
    #line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"





    


#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
        
        
    


#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"


    

#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
        
            
        

#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
    #line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"


    

#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"

#line 80 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
        
    #line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
#line 83 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )












#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"















#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 51 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"






















































#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"











#line 119 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 120 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"








#line 129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"



#pragma detect_mismatch("_MSC_VER", "1900")
#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"




#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#line 147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#line 149 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#line 151 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 153 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"




#line 158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#line 160 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 161 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"



#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"






#line 172 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"





























#line 203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"





#line 209 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"







#line 217 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"






#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 225 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"





#line 231 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"





#pragma once








#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"
















#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"









#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"




#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "d" "")






#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"

#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"

#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\use_ansi.h"
#pragma external_header(pop)
#line 234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"



















#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"






#line 261 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 262 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"



#line 266 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"






#line 273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"












#line 287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"



#line 291 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"






#line 299 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"






#line 307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 308 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"




#line 313 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#line 315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
















#line 333 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

#line 335 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 336 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"



#line 340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"



#line 344 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"


namespace std {
enum _Uninitialized { 
    _Noinit
};

class __declspec(dllimport) _Lockit { 
public:














    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; 
    __thiscall ~_Lockit() noexcept; 
#line 371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
     _Lockit(const _Lockit&) = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};








































































#line 460 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

class __declspec(dllimport) _Init_locks { 
public:










    __thiscall _Init_locks() noexcept;
    __thiscall ~_Init_locks() noexcept;
#line 476 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"

private:
    static void __cdecl _Init_locks_ctor(_Init_locks*) noexcept;
    static void __cdecl _Init_locks_dtor(_Init_locks*) noexcept;
};




































#line 518 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
}
#line 520 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"







#pragma warning(pop)
#pragma pack(pop)
#line 530 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#line 531 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\yvals.h"
#pragma external_header(pop)
#line 10 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class _Ty, _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    [[nodiscard]] static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { 
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

template <class... _Traits>
struct conjunction : true_type {}; 

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    
};

template <class... _Traits>
 constexpr bool conjunction_v = conjunction<_Traits...>::value;

template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; 

template <class _Trait>
 constexpr bool negation_v = negation<_Trait>::value;

template <class _Ty>
 constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

template <class... _Types>
using void_t = void;


template <class _Ty>
struct add_const { 
    using type = const _Ty;
};

template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};

template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};

template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

template <class _Ty, class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept;

template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

template <class _Ty, class = void>
struct _Add_pointer { 
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};

template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

template <class>
 constexpr bool is_array_v = false; 

template <class _Ty, size_t _Nx>
 constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
 constexpr bool is_array_v<_Ty[]> = true;

template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};



















#line 250 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class>
 constexpr bool is_lvalue_reference_v = false; 

template <class _Ty>
 constexpr bool is_lvalue_reference_v<_Ty&> = true;

template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

template <class>
 constexpr bool is_rvalue_reference_v = false; 

template <class _Ty>
 constexpr bool is_rvalue_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

template <class>
 constexpr bool is_reference_v = false; 

template <class _Ty>
 constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
 constexpr bool is_reference_v<_Ty&&> = true;

template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

template <class>
 constexpr bool is_pointer_v = false; 

template <class _Ty>
 constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
 constexpr bool is_pointer_v<_Ty* const volatile> = true;

template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; 

template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_union_v = __is_union(_Ty);

template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_class_v = __is_class(_Ty);

template <class _Ty>
 constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; 

template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    
};

template <class _From, class _To>
 constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_enum_v = __is_enum(_Ty);







#line 345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; 

template <class _Ty>
 constexpr bool is_compound_v = !is_fundamental_v<_Ty>;

template <class... _Types>
struct _Arg_types {}; 

template <class _Ty1>
struct _Arg_types<_Ty1> {
     typedef _Ty1 argument_type;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
     typedef _Ty1 first_argument_type;
     typedef _Ty2 second_argument_type;
};

template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type; 
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };






template <class _Ty>
 constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#line 404 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

template <class>
 constexpr bool is_const_v = false; 

template <class _Ty>
 constexpr bool is_const_v<const _Ty> = true;

template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

template <class>
 constexpr bool is_volatile_v = false; 

template <class _Ty>
 constexpr bool is_volatile_v<volatile _Ty> = true;

template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_function_v = 
    !is_const_v<const _Ty> && !is_reference_v<_Ty>;

template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {};

template <class _Ty>
 constexpr bool is_object_v = 
    is_const_v<const _Ty> && !is_void_v<_Ty>;

template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {};

template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type           = _Ty2;
};





template <class _Ty>
 constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#line 458 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};





template <class _Ty>
 constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#line 469 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; 

template <class _Ty>
 constexpr bool is_scalar_v = 
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

template <class _Ty>
struct  is_pod : bool_constant<__is_pod(_Ty)> {}; 

template <class _Ty>
  constexpr bool is_pod_v = __is_pod(_Ty);

template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_empty_v = __is_empty(_Ty);

template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_abstract_v = __is_abstract(_Ty);

template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_final_v = __is_final(_Ty);

template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; 

template <class _Ty>
 constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);


template <class _Ty>
struct  is_literal_type : bool_constant<__is_literal_type(_Ty)> {
    
};

template <class _Ty>
  constexpr bool is_literal_type_v = __is_literal_type(_Ty);
#line 525 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"


template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);






#line 541 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    
};

template <class _Ty>
 constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);















#line 573 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_default_constructible_v = __is_constructible(_Ty);

template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};

template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; 

template <class _To, class _From>
 constexpr bool is_assignable_v = __is_assignable(_To, _From);

template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
 constexpr bool _Is_copy_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);






#line 650 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
 constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, _Ty);






#line 674 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_destructible_v = __is_destructible(_Ty);

template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    
};

template <class _To, class _From>
 constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    
};

template <class _Ty, class... _Args>
 constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
    
};

template <class _Ty>
 constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    
};

template <class _To, class _From>
 constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

template <class _Ty>
 constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    
    
};

template <class _Ty>
 constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { 
                                
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; 

template <class _Ty>
 constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; 

template <class _Ty>
 constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

template <class _Ty>
 constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

template <bool>
struct _Select { 
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; 

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = 
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_signed { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

template <size_t>
struct _Make_unsigned2; 

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = 
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

template <class _Ty>
struct make_unsigned { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; 

template <class _Ty>
 constexpr size_t alignment_of_v = alignof(_Ty);

template <class _Ty, size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; 

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "Please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
        "that you actually want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conforming "
        "behavior.");
#line 997 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 999 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next                 = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next                 = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next                 = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct aligned_storage { 
    using _Next                 = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; 

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; 

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    
};

template <size_t _Len, class... _Types>
struct aligned_union { 
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = aligned_storage_t<_Max_len, alignment_value>;
};

template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template <class _Ty>
struct _Underlying_type<_Ty, false> {};

template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {}; 

template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;

template <class _Ty>
 constexpr size_t rank_v = 0; 

template <class _Ty, size_t _Nx>
 constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
 constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

template <class _Ty, unsigned int _Ix = 0>
 constexpr size_t extent_v = 0; 

template <class _Ty, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
 constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
 constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    
};

template <class _Base, class _Derived>
 constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

template <class _Ty>
using decay_t = typename decay<_Ty>::type;

template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());














#line 1133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {};
#line 1136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

template <class... _Ty>
struct common_type;

template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};











































































































































#line 1312 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t = typename _Identity<_Ty>::type;








#line 1328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Type, template <class...> class _Template>
 constexpr bool _Is_specialization_v = false; 
template <template <class...> class _Template, class... _Types>
 constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept { 
    return static_cast<_Ty&&>(_Arg);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept { 
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

template <class _Ty>
[[nodiscard]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { 
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

template <class _Ty>
[[nodiscard]] constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&,
    _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept { 
    return ::std:: move(_Arg);
}

template <class _Ty>
class reference_wrapper;





#pragma warning(push) 
#pragma warning(disable : 28278) 
enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(
        noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)))
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd) {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd) {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};

template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
struct _Invoker1;

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmf_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
          is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
          _Invoker_pmd_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {};

template <class _Callable>
inline auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
    -> decltype(static_cast<_Callable&&>(_Obj)()) {
    return static_cast<_Callable&&>(_Obj)();
}

template <class _Callable, class _Ty1, class... _Types2>
inline auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)))
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
        return _Arg1.get().*_Obj;
    } else {
        static_assert(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer, "bug in invoke");
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}
#pragma warning(pop) 

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 
#pragma warning(disable : 5215) 






template <class _To>
void _Implicitly_convert_to(_To) noexcept; 

template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
 constexpr bool _Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to<_To>(::std:: declval<_From>()));





#pragma warning(pop)

template <class _From, class _To, bool _IsVoid>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
 constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    
};







#line 1547 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
_Ty _Returns_exactly() noexcept; 

template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {};

template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(_Implicitly_convert_to<_To>(_Returns_exactly<_From>()))>>
    : true_type {};

template <class _From, class _To>
struct _Invoke_nothrow_convertible : bool_constant<noexcept(_Implicitly_convert_to<_To>(_Returns_exactly<_From>()))> {};

template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type                  = _Result;
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
            conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};

template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable>
using _Decltype_invoke_zero = decltype(::std:: declval<_Callable>()());

template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(::std:: declval<_Callable>()())> {};

template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...));

template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                          ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...))> {};

template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;


template <class _Fty>
struct  result_of { 
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
                                       "result_of<CallableType(zero or more argument types)> instead.");
};







template <class _Callable, class... _Args> struct  result_of<_Callable __cdecl(_Args...)> : _Select_invoke_traits<_Callable, _Args...> { };    template <class _Callable, class... _Args> struct  result_of<_Callable __vectorcall(_Args...)> : _Select_invoke_traits<_Callable, _Args...> { };


__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
using result_of_t  = typename result_of<_Ty>::type;
__pragma(warning(pop))
#line 1638 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};










































#line 1692 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"



























#line 1720 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct _Function_args {}; 







template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)   > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)   > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const  > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const  > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile  > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile & > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  && > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const && > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile && > : _Arg_types<_Types...> {  typedef _Ret result_type; };








template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) > {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&&> {  typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&&> {  typedef _Ret result_type; };


template <class _Ty, class = void>
struct _Weak_result_type {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
     typedef typename _Ty::result_type result_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    
     typedef typename _Ty::argument_type argument_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
     typedef typename _Ty::first_argument_type first_argument_type;
     typedef typename _Ty::second_argument_type second_argument_type;
};
__pragma(warning(pop))

template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;

template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>> : true_type {};

template <class _Ty>
class reference_wrapper

    : public _Weak_types<_Ty>
#line 1796 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
{
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    inline reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) {
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    inline operator _Ty&() const noexcept {
        return *_Ptr;
    }

    [[nodiscard]] inline _Ty& get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template <class... _Types>
    inline auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...))) 
        -> decltype(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)) {
        return ::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};




#line 1835 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

template <class _Ty>
void ref(const _Ty&&) = delete;

template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: ref(_Val.get());
}

template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

template <class _Ty>
void cref(const _Ty&&) = delete;

template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return ::std:: cref(_Val.get());
}



















#line 1881 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

template <class _Ty>
struct _Is_swappable;

template <class _Ty>
struct _Is_nothrow_swappable;



#line 1891 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
template <class _Ty, int _Enabled = 0>
#line 1893 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
inline void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
inline void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; 

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; 

template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    
};

template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};

template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>())) 
                                    && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    
    
};

template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    
    
};

template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};


































#line 1970 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

namespace _Has_ADL_swap_detail {
    void swap(); 

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
 constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;






template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    
};















































 constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
 constexpr size_t _FNV_prime        = 1099511628211ULL;



#line 2047 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { 
     typedef _Kty argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))  {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                   = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)      = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
};

template <class _Kty>
struct hash
    : _Conditionally_enabled_hash<_Kty,
          !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
     typedef float argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};

template <>
struct hash<double> {
     typedef double argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};

template <>
struct hash<long double> {
     typedef long double argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};

template <>
struct hash<nullptr_t> {
     typedef nullptr_t argument_type;
     typedef size_t result_type;
    [[nodiscard]] size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; 

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};



template <class _FloatingType>
struct _Floating_type_traits;

template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits           = 24; 
    static constexpr int32_t _Exponent_bits           = 8; 
    static constexpr int32_t _Maximum_binary_exponent = 127; 
    static constexpr int32_t _Minimum_binary_exponent = -126; 
    static constexpr int32_t _Exponent_bias           = 127;
    static constexpr int32_t _Sign_shift              = 31; 
    static constexpr int32_t _Exponent_shift          = 23; 

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask             = 0x000000FFu; 
    static constexpr uint32_t _Normal_mantissa_mask      = 0x00FFFFFFu; 
    static constexpr uint32_t _Denormal_mantissa_mask    = 0x007FFFFFu; 
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; 
    static constexpr uint32_t _Shifted_sign_mask         = 0x80000000u; 
    static constexpr uint32_t _Shifted_exponent_mask     = 0x7F800000u; 
};

template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits           = 53; 
    static constexpr int32_t _Exponent_bits           = 11; 
    static constexpr int32_t _Maximum_binary_exponent = 1023; 
    static constexpr int32_t _Minimum_binary_exponent = -1022; 
    static constexpr int32_t _Exponent_bias           = 1023;
    static constexpr int32_t _Sign_shift              = 63; 
    static constexpr int32_t _Exponent_shift          = 52; 

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask             = 0x00000000000007FFu; 
    static constexpr uint64_t _Normal_mantissa_mask      = 0x001FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Denormal_mantissa_mask    = 0x000FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; 
    static constexpr uint64_t _Shifted_sign_mask         = 0x8000000000000000u; 
    static constexpr uint64_t _Shifted_exponent_mask     = 0x7FF0000000000000u; 
};

template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {};




__pragma(warning(push)) __pragma(warning(disable : 4996))
namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: add_const;
    using ::std:: add_cv;
    using ::std:: add_pointer;
    using ::std:: add_volatile;
    using ::std:: aligned_storage;
    using ::std:: alignment_of;
    using ::std:: conditional;
    using ::std:: decay;
    using ::std:: enable_if;
    using ::std:: extent;
    using ::std:: false_type;
    using ::std:: has_virtual_destructor;
    using ::std:: integral_constant;
    using ::std:: is_abstract;
    using ::std:: is_arithmetic;
    using ::std:: is_array;
    using ::std:: is_base_of;
    using ::std:: is_class;
    using ::std:: is_compound;
    using ::std:: is_const;
    using ::std:: is_convertible;
    using ::std:: is_empty;
    using ::std:: is_enum;
    using ::std:: is_floating_point;
    using ::std:: is_function;
    using ::std:: is_fundamental;
    using ::std:: is_integral;
    using ::std:: is_member_function_pointer;
    using ::std:: is_member_object_pointer;
    using ::std:: is_member_pointer;
    using ::std:: is_object;
    using ::std:: is_pod;
    using ::std:: is_pointer;
    using ::std:: is_polymorphic;
    using ::std:: is_reference;
    using ::std:: is_same;
    using ::std:: is_scalar;
    using ::std:: is_signed;
    using ::std:: is_union;
    using ::std:: is_unsigned;
    using ::std:: is_void;
    using ::std:: is_volatile;
    using ::std:: make_signed;
    using ::std:: make_unsigned;
    using ::std:: rank;
    using ::std:: remove_all_extents;
    using ::std:: remove_const;
    using ::std:: remove_cv;
    using ::std:: remove_extent;
    using ::std:: remove_pointer;
    using ::std:: remove_reference;
    using ::std:: remove_volatile;
    using ::std:: true_type;
    using ::std:: cref;
    using ::std:: ref;
    using ::std:: reference_wrapper;

    using ::std:: result_of;
#line 2276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
    using ::std:: hash;
} 
__pragma(warning(pop))
#line 2280 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"

}



#pragma warning(pop)
#pragma pack(pop)

#line 2289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
#line 2290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\type_traits"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {


  bool __cdecl uncaught_exception() noexcept;
#line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"
 int __cdecl uncaught_exceptions() noexcept;

}



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





    


#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"













typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;






   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"

    
          __declspec(dllimport) int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    
        
    

#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"

    static_assert((sizeof(unsigned int) <= 16), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE");


    #pragma warning(push)
    #pragma warning(disable: 6540) 
                                   

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"






    
        
        




    #line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"












#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"




#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014) 
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC)
            {
                (void)( (!!((("Corrupted pointer passed to _freea" && 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h", 164, 0, L"%ls", L"(\"Corrupted pointer passed to _freea\" && 0)")) || (__debugbreak(), 0) );
            }
            #line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"




    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\malloc.h"
#pragma external_header(pop)
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_exception.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\eh.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_terminate.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )(void);
typedef void (__cdecl* terminate_function)(void);








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_terminate.h"

#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_terminate.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\eh.h"



#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* unexpected_handler )(void);
typedef void (__cdecl* unexpected_function)(void);






struct _EXCEPTION_POINTERS;



     __declspec(noreturn) void __cdecl unexpected() noexcept(false);

    

         unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) noexcept;

         unexpected_handler __cdecl _get_unexpected() noexcept;

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    #line 52 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\eh.h"

    class type_info;

     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();

#line 64 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\eh.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 70 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\eh.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_exception.h"







#pragma warning(push)
#pragma warning(disable:   4514 4820 )

#pragma pack(push, 8)

__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class exception
{
public:

    exception() noexcept
        : _Data()
    {
    }

    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }

    [[nodiscard]] virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};

#pragma warning(pop)

} 

#pragma pack(pop)

#pragma warning(pop) 
#line 153 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_exception.h"
#pragma external_header(pop)
#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"

namespace std {

using ::terminate;


using ::set_terminate;
using ::terminate_handler;

[[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept { 
    return _get_terminate();
}
#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"


using ::unexpected;


using ::set_unexpected;
using ::unexpected_handler;

[[nodiscard]] inline unexpected_handler __cdecl get_unexpected() noexcept { 
    return _get_unexpected();
}
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"
#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"

}




































































































































#line 195 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"

 void __cdecl __ExceptionPtrCreate(  void*) noexcept;
 void __cdecl __ExceptionPtrDestroy(  void*) noexcept;
 void __cdecl __ExceptionPtrCopy(  void*,   const void*) noexcept;
 void __cdecl __ExceptionPtrAssign(  void*,   const void*) noexcept;
 bool __cdecl __ExceptionPtrCompare(  const void*,   const void*) noexcept;
 bool __cdecl __ExceptionPtrToBool(  const void*) noexcept;
 void __cdecl __ExceptionPtrSwap(  void*,   void*) noexcept;
 void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
[[noreturn]]  void __cdecl __ExceptionPtrRethrow(  const void*);
 void __cdecl __ExceptionPtrCopyException(
      void*,   const void*,   const void*) noexcept;

namespace std {

class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }

    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }

    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);
    }

    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }

    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }

    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }

    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }

    static exception_ptr _Current_exception() noexcept {
        exception_ptr _Retval;
        __ExceptionPtrCurrentException(&_Retval);
        return _Retval;
    }

    static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }

    friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept {
        return !_Rhs;
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !_Lhs;
    }

    [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

    [[nodiscard]] friend bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

    [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

private:




    void* _Data1;
    void* _Data2;



};

[[nodiscard]] inline exception_ptr current_exception() noexcept {
    return exception_ptr::_Current_exception();
}

[[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr) {
    __ExceptionPtrRethrow(&_Ptr);
}

template <class _Ex>
void* __GetExceptionInfo(_Ex);

template <class _Ex>
[[nodiscard]] exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
}

[[noreturn]] inline void _Throw_bad_array_new_length() {
    throw bad_array_new_length{};
}

class nested_exception { 
public:
    nested_exception() noexcept : _Exc(::std:: current_exception()) {}

    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}

    [[noreturn]] void rethrow_nested() const { 
        if (_Exc) {
            ::std:: rethrow_exception(_Exc);
        } else {
            ::std:: terminate();
        }
    }

    [[nodiscard]] exception_ptr nested_ptr() const noexcept { 
        return _Exc;
    }

private:
    exception_ptr _Exc;
};

template <class _Ty, class _Uty>
struct _With_nested : _Uty, nested_exception { 
    explicit _With_nested(_Ty&& _Arg)
        : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception() {} 
};

template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg) { 
    using _Uty = decay_t<_Ty>;

    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        
        using _Glued = _With_nested<_Ty, _Uty>;
        throw _Glued(::std:: forward<_Ty>(_Arg));
    } else {
        
        throw ::std:: forward<_Ty>(_Arg);
    }
}


template <class _Ty>
void _Rethrow_if_nested(const _Ty* _Ptr, true_type) { 
    const auto _Nested = dynamic_cast<const nested_exception*>(_Ptr);

    if (_Nested) {
        _Nested->rethrow_nested();
    }
}

template <class _Ty>
void _Rethrow_if_nested(const _Ty*, false_type) {} 

template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg) { 
    bool_constant<
        is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>)>
        _Tag;

    _Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
}



#line 388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"

}



#pragma warning(pop)
#pragma pack(pop)

#line 397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"
#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\exception"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\new"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {





#line 28 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\new"
















#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\new"



using new_handler = void(__cdecl*)();
#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\new"

 new_handler __cdecl set_new_handler(  new_handler) noexcept;
[[nodiscard]]  new_handler __cdecl get_new_handler() noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\new"
#line 62 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\new"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xatomic.h"





#pragma once








#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )

















#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xatomic.h"












#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xatomic.h"




namespace std {
























#line 79 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xatomic.h"
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xatomic.h"

using _Atomic_counter_t = unsigned long;

template <class _Integral, class _Ty>
[[nodiscard]] volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}

template <class _Integral, class _Ty>
[[nodiscard]] const volatile _Integral* _Atomic_address_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<const volatile _Integral&>(_Source);
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xatomic.h"
#line 113 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xatomic.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"





#pragma once







#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstring"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memory.h"










#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memory.h"

    












#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memory.h"

#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memory.h"





    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_memory.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 

#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"
    
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"





    
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );
    

    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );

#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\string.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: size_t;
using :: memchr;
using :: memcmp;
using :: memcpy;
using :: memmove;
using :: memset;
using :: strcat;
using :: strchr;
using :: strcmp;
using :: strcoll;
using :: strcpy;
using :: strcspn;
using :: strerror;
using :: strlen;
using :: strncat;
using :: strncmp;
using :: strncpy;
using :: strpbrk;
using :: strrchr;
using :: strspn;
using :: strstr;
using :: strtok;
using :: strxfrm;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstring"
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cstring"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"





#pragma once













#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right)))  {
    
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
template <class _Ty>
[[nodiscard]]   constexpr const _Ty& 
    (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right))  {
    
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)

template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>, _Pr); 

template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>); 

template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left)))  {
    
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
template <class _Ty>
[[nodiscard]]   constexpr const _Ty& 
    (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left))  {
    
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)

template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>, _Pr); 

template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>); 

template <class _FwdIt1, class _FwdIt2>
inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { 
    swap(*_Left, *_Right);
}

template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> _Enabled>
inline void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    if (&_Left != &_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            ::std:: iter_swap(_First1, _First2);
        }
    }
}



#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"
template <class _Ty, int _Enabled>
#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"
inline void swap(_Ty& _Left, _Ty& _Right) noexcept(
    is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}

template <class _Ty>
inline void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    swap(_Left, _Right);
}

struct piecewise_construct_t { 
    explicit piecewise_construct_t() = default;
};

 constexpr piecewise_construct_t piecewise_construct{};

template <class...>
class tuple;

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

template <class _Ty1, class _Ty2>
struct pair { 
    using first_type  = _Ty1;
    using second_type = _Ty2;


    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>)
        pair() noexcept(
            is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
        : first(), second() {}

















#line 153 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"


    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>)
        pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
            is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}

















#line 179 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"




#line 184 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"
    template <class _Other1, class _Other2,
#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {
    }
















#line 209 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"

    pair(const pair&) = default;
    pair(pair&&)      = default;


    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>,
            int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>)
        pair(const pair<_Other1, _Other2>& _Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&&
                is_nothrow_constructible_v<_Ty2, const _Other2&>) 
        : first(_Right.first), second(_Right.second) {}


















#line 240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"


    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}
















#line 265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"

    template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>)
        : first(_Tuple_get<_Indexes1>(::std:: move(_Val1))...), second(_Tuple_get<_Indexes2>(::std:: move(_Val2))...) {}

    template <class... _Types1, class... _Types2>
    inline pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    inline pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    inline pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)  {
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    inline pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, const _Other1&>&&
            is_nothrow_assignable_v<_Ty2&, const _Other2&>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    inline pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>)  {
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }

    inline void swap(pair& _Right) noexcept(
        _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        if (this != ::std:: addressof(_Right)) {
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }

    _Ty1 first; 
    _Ty2 second; 
};




#line 337 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"

template <class _Ty1, class _Ty2, enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
inline void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Left.first == _Right.first && _Left.second == _Right.second;
}












template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return !(_Left == _Right);
}
#line 364 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return _Right < _Left;
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) {
    return !(_Left < _Right);
}
#line 385 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"

template <class _Ty>
struct _Unrefwrap_helper { 
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { 
    using type = _Ty&;
};


template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&&
        is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)  {
    
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}

namespace  rel_ops {
    template <class _Ty>
     [[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left == _Right);
    }

    template <class _Ty>
     [[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right) {
        return _Right < _Left;
    }

    template <class _Ty>
     [[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Right < _Left);
    }

    template <class _Ty>
     [[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left < _Right);
    }
} 

template <class _Tuple>
struct tuple_size;

template <class _Tuple, class = void>
struct _Tuple_size_sfinae {}; 

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {}; 

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct  tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct  tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Ty>
 constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

template <size_t _Index, class _Tuple>
struct tuple_element;

template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct  [[msvc::known_semantics]] tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct  [[msvc::known_semantics]] tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

template <class _Ty, size_t _Size>
class array;

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {}; 

template <size_t _Idx, class _Ty, size_t _Size>
struct [[msvc::known_semantics]] tuple_element<_Idx, array<_Ty, _Size>> {
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};

template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {}; 

template <size_t _Index>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<>> { 
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<0, tuple<_This, _Rest...>> { 
    using type = _This;
    
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {}; 

template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {}; 

template <size_t _Idx, class _Ty1, class _Ty2>
struct [[msvc::known_semantics]] tuple_element<_Idx, pair<_Ty1, _Ty2>> {
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 0>) noexcept { 
    return _Pr.first;
}

template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 1>) noexcept { 
    return _Pr.second;
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    pair<_Ty1, _Ty2>& _Pr) noexcept { 
    using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>{});
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<0>(_Pr);
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<1>(_Pr);
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>{});
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<0>(_Pr);
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<1>(_Pr);
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<0>(::std:: move(_Pr));
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<1>(::std:: move(_Pr));
}

template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<0>(::std:: move(_Pr));
}

template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<1>(::std:: move(_Pr));
}

template <class _Ty, class _Other = _Ty>
inline _Ty exchange(_Ty& _Val, _Other&& _New_val) noexcept(
    conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>)  {
    
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

template <class _Ty>
[[nodiscard]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { 
    return _Val;
}

template <class _Ty>
void as_const(const _Ty&&) = delete;




















#line 640 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"










































































































#line 747 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"






#line 754 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: get;
    using ::std:: tuple_element;
    using ::std:: tuple_size;
} 
#line 762 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"

}



#pragma warning(pop)
#pragma pack(pop)
#line 770 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"
#line 771 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\utility"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )







#line 28 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"






#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"





#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"


extern "C" {







__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;
}
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

namespace std {

template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To _Bit_cast(const _From& _Val) noexcept {





    return __builtin_bit_cast(_To, _Val);
#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
}

template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { 
    using type = _First;
};

template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { 
    using type = _Ty<_Newfirst, _Rest...>;
};

template <class _Ty, class = void>
struct _Get_element_type {
    using type = typename _Get_first_parameter<_Ty>::type;
};

template <class _Ty>
struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>> {
    using type = typename _Ty::element_type;
};

template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};

template <class _Iter>
[[nodiscard]] constexpr void* _Voidify_iter(_Iter _It) noexcept {
    if constexpr (is_pointer_v<_Iter>) {
        return const_cast<void*>(static_cast<const volatile void*>(_It));
    } else {
        return const_cast<void*>(static_cast<const volatile void*>(::std:: addressof(*_It)));
    }
}








#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _Ty, class... _Types>
inline void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_constructible_v<_Ty, _Types...>) {




#line 148 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
    {
        ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty(::std:: forward<_Types>(_Args)...);
    }
}

template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
    ::new (_Voidify_iter(::std:: addressof(_Obj))) _Ty;
}

template <class _Ty>
struct pointer_traits {
    using pointer         = _Ty;
    using element_type    = typename _Get_element_type<_Ty>::type;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<element_type>, char, element_type>&;

    [[nodiscard]] static pointer pointer_to(_Reftype _Val) noexcept(noexcept(_Ty::pointer_to(_Val)))  {
        return _Ty::pointer_to(_Val);
    }
};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer         = _Ty*;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

    [[nodiscard]] static inline pointer pointer_to(_Reftype _Val) noexcept {
        return ::std:: addressof(_Val);
    }
};

































#line 223 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"


template <class _Fx>
struct _Ref_fn { 
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) { 
        if constexpr (is_member_pointer_v<_Fx>) {
            return ::std:: invoke(_Fn, ::std:: forward<_Args>(_Vals)...);
        } else {
            return _Fn(::std:: forward<_Args>(_Vals)...);
        }
    }

    _Fx& _Fn;
};

template <class _Fn>
 constexpr bool _Pass_functor_by_value_v = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
    is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;

template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0> 
constexpr _Fn _Pass_fn(_Fn _Val) { 
    return _Val;
}

template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val) { 
    return {_Val};
}

struct _Unused_parameter { 
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

using _Any_tag = _Unused_parameter; 

template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;


struct input_iterator_tag {};

struct output_iterator_tag {};

struct forward_iterator_tag : input_iterator_tag {};

struct bidirectional_iterator_tag : forward_iterator_tag {};

struct random_access_iterator_tag : bidirectional_iterator_tag {};



















































































































































































































































































































































































































































































































































































































































































































































































































































































template <class, class = void>
struct _Iterator_traits_base {}; 

template <class _Iter>
struct _Iterator_traits_base<_Iter,
    void_t<typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type,
        typename _Iter::pointer, typename _Iter::reference>> {
    
    using iterator_category = typename _Iter::iterator_category;
    using value_type = typename _Iter::value_type;
    using difference_type = typename _Iter::difference_type;
    using pointer = typename _Iter::pointer;
    using reference = typename _Iter::reference;
};

template <class _Ty, bool = is_object_v<_Ty>>
struct _Iterator_traits_pointer_base { 
    using iterator_category = random_access_iterator_tag;
    using value_type = remove_cv_t<_Ty>;
    using difference_type = ptrdiff_t;
    using pointer = _Ty*;
    using reference = _Ty&;
};

template <class _Ty>
struct _Iterator_traits_pointer_base<_Ty, false> {}; 

template <class _Iter>
struct iterator_traits : _Iterator_traits_base<_Iter> {}; 

template <class _Ty>
struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty> {}; 

template <class _Iter>
using _Iter_ref_t = typename iterator_traits<_Iter>::reference;

template <class _Iter>
using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

template <class _Iter>
using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
#line 1167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

template <class _Ty, class = void>
 constexpr bool _Is_iterator_v = false;

template <class _Ty>
 constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};

template <class _Iter>
 constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

template <class _Iter>
 constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

template <class _Iter>
 constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

template <class _Iter>
 constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

template <class, class = void>
struct _Is_checked_helper {}; 


template <class _Ty>
constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {
    
    do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1202, 0, "%s", "transposed pointer range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"transposed pointer range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1202, 0); } while (false); } ; } while (false);
}
#line 1205 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _Iter, class = void>
 constexpr bool _Allow_inheriting_unwrap_v = true;

template <class _Iter>
 constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
    is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

template <class _Iter, class _Sentinel = _Iter, class = void>
 constexpr bool _Range_verifiable_v = false;

template <class _Iter, class _Sentinel>
 constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>> =
    _Allow_inheriting_unwrap_v<_Iter>;

template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
    
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}

template <class _Iter, class = void>
 constexpr bool _Unwrappable_v = false;

template <class _Iter>
 constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(::std:: declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std:: declval<_Iter>()._Unwrapped()))>> =
    _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std:: declval<_Iter>()))>;

template <class _Iter, class = bool>
 constexpr bool _Do_unwrap_when_unverified_v = false;

template <class _Iter>
 constexpr bool
    _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
        static_cast<bool>(_Iter::_Unwrap_when_unverified);

template <class _Iter>
 constexpr bool _Unwrappable_for_unverified_v =
    _Unwrappable_v<_Iter>&& _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<_Iter>()))>;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
 constexpr auto _Max_possible_v = _Diff{static_cast<make_unsigned_t<_Diff>>(-1) >> 1};

template <class _Diff>
 constexpr auto _Min_possible_v = _Diff{-_Max_possible_v<_Diff> - 1};

template <class _Iter, class = void>
 constexpr bool _Offset_verifiable_v = false;

template <class _Iter>
 constexpr bool
    _Offset_verifiable_v<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
        true;

template <class _Iter>
 constexpr bool _Unwrappable_for_offset_v =
    _Unwrappable_v<_Iter>&& _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class _Diff>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
        
        using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff     = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);

        do { if (_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>) && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1315, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1315, 0); } while (false); } ; } while (false);
#line 1316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        (void) _COff;

        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter, class _UIter, class = void>
 constexpr bool _Wrapped_seekable_v = false;

template <class _Iter, class _UIter>
 constexpr bool
    _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<_UIter>()))>> =
        true;

template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(::std:: forward<_UIter>(_UIt));
    } else {
        _It = ::std:: forward<_UIter>(_UIt);
    }
}



































#line 1381 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _Checked, class _Iter>
[[nodiscard]] constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    
    if constexpr (_Is_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        return _Distance_unknown{};
    }
}

template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { 
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { 
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;






#line 1411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"





template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(
    noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left))) {
    
    const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
    if (_Result) {
        do { if (!_Pred(_Right, _Left)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1423, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid comparator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1423, 0); } while (false); } ; } while (false);
    }

    return _Result;
}

template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<!is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(noexcept(_Pred(_Left, _Right))) {
    
    return static_cast<bool>(_Pred(_Left, _Right));
}

template <class _InIt, class _Sentinel, class _Pr>
constexpr void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred) {
    
    if constexpr (_Is_fwd_iter_v<_InIt>) {
        if (_First != _Last) {
            for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
                do { if (!static_cast<bool>(_Pred(*_Next, *_First))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1442, 0, "%s", "sequence not ordered")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"sequence not ordered\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1442, 0); } while (false); } ; } while (false);
            }
        }
    }
}

template <class _OtherIt, class _InIt, class _Pr>
constexpr void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred) {
    
    if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>> && _Is_fwd_iter_v<_InIt>) {
        _Debug_order_unchecked(_First, _Last, _Pred);
    }
}
#line 1456 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"


template <class _InIt, class _Diff>
inline void advance(_InIt& _Where, _Diff _Off) { 
    if constexpr (_Is_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>) {
            do { if (_Off >= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1464, 0, "%s", "negative advance of non-bidirectional iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"negative advance of non-bidirectional iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1464, 0); } while (false); } ; } while (false);
        }

        decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

        if constexpr (is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            _Seek_wrapped(_Where, ::std:: move(_UWhere));
        }
    }
}

template <class _InIt>
[[nodiscard]] inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_random_iter_v<_InIt>) {
        return _Last - _First; 
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { 
    return ++_First;
}

template <class _InIt>
[[nodiscard]] inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { 
    static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");

    ::std:: advance(_First, _Off);
    return _First;
}

template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { 
    return --_First;
}

template <class _BidIt>
[[nodiscard]] inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { 
    static_assert(_Is_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    ::std:: advance(_First, -_Off);
    return _First;
}

template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;







    using iterator_category = _Iter_cat_t<_BidIt>;
#line 1542 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
    using value_type      = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer         = typename iterator_traits<_BidIt>::pointer;
    using reference       = _Iter_ref_t<_BidIt>;

    template <class>
    friend class reverse_iterator;

    inline reverse_iterator() = default;

    inline explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v<_BidIt>) 
        : current(::std:: move(_Right)) {}

    
    template <class _Other>



    inline reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_BidIt, const _Other&>) 
        : current(_Right.current) {}

    template <class _Other>




    inline reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) {
        current = _Right.current;
        return *this;
    }
    

    [[nodiscard]] inline _BidIt base() const {
        return current;
    }

    [[nodiscard]] inline reference operator*() const {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }















    [[nodiscard]] inline pointer operator->() const {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        } else {
            return _Tmp.operator->();
        }
    }
#line 1609 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

    inline reverse_iterator& operator++() {
        --current;
        return *this;
    }

    inline reverse_iterator operator++(int) {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    inline reverse_iterator& operator--() {
        ++current;
        return *this;
    }

    inline reverse_iterator operator--(int) {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    [[nodiscard]] inline reverse_iterator operator+(const difference_type _Off) const {
        return reverse_iterator(current - _Off);
    }

    inline reverse_iterator& operator+=(const difference_type _Off) {
        current -= _Off;
        return *this;
    }

    [[nodiscard]] inline reverse_iterator operator-(const difference_type _Off) const {
        return reverse_iterator(current + _Off);
    }

    inline reverse_iterator& operator-=(const difference_type _Off) {
        current += _Off;
        return *this;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const {
        return current[static_cast<difference_type>(-_Off - 1)];
    }





















    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) {
        _Verify_range(_Last._Get_current(), _First.current); 
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        do { if (_Off != _Min_possible_v<difference_type>) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1683, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility", 1683, 0); } while (false); } ; } while (false);
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) {
        current._Seek_to(_It.current);
    }

    [[nodiscard]] constexpr const _BidIt& _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() == _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() != _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() > _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() < _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() >= _Right._Get_current(); }

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)







{ return _Left._Get_current() <= _Right._Get_current(); }









template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline auto operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    -> decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> operator+(
    typename reverse_iterator<_BidIt>::difference_type _Off, const reverse_iterator<_BidIt>& _Right) {
    return _Right + _Off;
}

template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v<_BidIt>)  {
    return reverse_iterator<_BidIt>(::std:: move(_Iter));
}









template <class _Container>
[[nodiscard]] inline auto begin(_Container& _Cont) -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

template <class _Container>
[[nodiscard]] inline auto begin(const _Container& _Cont) -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

template <class _Container>
[[nodiscard]] inline auto end(_Container& _Cont) -> decltype(_Cont.end()) {
    return _Cont.end();
}

template <class _Container>
[[nodiscard]] inline auto end(const _Container& _Cont) -> decltype(_Cont.end()) {
    return _Cont.end();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
    return _Array + _Size;
}

template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) {
    return ::std:: begin(_Cont);
}

template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) {
    return ::std:: end(_Cont);
}

template <class _Container>
[[nodiscard]] inline auto rbegin(_Container& _Cont) -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

template <class _Container>
[[nodiscard]] inline auto rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

template <class _Container>
[[nodiscard]] inline auto rend(_Container& _Cont) -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

template <class _Container>
[[nodiscard]] inline auto rend(const _Container& _Cont) -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) {
    return reverse_iterator<_Ty*>(_Array + _Size);
}

template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) {
    return reverse_iterator<_Ty*>(_Array);
}

template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) {
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) {
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

template <class _Container>
[[nodiscard]] inline auto crbegin(const _Container& _Cont) -> decltype(::std:: rbegin(_Cont)) {
    return ::std:: rbegin(_Cont);
}

template <class _Container>
[[nodiscard]] inline auto crend(const _Container& _Cont) -> decltype(::std:: rend(_Cont)) {
    return ::std:: rend(_Cont);
}

template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) -> decltype(_Cont.size()) {
    return _Cont.size();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept {
    return _Size;
}













#line 1922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _Container>
[[nodiscard]] constexpr auto empty(const _Container& _Cont) -> decltype(_Cont.empty()) {
    return _Cont.empty();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr bool empty(const _Ty (&)[_Size]) noexcept {
    return false;
}

template <class _Elem>
[[nodiscard]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.size() == 0;
}

template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) -> decltype(_Cont.data()) {
    return _Cont.data();
}

template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont) -> decltype(_Cont.data()) {
    return _Cont.data();
}

template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; 






template <class _Iter>
class move_iterator {
public:
    using iterator_type = _Iter;





    using iterator_category = _Iter_cat_t<_Iter>;
#line 3570 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
    using value_type      = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer         = _Iter;



    using reference =
        conditional_t<is_reference_v<_Iter_ref_t<_Iter>>, remove_reference_t<_Iter_ref_t<_Iter>>&&, _Iter_ref_t<_Iter>>;
#line 3579 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

    inline move_iterator() = default;

    inline explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)) {}

    
    template <class _Other>



    inline move_iterator(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()) {}

    template <class _Other>




    inline move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)  {
        _Current = _Right.base();
        return *this;
    }
    









    [[nodiscard]] inline iterator_type base() const {
        return _Current;
    }
#line 3618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

    [[nodiscard]] inline reference operator*() const {



        return static_cast<reference>(*_Current);
#line 3625 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
    }

     [[nodiscard]] inline pointer operator->() const {
        return _Current;
    }

    inline move_iterator& operator++() {
        ++_Current;
        return *this;
    }

    inline auto operator++(int) {



            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;





    }

    inline move_iterator& operator--() {
        --_Current;
        return *this;
    }

    inline move_iterator operator--(int) {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() != _Sentinel) {
        return _Current != _Sentinel;
    }

    [[nodiscard]] inline move_iterator operator+(const difference_type _Off) const {
        return move_iterator(_Current + _Off);
    }

    inline move_iterator& operator+=(const difference_type _Off) {
        _Current += _Off;
        return *this;
    }

    [[nodiscard]] inline move_iterator operator-(const difference_type _Off) const {
        return move_iterator(_Current - _Off);
    }

    inline move_iterator& operator-=(const difference_type _Off) {
        _Current -= _Off;
        return *this;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const {



        return ::std:: move(_Current[_Off]);
#line 3697 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
    }









































    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) {
        _Verify_range(_First._Current, _Last.base());
    }







    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        _Current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) {
        _Current._Seek_to(_It.base());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src>&& _It) {
        _Current._Seek_to(::std:: move(_It).base());
    }

private:
    iterator_type _Current{};
};

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)







{ return _Left.base() == _Right.base(); }


template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator!=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) {
    return !(_Left == _Right);
}
#line 3798 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)







{ return _Left.base() < _Right.base(); }

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)





{ return _Right < _Left; }

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator<=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)





{ return !(_Right < _Left); }

template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)





{ return !(_Left < _Right); }









template <class _Iter1, class _Iter2>
[[nodiscard]] inline auto operator-(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter> operator+(
    typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right)







{ return move_iterator<_Iter>{_Right.base() + _Off}; }

template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter> make_move_iterator(_Iter _It) { 
    return move_iterator<_Iter>(::std:: move(_It));
}



































template <class _Iter>
 constexpr bool _Iterator_is_contiguous = is_pointer_v<_Iter>;

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const _Iter& _Val) noexcept {
    ;
    return _Val;
}
#line 3911 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"



template <class _Iter1, class _Iter2>
 constexpr bool _Iterators_are_contiguous =
    _Iterator_is_contiguous<_Iter1>&& _Iterator_is_contiguous<_Iter2>;

template <class _Source, class _Dest>
struct _Ptr_cat_helper {
    using _USource                        = _Unwrap_enum_t<_Source>;
    using _UDest                          = _Unwrap_enum_t<_Dest>;
    static constexpr bool _Really_trivial = conjunction_v<
        bool_constant<sizeof(_USource) == sizeof(_UDest) && is_same_v<bool, _USource> == is_same_v<bool, _UDest>>,
        is_integral<_USource>, is_integral<_UDest>>;
    static constexpr bool _Trivially_copyable = _Really_trivial;
};

template <class _Elem>
struct _Ptr_cat_helper<_Elem, _Elem> { 
    static constexpr bool _Really_trivial     = is_trivial_v<_Elem>;
    static constexpr bool _Trivially_copyable = is_trivially_copyable_v<_Elem>;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, const _Anything*> {
    
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, volatile _Anything*> {
    
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

template <class _Anything>
struct _Ptr_cat_helper<_Anything*, const volatile _Anything*> {
    
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};

struct _False_copy_cat {
    static constexpr bool _Really_trivial     = false;
    static constexpr bool _Trivially_copyable = false;
};


template <class _Source, class _Dest, bool _Non_contiguous = !_Iterators_are_contiguous<_Source, _Dest>>
struct _Ptr_move_cat : _False_copy_cat {};

template <class _Source, class _Dest>
struct _Ptr_move_cat<_Source, _Dest, false>
    : conditional_t<is_trivially_assignable_v<_Iter_ref_t<_Dest>, remove_reference_t<_Iter_ref_t<_Source>>>,
          _Ptr_cat_helper<_Iter_value_t<_Source>, _Iter_value_t<_Dest>>, _False_copy_cat> {};

template <class _Source, class _Dest>
struct _Ptr_move_cat<move_iterator<_Source>, _Dest, true> : _Ptr_move_cat<_Source, _Dest> {};

template <class _Source, class _Dest, bool _Non_contiguous = !_Iterators_are_contiguous<_Source, _Dest>>
struct _Ptr_copy_cat : _False_copy_cat {};

template <class _Source, class _Dest>
struct _Ptr_copy_cat<_Source, _Dest, false>
    : conditional_t<is_trivially_assignable_v<_Iter_ref_t<_Dest>, _Iter_ref_t<_Source>>,
          _Ptr_cat_helper<_Iter_value_t<_Source>, _Iter_value_t<_Dest>>, _False_copy_cat> {};

template <class _Source, class _Dest>
struct _Ptr_copy_cat<move_iterator<_Source>, _Dest, true> : _Ptr_move_cat<_Source, _Dest> {};

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    :: memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
    } else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}

template <class _InIt, class _OutIt>
_OutIt _Copy_memmove(move_iterator<_InIt> _First, move_iterator<_InIt> _Last, _OutIt _Dest) {
    return _Copy_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _It, bool _RequiresMutable = false>
 constexpr bool _Is_vb_iterator = false;

template <class _InIt, class _OutIt>
inline _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Ptr_copy_cat<_InIt, _OutIt>::_Trivially_copyable) {


#line 4016 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = *_First;
    }

    return _Dest;
}

template <class _InIt, class _OutIt>
inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}










#line 4048 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"












































































template <class _InIt, class _Diff, class _OutIt>
inline _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Trivially_copyable) {


#line 4135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
            {
                _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
                _Seek_wrapped(_Dest, _UDest);
                return _Dest;
            }
        }

        for (;;) {
            *_UDest = *_UFirst;
            ++_UDest;
            --_Count;
            if (_Count == 0) { 
                               
                break;
            }

            ++_UFirst;
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}










#line 4170 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    auto _Result                = :: memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    } else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    if constexpr (_Ptr_copy_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {


#line 4201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

template <class _BidIt1, class _BidIt2>
inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}








#line 4232 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _InIt, class _OutIt>
inline _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {


#line 4241 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = ::std:: move(*_First);
    }

    return _Dest;
}

template <class _InIt, class _OutIt>
inline _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}










#line 4274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _BidIt1, class _BidIt2>
inline _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    
    if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {


#line 4283 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = ::std:: move(*--_Last);
    }

    return _Dest;
}

template <class _BidIt1, class _BidIt2>
inline _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}








#line 4314 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"


template <class _Ty>
struct _Is_character : false_type {}; 

template <>
struct _Is_character<char> : true_type {}; 

template <>
struct _Is_character<signed char> : true_type {}; 

template <>
struct _Is_character<unsigned char> : true_type {}; 






template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {};

template <>
struct _Is_character_or_bool<bool> : true_type {};

template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};








template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
 constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
 constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
 constexpr bool _Fill_zero_memset_is_safe =
    conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
 constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    :: memset(_To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}

template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    :: memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}

template <class _Ty>
[[nodiscard]] bool _Is_all_bits_zero(const _Ty& _Val) {
    
    ;
    constexpr _Ty _Zero{};
    return :: memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
}

template <class _FwdIt, class _Ty>
inline void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);


#line 4397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (_Is_all_bits_zero(_Val)) {
                    _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}









#line 4424 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _OutIt, class _Diff, class _Ty>
inline _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);


#line 4439 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}









#line 4472 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

















































#pragma warning(push)
#pragma warning(disable : 4806) 
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) 
        && is_integral_v<_Elem1> && !is_volatile_v<_Elem1> 
        && is_integral_v<_Elem2> && !is_volatile_v<_Elem2>>
 constexpr bool _Can_memcmp_elements =
    is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)












template <class _Ty1, class _Ty2>
 constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = is_same_v<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>;

template <class _Elem1, class _Elem2>
 constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;





template <class _Elem1, class _Elem2, class _Pr>
 constexpr bool _Pred_is_consistent_with_memcmp = false;



template <class _Elem>
 constexpr bool _Pred_is_consistent_with_memcmp<_Elem, _Elem, equal_to<_Elem>> = true;


template <class _Elem1, class _Elem2>
 constexpr bool _Pred_is_consistent_with_memcmp<_Elem1, _Elem2, equal_to<>> = true;










template <class _Elem1, class _Elem2, class _Pr>
 constexpr bool _Can_memcmp_elements_with_pred = _Can_memcmp_elements<_Elem1, _Elem2> 
    && _Pred_is_consistent_with_memcmp<_Elem1, _Elem2, _Pr>;




template <class _Iter1, class _Iter2, class _Pr>
 constexpr bool _Equal_memcmp_is_safe_helper = _Iterators_are_contiguous<_Iter1, _Iter2> 
    && _Can_memcmp_elements_with_pred<remove_const_t<remove_reference_t<_Iter_ref_t<_Iter1>>>,
        remove_const_t<remove_reference_t<_Iter_ref_t<_Iter2>>>, _Pr>;

template <class _Iter1, class _Iter2, class _Pr>
 constexpr bool _Equal_memcmp_is_safe =
    _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _Last1_ch  = reinterpret_cast<const char*>(_To_address(_Last1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
}

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {


#line 4617 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}





#line 4636 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>{});
}








#line 4651 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}





#line 4693 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
}








#line 4709 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"































































































































template <class _Elem1, class _Elem2, class _FTy>
struct _Lex_compare_check_element_types_helper
    : bool_constant<
          conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, _Is_character<_FTy>, is_unsigned<_FTy>>> {
    
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
    : bool_constant<
          conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>> {
    
};













template <class _Memcmp_pr>
struct _Lex_compare_optimize {
    explicit _Lex_compare_optimize() = default;

    using _Pred = _Memcmp_pr;
}; 

template <class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy>
using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
    _Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value, _Memcmp_pr,
    void>>; 

template <class _InIt1, class _InIt2, class _Pr>
constexpr auto _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&) {
    
    return _Lex_compare_optimize<void>{};
}

template <class _CtgIt1, class _CtgIt2, class _FTy, enable_if_t<_Iterators_are_contiguous<_CtgIt1, _CtgIt2>, int> = 0>
constexpr auto _Lex_compare_memcmp_classify(const _CtgIt1&, const _CtgIt2&, const less<_FTy>&) {
    
    return _Lex_compare_check_element_types<less<int>, remove_reference_t<_Iter_ref_t<_CtgIt1>>,
        remove_reference_t<_Iter_ref_t<_CtgIt2>>, _FTy>{};
}

template <class _CtgIt1, class _CtgIt2, class _FTy, enable_if_t<_Iterators_are_contiguous<_CtgIt1, _CtgIt2>, int> = 0>
constexpr auto _Lex_compare_memcmp_classify(const _CtgIt1&, const _CtgIt2&, const greater<_FTy>&) {
    
    return _Lex_compare_check_element_types<greater<int>, remove_reference_t<_Iter_ref_t<_CtgIt1>>,
        remove_reference_t<_Iter_ref_t<_CtgIt2>>, _FTy>{};
}

















template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool _Lex_compare_unchecked(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>) {
    
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) { 
        if (_Debug_lt_pred(_Pred, *_First1, *_First2)) {
            return true;
        } else if (_Pred(*_First2, *_First1)) {
            return false;
        }
    }

    return _First1 == _Last1 && _First2 != _Last2;
}

template <class _CtgIt1, class _CtgIt2, class _Pr, class _Memcmp_pr>
[[nodiscard]] inline bool _Lex_compare_unchecked(
    _CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2, _CtgIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<_Memcmp_pr>) {
    




#line 4934 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
    (void) _Pred;
    const auto _Num1 = static_cast<size_t>(_Last1 - _First1);
    const auto _Num2 = static_cast<size_t>(_Last2 - _First2);
    const int _Ans   = _Memcmp_count(_First1, _First2, (::std:: min) (_Num1, _Num2));
    return _Memcmp_pr{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
}

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool lexicographical_compare(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    return _Lex_compare_unchecked(
        _UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred), _Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred));
}

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
}





















#line 4982 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"




























































template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag, false_type) {
    
    return (-128) <= _Val && _Val <= 127;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type, false_type) {
    
    return _Val <= 127 || static_cast<_Ty>((-128)) <= _Val;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type, false_type) {
    
    return _Val <= 127;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag, false_type) {
    
    return 0 <= _Val && _Val <= 0xff;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag, false_type) {
    
    return _Val <= 0xff;
}

template <class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _Ty& _Val, _Any_tag, _Any_tag, _Any_tag, true_type) {
    
    return _Val == true || _Val == false;
}

template <class _InIt, class _Ty>
[[nodiscard]] constexpr bool _Within_limits(const _InIt&, const _Ty& _Val) {
    
    using _Elem = _Iter_value_t<_InIt>;
    return _Within_limits(_Val, bool_constant<is_signed_v<_Elem>>{}, bool_constant<is_signed_v<_Ty>>{},
        bool_constant<-1 == static_cast<_Ty>(-1)>{}, bool_constant<is_same_v<_Elem, bool>>{});
}

template <class _InIt>
[[nodiscard]] constexpr bool _Within_limits(const _InIt&, const bool&) { 
    return true;
}








template <class _Iter, class _Ty>
 constexpr bool _Memchr_in_find_is_safe =
    _Iterator_is_contiguous<_Iter>&&
        disjunction_v<conjunction<is_integral<_Ty>, _Is_character_or_bool<_Iter_value_t<_Iter>>>




            > && !is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;

template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, false_type) {
    
    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, true_type) {
    
    if (!_Within_limits(_First, _Val)) {
        return _Last;
    }






#line 5133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
    const auto _First_ptr = _To_address(_First);
    const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
        :: memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
    if constexpr (is_pointer_v<_InIt>) {
        return _Result ? _Result : _Last;
    } else {
        return _Result ? _First + (_Result - _First_ptr) : _Last;
    }
}

template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    
    return _Find_unchecked1(_First, _Last, _Val, bool_constant<_Memchr_in_find_is_safe<_InIt, _Ty>>{});
}

template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Find_vbool(_First, _Last, _Val);
    } else {
        _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return _First;
    }
}




#line 5165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

























































































template <class _InIt, class _Ty>
[[nodiscard]] inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Count_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst               = _Get_unwrapped(_First);
        const auto _ULast          = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Count = 0;

        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }

        return _Count;
    }
}





#line 5280 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool _Check_match_counts(
    const _FwdIt1 _First1, _FwdIt1 _Last1, const _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
    ;
    ;
    if constexpr (_Is_bidi_iter_v<_FwdIt1> && _Is_bidi_iter_v<_FwdIt2>) {
        do { 
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));
        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { 
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; 
            }

            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; 
            }
        }
    }

    return true;
}

template <class _BidIt>
inline void reverse(const _BidIt _First, const _BidIt _Last) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);

    using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

#pragma warning(suppress : 6326) 
    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {


#line 5354 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            if constexpr (_Nx == 1) {
                __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 2) {
                __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 4) {
                __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
            } else {
                __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));
            }

            return;
        }
    }
#line 5369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        ::std:: iter_swap(_UFirst, _ULast);
    }
}








#line 5383 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    
    while (_First != _Sentinel && _Last != _Sentinel) {
        ::std:: iter_swap(_First, --_Last);
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}

template <class _FwdIt>
inline _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    
    
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { 
            ::std:: iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { 
            _UNext = _UMid;
            do {
                ::std:: iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}








#line 5459 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

































































































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: lower_bound(_First, _Last, _Val, less<>{});
}

template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    


    using _Elem1 = remove_reference_t<_Iter_ref_t<_FwdIt1>>;
    using _Elem2 = remove_reference_t<_Iter_ref_t<_FwdIt2>>;
    if constexpr (is_same_v<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1> 
                  && _Iterators_are_contiguous<_FwdIt1, _FwdIt2>) {


#line 5611 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
        {
            __std_swap_ranges_trivially_swappable_noalias(
                _To_address(_First1), _To_address(_Last1), _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
#line 5618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        ::std:: iter_swap(_First1, _First2);
    }

    return _First2;
}

template <class _Diff, class _Urng>
class _Rng_from_urng { 
public:
    using _Ty0 = make_unsigned_t<_Diff>;
    using _Ty1 = typename _Urng::result_type;

    using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;

    explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(8 * sizeof(_Udiff)), _Bmask(_Udiff(-1)) {
        for (; (_Urng::max) () - (_Urng::min) () < _Bmask; _Bmask >>= 1) {
            --_Bits;
        }
    }

    _Diff operator()(_Diff _Index) { 
        for (;;) { 
            _Udiff _Ret  = 0; 
            _Udiff _Mask = 0; 

            while (_Mask < _Udiff(_Index - 1)) { 
                _Ret <<= _Bits - 1; 
                _Ret <<= 1;
                _Ret |= _Get_bits();
                _Mask <<= _Bits - 1; 
                _Mask <<= 1;
                _Mask |= _Bmask;
            }

            
            if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {
                return static_cast<_Diff>(_Ret % _Index);
            }
        }
    }

    _Udiff _Get_all_bits() {
        _Udiff _Ret = 0;

        for (size_t _Num = 0; _Num < 8 * sizeof(_Udiff); _Num += _Bits) { 
            _Ret <<= _Bits - 1; 
            _Ret <<= 1;
            _Ret |= _Get_bits();
        }

        return _Ret;
    }

    _Rng_from_urng(const _Rng_from_urng&) = delete;
    _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
    _Udiff _Get_bits() { 
        for (;;) { 
            _Udiff _Val = _Ref() - (_Urng::min) ();

            if (_Val <= _Bmask) {
                return _Val;
            }
        }
    }

    _Urng& _Ref; 
    size_t _Bits; 
    _Udiff _Bmask; 
};

template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {}; 

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {}; 

struct allocator_arg_t { 
    explicit allocator_arg_t() = default;
};

 constexpr allocator_arg_t allocator_arg{};

[[noreturn]]  void __cdecl _Xbad_alloc();
[[noreturn]]  void __cdecl _Xinvalid_argument(  const char*);
[[noreturn]]  void __cdecl _Xlength_error(  const char*);
[[noreturn]]  void __cdecl _Xout_of_range(  const char*);
[[noreturn]]  void __cdecl _Xoverflow_error(  const char*);
[[noreturn]]  void __cdecl _Xruntime_error(  const char*);
[[noreturn]]  void __cdecl _XGetLastError();

template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {
    
};

template <class _Ty, class _Alloc>
 constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*, class _Reference = _Ty&>
struct  iterator { 
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr auto _Float_abs_bits(const _Ty& _Xx) {
    using _Traits    = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_abs(const _Ty _Xx) { 
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign) { 
    using _Traits       = _Floating_type_traits<_Ty>;
    using _Uint_type    = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast<_Uint_type>(_Sign) & _Traits::_Shifted_sign_mask;
    return _Bit_cast<_Ty>(_Float_abs_bits(_Magnitude) | _Signbit);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_nan(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}





template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_signaling_nan(const _Ty& _Xx) { 
    using _Traits        = _Floating_type_traits<_Ty>;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits > _Traits::_Shifted_exponent_mask && ((_Abs_bits & _Traits::_Special_nan_mantissa_mask) == 0);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_inf(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_finite(const _Ty _Xx) { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}

struct _Nontrivial_dummy_type {
    constexpr _Nontrivial_dummy_type() noexcept {
        
    }
};
;



#line 5790 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"

}


#pragma warning(pop)
#pragma pack(pop)
#line 5797 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
#line 5798 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xutility"
#pragma external_header(pop)
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"



#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class _Ty>
struct [[nodiscard]] _Tidy_guard { 
    _Ty* _Target;
    inline ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};

template <class _Ty>
struct [[nodiscard]] _Tidy_deallocate_guard { 
    _Ty* _Target;
    inline ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};

template <class _Keycmp, class _Lhs, class _Rhs>
 constexpr bool _Nothrow_compare = noexcept(
    static_cast<bool>(::std:: declval<const _Keycmp&>()(::std:: declval<const _Lhs&>(), ::std:: declval<const _Rhs&>())));

template <size_t _Ty_size>
[[nodiscard]] constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr (_Overflow_is_possible) {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        if (_Count > _Max_possible) {
            _Throw_bad_array_new_length(); 
        }
    }

    return _Count * _Ty_size;
}

template <class _Ty>
 constexpr size_t _New_alignof = (::std:: max) (alignof(_Ty),
    static_cast<size_t>(16ull) 
);

struct _Default_allocate_traits {
    __declspec(allocator) static



        void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }



















};

constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}


constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;

static_assert(2 * sizeof(void*) <= _Big_allocation_alignment,
    "Big allocation alignment should at least match vector register alignment");
static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");


constexpr size_t _Non_user_size = 2 * sizeof(void*) + _Big_allocation_alignment - 1;


#line 119 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"


constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;


#line 125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {
    
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length(); 
    }

    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    do { if (_Ptr_container != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 135, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 135, 0); } while (false); } ; } while (false); 
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;


    static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
#line 142 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
    return _Ptr;
}

inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {
    
    _Bytes += _Non_user_size;

    const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];

    
    
    do { if (_Ptr_user[-2] == _Big_allocation_sentinel) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 154, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 154, 0); } while (false); } ; } while (false);

    
    

    constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);


#line 163 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    do { if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 164, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 164, 0); } while (false); } ; } while (false);
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#line 168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

















































#line 218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(!0 || _Align <= 16ull), int> = 0>
__declspec(allocator) inline void* _Allocate(const size_t _Bytes) {
    



#line 227 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
    {
        if (_Bytes >= _Big_allocation_threshold) { 
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }
    }
#line 233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);
    }

    return nullptr;
}

template <size_t _Align, enable_if_t<(!0 || _Align <= 16ull), int> = 0>
inline void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {
    




#line 249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
    {

        if (_Bytes >= _Big_allocation_threshold) { 
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
#line 255 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        ::operator delete(_Ptr, _Bytes);
    }
}



template <class _Ty, class... _Types>
_Ty* _Global_new(_Types&&... _Args) { 
    struct [[nodiscard]] _Guard_type {
        void* _Result;
        ~_Guard_type() {
            if (_Result) {
                _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
            }
        }
    };

    _Guard_type _Guard{_Allocate<_New_alignof<_Ty>>(sizeof(_Ty))};
    ::new (_Guard._Result) _Ty(::std:: forward<_Types>(_Args)...);
    return static_cast<_Ty*>(::std:: exchange(_Guard._Result, nullptr));
}

template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;

template <class _Ty>
inline void _Destroy_in_place(_Ty& _Obj) noexcept {
    if constexpr (is_array_v<_Ty>) {
        _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
    } else {
        _Obj.~_Ty();
    }
}













#line 315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept { 
    using _Elem       = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest       = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}

template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}

template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<void>;
};

template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};

template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const void>;
};

template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};

template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::difference_type;
};

template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};

template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};

template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = bool_constant<is_empty_v<_Ty>>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};
__pragma(warning(pop))

template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
__pragma(warning(pop))

template <class _Ty>
class allocator;

template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {};

template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type {};

template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
    disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;

template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
    : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template <class _Alloc, class _Ptr>
using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;

template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std:: declval<_Alloc&>().allocate(
        ::std:: declval<const _Size_type&>(), ::std:: declval<const _Const_void_pointer&>()))>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_max_size : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {};

template <class _Alloc>
struct allocator_traits;

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Normal_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer      = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer       = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

    using size_type       = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal                        = typename _Get_is_always_equal<_Alloc>::type;

    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count) {
        return _Al.allocate(_Count);
    }

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            return _Al.allocate(_Count);
        }
    }

    static inline void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }

    template <class _Ty, class... _Types>
    static inline void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
            (void) _Al; 


#line 570 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
            ::new (static_cast<void*>(_Ptr)) _Ty(::std:: forward<_Types>(_Args)...);
#line 572 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        } else {
            _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Ty>
    static inline void destroy(_Alloc& _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {


#line 583 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
            _Ptr->~_Ty();
#line 585 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        } else {
            _Al.destroy(_Ptr);
        }
    }

    [[nodiscard]] static inline size_type max_size(const _Alloc& _Al) noexcept {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            return (numeric_limits<size_type>::max) () / sizeof(value_type);
        }
    }

    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
};
__pragma(warning(pop))

template <class _Alloc>
struct _Default_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    using rebind_alloc = allocator<_Other>;

    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count) {




#line 639 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    [[nodiscard]] static inline __declspec(allocator) pointer
        allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count, const_void_pointer) {




#line 653 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    static inline void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {
        




#line 667 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            (void) _Al;
            _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }
    }

    template <class _Objty, class... _Types>
    static inline void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {




#line 680 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            ::new (_Voidify_iter(_Ptr)) _Objty(::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Uty>
    static inline void destroy(_Alloc&, _Uty* const _Ptr) {


#line 690 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        _Ptr->~_Uty();
#line 692 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
    }

    [[nodiscard]] static inline size_type max_size(const _Alloc&) noexcept {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }

    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        return _Al;
    }
};

template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> {};



template <class _Alloc>
using _Choose_pocca = bool_constant<allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
                                    && !allocator_traits<_Alloc>::is_always_equal::value>;

struct _Equal_allocators {}; 
using _Propagate_allocators    = true_type; 
using _No_propagate_allocators = false_type; 

template <class _Alloc>
using _Choose_pocma = conditional_t<allocator_traits<_Alloc>::is_always_equal::value, _Equal_allocators,
    typename allocator_traits<_Alloc>::propagate_on_container_move_assignment::type>;

template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;



template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
        _Rebind_alloc_t<_Alloc, _Value_type>>;

template <class _Alloc> 
 constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>&&
    is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>&&
        is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>&&
            is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

template <class _Value_type>
struct _Simple_types { 
                       
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};
























#line 771 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");

    using _From_primary = allocator;

    using value_type = _Ty;


     typedef _Ty* pointer;
     typedef const _Ty* const_pointer;

     typedef _Ty& reference;
     typedef const _Ty& const_reference;
#line 789 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;


    using is_always_equal  = true_type;

    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };

     [[nodiscard]] _Ty* address(_Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }

     [[nodiscard]] const _Ty* address(const _Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }
#line 811 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

    constexpr allocator() noexcept {}

    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept {}
    inline ~allocator()       = default;
    inline allocator& operator=(const allocator&) = default;

    inline void deallocate(_Ty* const _Ptr, const size_t _Count) {
        
        _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }

    [[nodiscard]] inline __declspec(allocator) _Ty* allocate(__declspec(guard(overflow)) const size_t _Count) {
        return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }






#line 835 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"


     [[nodiscard]] __declspec(allocator) _Ty* allocate(
        __declspec(guard(overflow)) const size_t _Count, const void*) {
        return allocate(_Count);
    }

    template <class _Objty, class... _Types>
     void construct(_Objty* const _Ptr, _Types&&... _Args) {
        ::new (_Voidify_iter(_Ptr)) _Objty(::std:: forward<_Types>(_Args)...);
    }

    template <class _Uty>
     void destroy(_Uty* const _Ptr) {
        _Ptr->~_Uty();
    }

     [[nodiscard]] size_t max_size() const noexcept {
        return static_cast<size_t>(-1) / sizeof(_Ty);
    }
#line 856 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
};

template <>
class allocator<void> {
public:
    using value_type = void;

     typedef void* pointer;
     typedef const void* const_pointer;
#line 866 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;


    using is_always_equal  = true_type;

    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };
#line 880 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
};

template <class _Ty, class _Other>
[[nodiscard]] inline bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return true;
}


template <class _Ty, class _Other>
[[nodiscard]] bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return false;
}
#line 893 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"






#line 900 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

template <class _Alloc>
inline void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}

template <class _Alloc>
inline void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std:: move(_Right);
    }
}

template <class _Alloc>
inline void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        _Swap_adl(_Left, _Right);
    } else {
        do { if (_Left == _Right) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 926, 0, "%s", "containers incompatible for swap")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"containers incompatible for swap\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 926, 0); } while (false); } ; } while (false);
    }
}

template <class _Alloc>
inline void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {
    
    if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}

template <class _Size_type>
[[nodiscard]] constexpr _Size_type _Convert_size(const size_t _Len) noexcept {
    
    if (_Len > (numeric_limits<_Size_type>::max) ()) {
        _Xlength_error("size_t too long for _Size_type");
    }

    return static_cast<_Size_type>(_Len);
}

template <>
[[nodiscard]] constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {
    
    return _Len;
}

template <class _Alloc>
inline void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}

template <class _Alloc>
inline void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    _Deallocate_plain(_Al, _Ptr);
}

template <class _Alloc>
struct _Alloc_construct_ptr { 
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;

    inline explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

    [[nodiscard]] inline pointer _Release() noexcept { 
        return ::std:: exchange(_Ptr, nullptr);
    }

    inline void _Allocate() { 
        _Ptr = nullptr; 
        _Ptr = _Al.allocate(1);
    }

    inline ~_Alloc_construct_ptr() { 
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&) = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};

struct _Fake_allocator {};

struct _Container_base0 {
    inline void _Orphan_all() noexcept {}
    inline void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    inline void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    inline void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};

struct _Iterator_base0 {
    inline void _Adopt(const void*) noexcept {}
    inline const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

struct _Container_base12;
struct _Container_proxy { 
    inline _Container_proxy() noexcept = default;
    inline _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

    const _Container_base12* _Mycont       = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};

struct _Container_base12 {
public:
    inline _Container_base12() noexcept = default;

    _Container_base12(const _Container_base12&) = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;

    inline void _Orphan_all() noexcept;
    inline void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

    template <class _Alloc>
    inline void _Alloc_proxy(_Alloc&& _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy->_Mycont = this;
    }

    template <class _Alloc>
    inline void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Myproxy, _New_proxy));
    }

    _Container_proxy* _Myproxy = nullptr;

private:
    inline void _Orphan_all_unlocked_v3() noexcept;
    inline void _Swap_proxy_and_iterators_unlocked(_Container_base12&) noexcept;

    void _Orphan_all_locked_v3() noexcept {
        _Lockit _Lock(3);
        _Orphan_all_unlocked_v3();
    }

    void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {
        _Lockit _Lock(3);
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
};

struct _Iterator_base12 { 
public:
    inline _Iterator_base12() noexcept = default; 

    inline _Iterator_base12(const _Iterator_base12& _Right) noexcept {
        *this = _Right;
    }

    inline _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {





#line 1100 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            _Assign_locked(_Right);
        }


#line 1106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        return *this;
    }


    inline ~_Iterator_base12() noexcept {




#line 1116 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            _Orphan_me_locked_v3();
        }
    }

    inline void _Adopt(const _Container_base12* _Parent) noexcept {




#line 1127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            _Adopt_locked(_Parent);
        }
    }








#line 1140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

    inline const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = 2 == 0;

    mutable _Container_proxy* _Myproxy    = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;


private:
    inline void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {
        if (_Myproxy == _Right._Myproxy) {
            return;
        }

        if (_Right._Myproxy) {
            _Adopt_unlocked(_Right._Myproxy->_Mycont);
        } else { 
            _Orphan_me_unlocked_v3();
        }
    }

    void _Assign_locked(const _Iterator_base12& _Right) noexcept {
        _Lockit _Lock(3);
        _Assign_unlocked(_Right);
    }

    inline void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {
        if (!_Parent) {
            _Orphan_me_unlocked_v3();
            return;
        }

        _Container_proxy* _Parent_proxy = _Parent->_Myproxy;
        if (_Myproxy != _Parent_proxy) { 
            if (_Myproxy) { 
                _Orphan_me_unlocked_v3();
            }
            _Mynextiter                 = _Parent_proxy->_Myfirstiter;
            _Parent_proxy->_Myfirstiter = this;
            _Myproxy                    = _Parent_proxy;
        }
    }

    void _Adopt_locked(const _Container_base12* _Parent) noexcept {
        _Lockit _Lock(3);
        _Adopt_unlocked(_Parent);
    }

    inline void _Orphan_me_unlocked_v3() noexcept {
        if (!_Myproxy) { 
            return;
        }

        
        _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;
        while (*_Pnext && *_Pnext != this) {
            const auto _Temp = *_Pnext; 
            _Pnext           = &_Temp->_Mynextiter;
        }

        do { if (*_Pnext) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 1203, 0, "%s", "ITERATOR LIST CORRUPTED!")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"ITERATOR LIST CORRUPTED!\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory", 1203, 0); } while (false); } ; } while (false);
        *_Pnext  = _Mynextiter;
        _Myproxy = nullptr;
    }

    void _Orphan_me_locked_v3() noexcept {
        _Lockit _Lock(3);
        _Orphan_me_unlocked_v3();
    }
#line 1213 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
};

inline void _Container_base12::_Orphan_all_unlocked_v3() noexcept {
    if (!_Myproxy) { 
        return;
    }

    
    for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { 
        _Pnext->_Myproxy = nullptr;
    }
    _Myproxy->_Myfirstiter = nullptr;
}

inline void _Container_base12::_Orphan_all() noexcept {





#line 1234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
    {
        _Orphan_all_locked_v3();
    }
#line 1238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
}

inline void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;

    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }

    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}

inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {





#line 1261 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
    {
        _Swap_proxy_and_iterators_locked(_Right);
    }


#line 1267 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
}




#line 1273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
#line 1276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
}; 

struct _Fake_proxy_ptr_impl { 
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

    inline void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    inline void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    
    _Container_proxy* _Ptr = nullptr;

    constexpr void _Release() noexcept { 
        _Ptr = nullptr;
    }

protected:
    inline _Basic_container_proxy_ptr12()                       = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&)      = delete;
};

template <class _Alloc>
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    
    _Alloc& _Al;

    inline _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

    inline _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, ::std:: addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }

    inline void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        
        
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Mycont->_Myproxy, ::std:: exchange(_Ptr, nullptr)));
    }

    inline ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};






#line 1343 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

template <class _Alloc>
using _Container_proxy_ptr = _Container_proxy_ptr12<_Rebind_alloc_t<_Alloc, _Container_proxy>>;
#line 1347 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
}; 

struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
}; 

template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { 
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; 

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return *this;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return *this;
    }
};

template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { 
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return _Myval1;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return _Myval1;
    }
};

struct _Move_allocator_tag {
    explicit _Move_allocator_tag() = default;
};

template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;





            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return {static_cast<_Ty*>(_Pbuf), _Count};
            }
        }
    }

    return {nullptr, 0};
}

template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {





    {
        ::operator delete(_Pbuf);
    }
}

template <class _NoThrowFwdIt>
struct [[nodiscard]] _Uninitialized_backout {
    
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&) = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

    inline ~_Uninitialized_backout() {
        _Destroy_range(_First, _Last);
    }

    template <class... _Types>
    inline void _Emplace_back(_Types&&... _Vals) {
        
        _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr _NoThrowFwdIt _Release() { 
        _First = _Last;
        return _Last;
    }
};

template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Ptr_move_cat<_InIt, _NoThrowFwdIt>::_Really_trivial) {


#line 1484 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(::std:: move(*_First));
    }

    return _Backout._Release();
}













































































































































template <class _Alloc>
class [[nodiscard]] _Uninitialized_backout_al {
    
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    inline _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

    inline ~_Uninitialized_backout_al() {
        _Destroy_range(_First, _Last, _Al);
    }

    template <class... _Types>
    inline void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr pointer _Release() { 
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;

    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {


#line 1683 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            _Dest += _ULast - _UFirst;
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Ptr_copy_cat<_InIt, _NoThrowFwdIt>::_Really_trivial) {


#line 1705 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(*_First);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval     = typename _Alloc::value_type*;
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(::std:: move(*_UFirst))>>) {


#line 1742 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(::std:: move(*_UFirst));
    }

    return _Backout._Release();
}

template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {


#line 1765 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
            return _First + _Count;
        }
    } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {


#line 1773 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
        }

        _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}

template <class _NoThrowFwdIt>
 constexpr bool _Use_memset_value_construct_v =
    conjunction_v<bool_constant<_Iterator_is_contiguous<_NoThrowFwdIt>>, is_scalar<_Iter_value_t<_NoThrowFwdIt>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
        negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { 
    char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
    char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
    :: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}

template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {
    
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {


#line 1837 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    
    ;
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}


template <class _Ty>
 [[nodiscard]] pair<_Ty*, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept {
    return _Get_temporary_buffer<_Ty>(_Count);
}

template <class _Ty>
 void return_temporary_buffer(_Ty* _Pbuf) {
    _Return_temporary_buffer(_Pbuf);
}
#line 1879 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"


template <class _Key, class... _Args>
struct _In_place_key_extract_set {
    
    static constexpr bool _Extractable = false;
};

template <class _Key>
struct _In_place_key_extract_set<_Key, _Key> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept {
        return _Val;
    }
};


template <class _Key, class... _Args>
struct _In_place_key_extract_map {
    
    static constexpr bool _Extractable = false;
};

template <class _Key, class _Second>
struct _In_place_key_extract_map<_Key, _Key, _Second> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {
        return _Val;
    }
};

template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map<_Key, pair<_First, _Second>> {
    
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val) {
        return _Val.first;
    }
};

#pragma warning(push)
#pragma warning(disable : 4624) 
template <class _Ty>
struct _Wrap {
    _Ty _Value; 
};
#pragma warning(pop)

template <class _Alloc>
struct _Alloc_temporary2 {
    using value_type = typename _Alloc::value_type;
    using _Traits    = allocator_traits<_Alloc>;

    _Alloc& _Al;














    union {
        value_type _Value;
    };

    [[nodiscard]] inline value_type& _Get_value() noexcept {
        return _Value;
    }

    [[nodiscard]] inline const value_type& _Get_value() const noexcept {
        return _Value;
    }
#line 1961 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"

    template <class... _Args>
    inline explicit _Alloc_temporary2(_Alloc& _Al_, _Args&&... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...)))
        : _Al(_Al_) {
        _Traits::construct(_Al, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...);
    }

    _Alloc_temporary2(const _Alloc_temporary2&) = delete;
    _Alloc_temporary2& operator=(const _Alloc_temporary2&) = delete;

    inline ~_Alloc_temporary2() {
        _Traits::destroy(_Al, ::std:: addressof(_Get_value()));
    }
};

template <class _Alloc>
[[nodiscard]] constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {
    if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: find_if(_UFirst, _ULast, _Pass_fn(_Pred));
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _Container, class _Uty>
inline typename _Container::size_type _Erase_remove(_Container& _Cont, const _Uty& _Val) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
inline typename _Container::size_type _Erase_remove_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove_if(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
typename _Container::size_type _Erase_nodes_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        } else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}







































































































#line 2169 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
}



#pragma warning(pop)
#pragma pack(pop)
#line 2176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
#line 2177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmemory"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"



#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class _Myvec>
class _Vector_const_iterator : public _Iterator_base {
public:



    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::const_pointer;
    using reference         = const value_type&;

    using _Tptr = typename _Myvec::pointer;

    inline _Vector_const_iterator() noexcept : _Ptr() {}

    inline _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pvector);
    }

    
    inline _Vector_const_iterator& operator=(const _Vector_const_iterator&) noexcept = default;

    [[nodiscard]] inline reference operator*() const noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 51, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference value-initialized vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 51, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 53, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference out of range vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 53, 0); } while (false); } ; } while (false);
#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 55 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return *_Ptr;
    }

    [[nodiscard]] inline pointer operator->() const noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 62, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference value-initialized vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 62, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 64, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference out of range vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 64, 0); } while (false); } ; } while (false);
#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return _Ptr;
    }

    inline _Vector_const_iterator& operator++() noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 73, 0, "%s", "can't increment value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't increment value-initialized vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 73, 0); } while (false); } ; } while (false);
        do { if (_Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 74, 0, "%s", "can't increment vector iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't increment vector iterator past end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 74, 0); } while (false); } ; } while (false);
#line 76 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        ++_Ptr;
        return *this;
    }

    inline _Vector_const_iterator operator++(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    inline _Vector_const_iterator& operator--() noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 90, 0, "%s", "can't decrement value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't decrement value-initialized vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 90, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myfirst < _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 91, 0, "%s", "can't decrement vector iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't decrement vector iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 91, 0); } while (false); } ; } while (false);
#line 93 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        --_Ptr;
        return *this;
    }

    inline _Vector_const_iterator operator--(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    inline void _Verify_offset(const difference_type _Off) const noexcept {


#line 108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Off == 0 || _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 109, 0, "%s", "cannot seek value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 109, 0); } while (false); } ; } while (false);
        if (_Off < 0) {
            do { if (_Off >= _Mycont->_Myfirst - _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 111, 0, "%s", "cannot seek vector iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 111, 0); } while (false); } ; } while (false);
        }

        if (_Off > 0) {
            do { if (_Off <= _Mycont->_Mylast - _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 115, 0, "%s", "cannot seek vector iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector iterator after end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 115, 0); } while (false); } ; } while (false);
        }
#line 118 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }

    inline _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] inline _Vector_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vector_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _Vector_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }






#line 162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    [[nodiscard]] bool operator!=(const _Vector_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

    [[nodiscard]] bool operator>(const _Vector_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Vector_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Vector_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 183 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    inline void _Compat(const _Vector_const_iterator& _Right) const noexcept {
        


#line 189 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 189, 0, "%s", "vector iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 189, 0); } while (false); } ; } while (false);
#line 191 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }


    friend inline void _Verify_range(
        const _Vector_const_iterator& _First, const _Vector_const_iterator& _Last) noexcept {
        do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 196, 0, "%s", "vector iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterators in range are from different containers\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 196, 0); } while (false); } ; } while (false);
        do { if (_First._Ptr <= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 197, 0, "%s", "vector iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterator range transposed\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 197, 0); } while (false); } ; } while (false);
    }
#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    [[nodiscard]] inline const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    inline void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));
    }

    _Tptr _Ptr; 
};

template <class _Myvec>
[[nodiscard]] inline _Vector_const_iterator<_Myvec> operator+(
    typename _Vector_const_iterator<_Myvec>::difference_type _Off, _Vector_const_iterator<_Myvec> _Next) noexcept {
    _Next += _Off;
    return _Next;
}


























#line 247 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

template <class _Myvec>
class _Vector_iterator : public _Vector_const_iterator<_Myvec> {
public:
    using _Mybase = _Vector_const_iterator<_Myvec>;




    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    
    inline _Vector_iterator& operator=(const _Vector_iterator&) noexcept = default;

    [[nodiscard]] inline reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] inline pointer operator->() const noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (this->_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 274, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference value-initialized vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 274, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myfirst <= this->_Ptr && this->_Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 276, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference out of range vector iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 276, 0); } while (false); } ; } while (false);
#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return this->_Ptr;
    }

    inline _Vector_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _Vector_iterator operator++(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _Vector_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _Vector_iterator operator--(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _Vector_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _Vector_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vector_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _Vector_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

    [[nodiscard]] inline value_type* _Unwrapped() const noexcept {
        return _Unfancy(this->_Ptr);
    }
};

template <class _Myvec>
[[nodiscard]] inline _Vector_iterator<_Myvec> operator+(
    typename _Vector_iterator<_Myvec>::difference_type _Off, _Vector_iterator<_Myvec> _Next) noexcept {
    _Next += _Off;
    return _Next;
}


























#line 372 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _Vec_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

struct _Value_init_tag { 
    explicit _Value_init_tag() = default;
};

template <class _Val_types>
class _Vector_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    inline _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

    inline _Vector_val(pointer _First, pointer _Last, pointer _End) noexcept
        : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

    inline void _Swap_val(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        _Swap_adl(_Myfirst, _Right._Myfirst);
        _Swap_adl(_Mylast, _Right._Mylast);
        _Swap_adl(_Myend, _Right._Myend);
    }

    inline void _Take_contents(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        _Myfirst = _Right._Myfirst;
        _Mylast  = _Right._Mylast;
        _Myend   = _Right._Myend;

        _Right._Myfirst = nullptr;
        _Right._Mylast  = nullptr;
        _Right._Myend   = nullptr;
    }

    pointer _Myfirst; 
    pointer _Mylast; 
    pointer _Myend; 
};

template <class _Ptrty>
constexpr auto _Unfancy_maybe_null(_Ptrty _Ptr) noexcept {
    
    return _Ptr ? ::std:: addressof(*_Ptr) : nullptr;
}

template <class _Ty>
constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { 
    return _Ptr;
}

template <class _Ty, class _Alloc = allocator<_Ty>>
class vector { 
private:
    template <class>
    friend class _Vb_val;
    friend _Tidy_guard<vector>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits = allocator_traits<_Alty>;

public:
    static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>,
        "vector<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    using value_type      = _Ty;
    using allocator_type  = _Alloc;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&;
    using const_reference = const _Ty&;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;

private:
    using _Scary_val = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>,
        _Vec_iter_types<_Ty, size_type, difference_type, pointer, const_pointer, _Ty&, const _Ty&>>>;

public:
    using iterator               = _Vector_iterator<_Scary_val>;
    using const_iterator         = _Vector_const_iterator<_Scary_val>;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    inline vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
    }

    inline explicit vector(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
    }

    inline explicit vector(__declspec(guard(overflow)) const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count);
    }

    inline vector(__declspec(guard(overflow)) const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count, _Val);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_fwd_iter_v<_Iter>) {
            const auto _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_UFirst, _ULast)));
            _Construct_n(_Count, ::std:: move(_UFirst), ::std:: move(_ULast));
        } else {
            auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_guard<vector> _Guard{this};

            for (; _UFirst != _ULast; ++_UFirst) {
                emplace_back(*_UFirst); 
            }

            _Guard._Target = nullptr;
            _Proxy._Release();
        }
    }

    inline vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());
    }

    inline vector(const vector& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        const auto& _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }

    inline vector(const vector& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
        const auto& _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }

    inline vector(vector&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal()),
            ::std:: exchange(_Right._Mypair._Myval2._Myfirst, nullptr),
            ::std:: exchange(_Right._Mypair._Myval2._Mylast, nullptr),
            ::std:: exchange(_Right._Mypair._Myval2._Myend, nullptr)) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    inline vector(vector&& _Right, const _Alloc& _Al_) noexcept(
        _Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al_) {
        _Alty& _Al        = _Getal();
        auto&& _Alproxy   = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Al != _Right._Getal()) {
                const auto _Count = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
                if (_Count != 0) {
                    _Buy_raw(_Count);
                    _Tidy_guard<vector> _Guard{this};
                    _My_data._Mylast =
                        _Uninitialized_move(_Right_data._Myfirst, _Right_data._Mylast, _My_data._Myfirst, _Al);
                    _Guard._Target = nullptr;
                }
                _Proxy._Release();
                return;
            }
        }

        _My_data._Take_contents(_Right_data);
        _Proxy._Release();
    }

    inline vector& operator=(vector&& _Right) noexcept(
        !is_same_v<_Choose_pocma<_Alty>, _No_propagate_allocators>) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        if (_Getal() == _Right._Getal()) {
            _Tidy();
            _Pocma(_Getal(), _Right._Getal());
            _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
        } else if constexpr (!is_same_v<_Choose_pocma<_Alty>, _Equal_allocators>) {
            _Move_assign_unequal_alloc(_Right);
        }
        return *this;
    }

    inline ~vector() noexcept {
        _Tidy();

        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Delete_plain_internal(_Alproxy, ::std:: exchange(_Mypair._Myval2._Myproxy, nullptr));
#line 588 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }

private:
    template <class... _Valty>
    inline decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;
        ; 
        _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), ::std:: forward<_Valty>(_Val)...);
        _Orphan_range(_Mylast, _Mylast);
        _Ty& _Result = *_Mylast;
        ++_Mylast;


#line 604 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        (void) _Result;
#line 606 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }

public:
    template <class... _Valty>
    inline decltype(auto) emplace_back(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;
        if (_Mylast != _My_data._Myend) {
            return _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
        }

        _Ty& _Result = *_Emplace_reallocate(_Mylast, ::std:: forward<_Valty>(_Val)...);


#line 622 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        (void) _Result;
#line 624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }

    inline void push_back(const _Ty& _Val) { 
        emplace_back(_Val);
    }

    inline void push_back(_Ty&& _Val) {
        
        emplace_back(::std:: move(_Val));
    }

    template <class... _Valty>
    inline pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {
        
        _Alty& _Al        = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        ; 

        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        if (_Oldsize == max_size()) {
            _Xlength();
        }

        const size_type _Newsize     = _Oldsize + 1;
        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec           = _Al.allocate(_Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;
        pointer _Constructed_first      = _Constructed_last;

        try {
        _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), ::std:: forward<_Valty>(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;

        if (_Whereptr == _Mylast) { 
            if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
            } else {
                _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
            }
        } else { 
            _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);
            _Constructed_first = _Newvec;
            _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);
        }
        } catch (...) {
        _Destroy_range(_Constructed_first, _Constructed_last, _Al);
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return _Newvec + _Whereoff;
    }

    template <class... _Valty>
    inline iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldlast  = _My_data._Mylast;

        do { if (_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 693, 0, "%s", "vector emplace iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector emplace iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 693, 0); } while (false); } ; } while (false);
#line 694 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 695 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        if (_Oldlast != _My_data._Myend) {
            if (_Whereptr == _Oldlast) { 
                _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
            } else {
                auto& _Al = _Getal();
                _Alloc_temporary2<_Alty> _Obj(_Al, ::std:: forward<_Valty>(_Val)...); 
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Alty_traits::construct(_Al, _Unfancy(_Oldlast), ::std:: move(_Oldlast[-1]));
                ++_My_data._Mylast;
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = ::std:: move(_Obj._Get_value());
            }

            return _Make_iterator(_Whereptr);
        }

        return _Make_iterator(_Emplace_reallocate(_Whereptr, ::std:: forward<_Valty>(_Val)...));
    }

    inline iterator insert(const_iterator _Where, const _Ty& _Val) { 
        return emplace(_Where, _Val);
    }

    inline iterator insert(const_iterator _Where, _Ty&& _Val) { 
        return emplace(_Where, ::std:: move(_Val));
    }

    inline iterator insert(const_iterator _Where, __declspec(guard(overflow)) const size_type _Count, const _Ty& _Val) {
        
        const pointer _Whereptr = _Where._Ptr;

        auto& _Al        = _Getal();
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst = _My_data._Myfirst;
        const pointer _Oldlast  = _Mylast;

        do { if (_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _Oldfirst && _Oldlast >= _Whereptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 736, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector insert iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 736, 0); } while (false); } ; } while (false);
#line 737 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 738 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        const auto _Whereoff        = static_cast<size_type>(_Whereptr - _Oldfirst);
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
        const bool _One_at_back     = _Count == 1 && _Whereptr == _Oldlast;
        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Al.allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            try {
            _Uninitialized_fill_n(_Newvec + _Whereoff, _Count, _Val, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { 
                if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { 
                _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }
            } catch (...) {
            _Destroy_range(_Constructed_first, _Constructed_last, _Al);
            _Al.deallocate(_Newvec, _Newcapacity);
            throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { 
            _Emplace_back_with_unused_capacity(_Val);
        } else { 
            const _Alloc_temporary2<_Alty> _Tmp_storage(_Al, _Val); 
            const auto& _Tmp              = _Tmp_storage._Get_value();
            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
            _Orphan_range(_Whereptr, _Oldlast);

            if (_Count > _Affected_elements) { 
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Count - _Affected_elements, _Tmp, _Al);
                _Mylast = _Uninitialized_move(_Whereptr, _Oldlast, _Mylast, _Al);
                ::std:: fill(_Whereptr, _Oldlast, _Tmp);
            } else { 
                _Mylast = _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                ::std:: fill(_Whereptr, _Whereptr + _Count, _Tmp);
            }
        }

        return _Make_iterator_offset(_Whereoff);
    }

private:
    template <class _Iter>
    inline void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
        
        if (_First == _Last) {
            return; 
        }

        auto& _My_data       = _Mypair._Myval2;
        pointer& _Myfirst    = _My_data._Myfirst;
        pointer& _Mylast     = _My_data._Mylast;
        const auto _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        
        
        

        for (; _First != _Last; ++_First) {
            emplace_back(*_First);
        }

        _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);

        ::std:: rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
    }

    template <class _Iter>
    inline void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
        
        const pointer _Whereptr = _Where._Ptr;
        const auto _Count       = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));

        auto& _Al        = _Getal();
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Al.allocate(_Newcapacity);
            const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            try {
            _Uninitialized_copy(_First, _Last, _Newvec + _Whereoff, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_Count == 1 && _Whereptr == _Oldlast) { 
                if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { 
                _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }
            } catch (...) {
            _Destroy_range(_Constructed_first, _Constructed_last, _Al);
            _Al.deallocate(_Newvec, _Newcapacity);
            throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { 
                 
                 

            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);

            if (_Count < _Affected_elements) { 
                _Mylast = _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                _Destroy_range(_Whereptr, _Whereptr + _Count, _Al);

                try {
                _Uninitialized_copy(_First, _Last, _Whereptr, _Al);
                } catch (...) {
                

                try {
                _Uninitialized_move(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr, _Al);
                } catch (...) {
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy_range(_Whereptr + _Count, _Mylast, _Al);
                _Mylast = _Whereptr;
                throw;
                }

                _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
                _Destroy_range(_Oldlast, _Mylast, _Al);
                _Mylast = _Oldlast;
                throw;
                }
            } else { 
                const pointer _Relocated = _Whereptr + _Count;
                _Mylast                  = _Uninitialized_move(_Whereptr, _Oldlast, _Relocated, _Al);
                _Destroy_range(_Whereptr, _Oldlast, _Al);

                try {
                _Uninitialized_copy(_First, _Last, _Whereptr, _Al);
                } catch (...) {
                

                try {
                _Uninitialized_move(_Relocated, _Mylast, _Whereptr, _Al);
                } catch (...) {
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy_range(_Relocated, _Mylast, _Al);
                _Mylast = _Whereptr;
                throw;
                }

                _Destroy_range(_Relocated, _Mylast, _Al);
                _Mylast = _Oldlast;
                throw;
                }
            }

            _Orphan_range(_Whereptr, _Oldlast);
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;

        do { if (_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _Oldfirst && _My_data._Mylast >= _Whereptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 950, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector insert iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 950, 0); } while (false); } ; } while (false);
#line 951 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 952 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        _Adl_verify_range(_First, _Last);
        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
        _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        return _Make_iterator_offset(_Whereoff);
    }

    inline iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    inline void assign(__declspec(guard(overflow)) const size_type _Newsize, const _Ty& _Val) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            } else {
                ::std:: fill(_Myfirst, _Mylast, _Val);
            }

            _Mylast = _Uninitialized_fill_n(_Mylast, _Newsize - _Oldsize, _Val, _Al);
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            ::std:: fill(_Myfirst, _Newlast, _Val);
            _Destroy_range(_Newlast, _Mylast, _Al);
            _Mylast = _Newlast;
        }
    }

private:
    template <class _Iter>
    inline void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        pointer _Next = _Myfirst;

        for (; _First != _Last && _Next != _Mylast; ++_First, (void) ++_Next) {
            *_Next = *_First;
        }

        
        
        
        

        
        _Destroy_range(_Next, _Mylast, _Getal());
        _Mylast = _Next;

        
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); 
        }
    }

    template <class _Iter>
    inline void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {
        
        const auto _Newsize = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        auto& _Al           = _Getal();
        auto& _My_data      = _Mypair._Myval2;
        pointer& _Myfirst   = _My_data._Myfirst;
        pointer& _Mylast    = _My_data._Mylast;
        pointer& _Myend     = _My_data._Myend;

        _My_data._Orphan_all();

        if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
                          _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
                          _Uses_default_destroy<_Alty, _Ty*>>) {


#line 1040 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
            {
                const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
                if (_Newsize > _Oldcapacity) {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));
                return;
            }
        }
        auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

        if (_Newsize > _Oldsize) {
            const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            }

            
            const _Iter _Mid = ::std:: next(_First, static_cast<difference_type>(_Oldsize));
            _Copy_unchecked(_First, _Mid, _Myfirst);
            _Mylast = _Uninitialized_copy(_Mid, _Last, _Mylast, _Al);
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _Copy_unchecked(_First, _Last, _Myfirst);
            _Destroy_range(_Newlast, _Mylast, _Al);
            _Mylast = _Newlast;
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline void assign(_Iter _First, _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
    }

    inline void assign(initializer_list<_Ty> _Ilist) {
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
    }

private:
    inline void _Copy_assign(const vector& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        auto& _Right_data = _Right._Mypair._Myval2;
        assign(_Right_data._Myfirst, _Right_data._Mylast);
    }

    inline void _Copy_assign(const vector& _Right, true_type) {
        if (_Getal() != _Right._Getal()) {
            _Tidy();
            _Mypair._Myval2._Reload_proxy(
                static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
        }

        _Copy_assign(_Right, false_type{});
    }

public:
    inline vector& operator=(const vector& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }

        return *this;
    }

    inline vector& operator=(initializer_list<_Ty> _Ilist) {
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        return *this;
    }

private:
    template <class _Ty2>
    inline void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
        if (_Newsize > max_size()) {
            _Xlength();
        }

        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);
        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec         = _Al.allocate(_Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;
        pointer _Appended_last        = _Appended_first;

        try {
        if constexpr (is_same_v<_Ty2, _Ty>) {
            _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
        } else {
            ;
            _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);
        }

        if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }
        } catch (...) {
        _Destroy_range(_Appended_first, _Appended_last, _Al);
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }

    template <class _Ty2>
    inline void _Resize(const size_type _Newsize, const _Ty2& _Val) {
        
        auto& _Al           = _Getal();
        auto& _My_data      = _Mypair._Myval2;
        pointer& _Myfirst   = _My_data._Myfirst;
        pointer& _Mylast    = _My_data._Mylast;
        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize < _Oldsize) { 
            const pointer _Newlast = _Myfirst + _Newsize;
            _Orphan_range(_Newlast, _Mylast);
            _Destroy_range(_Newlast, _Mylast, _Al);
            _Mylast = _Newlast;
            return;
        }

        if (_Newsize > _Oldsize) { 
            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Resize_reallocate(_Newsize, _Val);
                return;
            }

            const pointer _Oldlast = _Mylast;
            if constexpr (is_same_v<_Ty2, _Ty>) {
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);
            }
            _Orphan_range(_Oldlast, _Oldlast);
        }

        
    }

public:
    inline void resize(__declspec(guard(overflow)) const size_type _Newsize) {
        
        _Resize(_Newsize, _Value_init_tag{});
    }

    inline void resize(__declspec(guard(overflow)) const size_type _Newsize, const _Ty& _Val) {
        
        _Resize(_Newsize, _Val);
    }

private:
    inline void _Reallocate_exactly(const size_type _Newcapacity) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

        const pointer _Newvec = _Al.allocate(_Newcapacity);

        try {
        if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }
        } catch (...) {
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Size, _Newcapacity);
    }



















#line 1246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    inline void _Clear_and_reserve_geometric(const size_type _Newsize) {
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;




#line 1258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        if (_Newsize > max_size()) {
            _Xlength();
        }

        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        if (_Myfirst) { 
            _Destroy_range(_Myfirst, _Mylast, _Al);
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }

        _Buy_raw(_Newcapacity);
    }

public:
    inline void reserve(__declspec(guard(overflow)) const size_type _Newcapacity) {
        
        if (_Newcapacity > capacity()) { 
            if (_Newcapacity > max_size()) {
                _Xlength();
            }

            _Reallocate_exactly(_Newcapacity);
        }
    }

    inline void shrink_to_fit() { 
        auto& _My_data         = _Mypair._Myval2;
        const pointer _Oldlast = _My_data._Mylast;
        if (_Oldlast != _My_data._Myend) { 
            const pointer _Oldfirst = _My_data._Myfirst;
            if (_Oldfirst == _Oldlast) {
                _Tidy();
            } else {
                _Reallocate_exactly(static_cast<size_type>(_Oldlast - _Oldfirst));
            }
        }
    }

    inline void pop_back() noexcept  {
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;


        do { if (_My_data._Myfirst != _Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1307, 0, "%s", "vector empty before pop")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector empty before pop\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1307, 0); } while (false); } ; } while (false);
#line 1309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        _Orphan_range(_Mylast - 1, _Mylast);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        --_Mylast;
    }

    inline iterator erase(const_iterator _Where) noexcept(
        is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;


        do { if (_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1324, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector erase iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1324, 0); } while (false); } ; } while (false);
#line 1325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 1326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        _Orphan_range(_Whereptr, _Mylast);
        _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        --_Mylast;
        return iterator(_Whereptr, ::std:: addressof(_My_data));
    }

    inline iterator erase(const_iterator _First, const_iterator _Last) noexcept(
        is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Firstptr = _First._Ptr;
        const pointer _Lastptr  = _Last._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;


        do { if (_First._Getcont() == ::std:: addressof(_My_data) && _Last._Getcont() == ::std:: addressof(_My_data) && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1344, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector erase iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1344, 0); } while (false); } ; } while (false);
#line 1345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 1346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        if (_Firstptr != _Lastptr) { 
            _Orphan_range(_Firstptr, _Mylast);

            const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
            _Destroy_range(_Newlast, _Mylast, _Getal());
            _Mylast = _Newlast;
        }

        return iterator(_Firstptr, ::std:: addressof(_My_data));
    }

    inline void clear() noexcept { 
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();
        _Destroy_range(_Myfirst, _Mylast, _Getal());
        _Mylast = _Myfirst;
    }

    inline void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);
        }
    }

    [[nodiscard]] inline _Ty* data() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline const _Ty* data() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline iterator begin() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline iterator end() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] inline pointer _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    [[nodiscard]] inline const_pointer _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    [[nodiscard]] inline pointer _Unchecked_end() noexcept {
        return _Mypair._Myval2._Mylast;
    }

    [[nodiscard]] inline const_pointer _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Mylast;
    }

    [[nodiscard]] inline bool empty() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return _My_data._Myfirst == _My_data._Mylast;
    }

    [[nodiscard]] inline size_type size() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        return (::std:: min) (static_cast<size_type>((numeric_limits<difference_type>::max) ()),
            _Alty_traits::max_size(_Getal()));
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);
    }

    [[nodiscard]] inline _Ty& operator[](const size_type _Pos) noexcept  {
        auto& _My_data = _Mypair._Myval2;

        do { if (_Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1475, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1475, 0); } while (false); } ; } while (false);
#line 1476 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 1477 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline const _Ty& operator[](const size_type _Pos) const noexcept  {
        auto& _My_data = _Mypair._Myval2;

        do { if (_Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1485, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1485, 0); } while (false); } ; } while (false);
#line 1486 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 1487 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline _Ty& at(const size_type _Pos) {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline const _Ty& at(const size_type _Pos) const {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline _Ty& front() noexcept  {
        auto& _My_data = _Mypair._Myval2;

        do { if (_My_data._Myfirst != _My_data._Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1512, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1512, 0); } while (false); } ; } while (false);
#line 1514 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] inline const _Ty& front() const noexcept  {
        auto& _My_data = _Mypair._Myval2;

        do { if (_My_data._Myfirst != _My_data._Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1521, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1521, 0); } while (false); } ; } while (false);
#line 1523 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] inline _Ty& back() noexcept  {
        auto& _My_data = _Mypair._Myval2;

        do { if (_My_data._Myfirst != _My_data._Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1530, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1530, 0); } while (false); } ; } while (false);
#line 1532 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] inline const _Ty& back() const noexcept  {
        auto& _My_data = _Mypair._Myval2;

        do { if (_My_data._Myfirst != _My_data._Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1539, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 1539, 0); } while (false); } ; } while (false);
#line 1541 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    inline size_type _Calculate_growth(const size_type _Newsize) const {
        
        const size_type _Oldcapacity = capacity();
        const auto _Max              = max_size();

        if (_Oldcapacity > _Max - _Oldcapacity / 2) {
            return _Max; 
        }

        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

        if (_Geometric < _Newsize) {
            return _Newsize; 
        }

        return _Geometric; 
    }

    inline void _Buy_raw(const size_type _Newcapacity) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        ; 
        ;

        const auto _Newvec = _Getal().allocate(_Newcapacity);
        _Myfirst           = _Newvec;
        _Mylast            = _Newvec;
        _Myend             = _Newvec + _Newcapacity;
    }

    inline void _Buy_nonzero(const size_type _Newcapacity) {
        









        if (_Newcapacity > max_size()) {
            _Xlength();
        }

        _Buy_raw(_Newcapacity);
    }

    inline void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            _Destroy_range(_Myfirst, _Mylast, _Al);
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));
        }

        _Myfirst = _Newvec;
        _Mylast  = _Newvec + _Newsize;
        _Myend   = _Newvec + _Newcapacity;
    }

    inline void _Tidy() noexcept { 
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            _Destroy_range(_Myfirst, _Mylast, _Al);
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }
    }

    template <class... _Valty>
    inline void _Construct_n(__declspec(guard(overflow)) const size_type _Count, _Valty&&... _Val) {
        
        
        
        
        auto& _Al       = _Getal();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        auto& _My_data  = _Mypair._Myval2;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            if constexpr (sizeof...(_Val) == 0) {
                _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
            } else if constexpr (sizeof...(_Val) == 1) {
                ;
                _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
            } else if constexpr (sizeof...(_Val) == 2) {
                _My_data._Mylast = _Uninitialized_copy(::std:: forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
            } else {
                static_assert(_Always_false<_Ty>, "Should be unreachable");
            }
            _Guard._Target = nullptr;
        }

        _Proxy._Release();
    }

    inline void _Move_assign_unequal_alloc(vector& _Right) noexcept(
        !is_same_v<_Choose_pocma<_Alty>, _No_propagate_allocators>) {
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        if constexpr (is_same_v<_Choose_pocma<_Alty>, _Propagate_allocators>) {
            _Tidy();

            
            _My_data._Reload_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
#line 1681 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
            _Pocma(_Al, _Right._Getal());
            _My_data._Take_contents(_Right_data);
        } else {
            const pointer _First = _Right_data._Myfirst;
            const pointer _Last  = _Right_data._Mylast;
            const auto _Newsize  = static_cast<size_type>(_Last - _First);

            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast  = _My_data._Mylast;

            _My_data._Orphan_all();

            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Ty*, _Ty*>::_Trivially_copyable>,
                              _Uses_default_construct<_Alty, _Ty*, _Ty>, _Uses_default_destroy<_Alty, _Ty*>>) {
                if (_Newsize > _Oldcapacity) {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast = _Refancy<pointer>(_Copy_memmove(_Unfancy(_First), _Unfancy(_Last), _Unfancy(_Myfirst)));
            } else {
                auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

                if (_Newsize > _Oldsize) {
                    if (_Newsize > _Oldcapacity) { 
                        _Clear_and_reserve_geometric(_Newsize);
                        _Oldsize = 0;
                    }

                    const pointer _Mid = _First + _Oldsize;
                    _Move_unchecked(_First, _Mid, _Myfirst);
                    _Mylast = _Uninitialized_move(_Mid, _Last, _Mylast, _Al);
                } else {
                    const pointer _Newlast = _Myfirst + _Newsize;
                    _Move_unchecked(_First, _Last, _Myfirst);
                    _Destroy_range(_Newlast, _Mylast, _Al);
                    _Mylast = _Newlast;
                }
            }
        }
    }

    [[noreturn]] static void _Xlength() {
        _Xlength_error("vector too long");
    }

    [[noreturn]] static void _Xrange() {
        _Xout_of_range("invalid vector subscript");
    }


    inline void _Orphan_range_unlocked(pointer _First, pointer _Last) const {
        _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
        while (*_Pnext) {
            const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
            if (_Pnextptr < _First || _Last < _Pnextptr) { 
                const auto _Temp = *_Pnext; 
                _Pnext           = &_Temp->_Mynextiter;
            } else { 
                const auto _Temp = *_Pnext; 
                _Temp->_Myproxy  = nullptr;
                *_Pnext          = _Temp->_Mynextiter;
            }
        }
    }

    void _Orphan_range_locked(pointer _First, pointer _Last) const {
        _Lockit _Lock(3);
        _Orphan_range_unlocked(_First, _Last);
    }

    inline void _Orphan_range(pointer _First, pointer _Last) const {
        




#line 1759 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        {
            _Orphan_range_locked(_First, _Last);
        }
    }


#line 1766 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    [[nodiscard]] inline _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline iterator _Make_iterator(const pointer _Ptr) noexcept {
        return iterator(_Ptr, ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline iterator _Make_iterator_offset(const size_type _Offset) noexcept {
        
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst + _Offset, ::std:: addressof(_My_data));
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};





#line 1793 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

template <class _Alloc>
class vector<bool, _Alloc>;

using _Vbase         = unsigned int; 
constexpr int _VBITS = 8 * sizeof(_Vbase); 

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator==(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if (_Left.size() != _Right.size()) {
        return false;
    }

    if constexpr (is_same_v<_Ty, bool>) {
        return ::std:: equal(
            _Left._Myvec._Unchecked_begin(), _Left._Myvec._Unchecked_end(), _Right._Myvec._Unchecked_begin());
    } else {
        return ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
    }
}


template <class _Ty, class _Alloc>
[[nodiscard]] bool operator!=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Left == _Right);
}
#line 1820 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
















template <class _Ret>
struct _Vbase_compare_three_way {
    [[nodiscard]] constexpr _Ret operator()(const _Vbase _Left, const _Vbase _Right) const noexcept {
        const _Vbase _Differing_bits = _Left ^ _Right;

        if (_Differing_bits == 0) { 



            return 0;
#line 1847 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        }

        const int _Bit_index = _Countr_zero(_Differing_bits); 
        ; 

        const _Vbase _Mask = _Vbase{1} << _Bit_index; 

        



        return (_Left & _Mask) == 0 ? -1 : 1;
#line 1860 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }
};



























template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if constexpr (is_same_v<_Ty, bool>) {
        
        auto _First = _Left._Myvec._Unchecked_begin();
        auto _Other = _Right._Myvec._Unchecked_begin();

        const auto _Last = _First + (::std:: min) (_Left._Myvec.size(), _Right._Myvec.size());

        for (; _First != _Last; ++_First, (void) ++_Other) {
            using _Comp = _Vbase_compare_three_way<signed char>;
            const auto _Result = _Comp{}(*_First, *_Other);

            if (_Result < 0) {
                return true;
            } else if (_Result > 0) {
                return false;
            }
        }

        return _Left.size() < _Right.size();
    } else {
        return ::std:: lexicographical_compare(
            _Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin(), _Right._Unchecked_end());
    }
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Left < _Right);
}
#line 1931 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

template <class _Ty, class _Alloc>
inline void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}











#line 1948 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

template <class _Alloc0>
struct _Wrap_alloc { 
    using _Alloc = _Alloc0;
};

template <class _Alvbase_wrapped>
class _Vb_iter_base : public _Iterator_base {
    
public:
    using _Alvbase         = typename _Alvbase_wrapped::_Alloc;
    using _Size_type       = typename allocator_traits<_Alvbase>::size_type;
    using _Difference_type = typename allocator_traits<_Alvbase>::difference_type;
    using _Mycont          = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

    inline _Vb_iter_base() = default;

    inline _Vb_iter_base(const _Vbase* _Ptr, _Size_type _Off, const _Container_base* _Mypvbool) noexcept
        : _Myptr(_Ptr), _Myoff(_Off) {
        this->_Adopt(_Mypvbool);
    }

    
    inline _Vb_iter_base& operator=(const _Vb_iter_base&) noexcept = default;

    inline void _Advance(_Size_type _Off) noexcept {
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }


    inline _Difference_type _Total_off(const _Mycont* _Cont) const noexcept {
        return static_cast<_Difference_type>(_VBITS * (_Myptr - _Cont->_Myvec.data()) + _Myoff);
    }
#line 1984 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    const _Vbase* _Myptr = nullptr;
    _Size_type _Myoff    = 0;
};

template <class _Alvbase_wrapped>
class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> {
    
    using _Mybase          = _Vb_iter_base<_Alvbase_wrapped>;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    
    inline _Vb_reference() = default;

public:
    inline _Vb_reference(const _Vb_reference&) = default;

    inline _Vb_reference(const _Mybase& _Right) noexcept
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

    inline _Vb_reference& operator=(const _Vb_reference& _Right) noexcept {
        return *this = static_cast<bool>(_Right);
    }

    inline _Vb_reference& operator=(bool _Val) noexcept {
        if (_Val) {
            *const_cast<_Vbase*>(_Getptr()) |= _Mask();
        } else {
            *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
        }

        return *this;
    }

    inline void flip() noexcept {
        *const_cast<_Vbase*>(_Getptr()) ^= _Mask();
    }

    inline operator bool() const noexcept {
        return (*_Getptr() & _Mask()) != 0;
    }

    inline const _Vbase* _Getptr() const noexcept {

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        do { if (_Cont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2030, 0, "%s", "cannot dereference value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized vector<bool> iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2030, 0); } while (false); } ; } while (false);
        do { if (this->_Total_off(_Cont) <= static_cast<_Difference_type>(_Cont->_Mysize)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2032, 0, "%s", "vector<bool> iterator not dereferenceable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator not dereferenceable\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2032, 0); } while (false); } ; } while (false);
#line 2033 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 2034 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return this->_Myptr;
    }

    friend inline void swap(_Vb_reference _Left, _Vb_reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

protected:
    inline _Vbase _Mask() const noexcept {
        return static_cast<_Vbase>(1) << this->_Myoff;
    }
};

template <class _Alvbase_wrapped>
class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> {
private:
    using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;

public:
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;
    using _Size_type       = typename _Mybase::_Size_type;
    using _Reft            = _Vb_reference<_Alvbase_wrapped>;
    using const_reference  = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difference_type;
    using pointer           = const_reference*;
    using reference         = const_reference;

    inline _Vb_const_iterator() = default;

    inline _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept
        : _Mybase(_Ptr, 0, _Mypvbool) {}

    
    inline _Vb_const_iterator& operator=(const _Vb_const_iterator&) noexcept = default;

    [[nodiscard]] inline const_reference operator*() const noexcept {

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        do { if (_Cont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2079, 0, "%s", "cannot dereference value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized vector<bool> iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2079, 0); } while (false); } ; } while (false);
        do { if (this->_Total_off(_Cont) < static_cast<_Difference_type>(_Cont->_Mysize)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2081, 0, "%s", "vector<bool> iterator not dereferenceable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator not dereferenceable\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2081, 0); } while (false); } ; } while (false);
#line 2082 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 2083 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return _Reft(*this);
    }

    inline _Vb_const_iterator& operator++() noexcept {
        _Inc();
        return *this;
    }

    inline _Vb_const_iterator operator++(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Inc();
        return _Tmp;
    }

    inline _Vb_const_iterator& operator--() noexcept {
        _Dec();
        return *this;
    }

    inline _Vb_const_iterator operator--(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Dec();
        return _Tmp;
    }

    inline _Vb_const_iterator& operator+=(const difference_type _Off) noexcept {

        if (_Off != 0) {
            const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
            do { if (_Cont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2113, 0, "%s", "cannot seek value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized vector<bool> iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2113, 0); } while (false); } ; } while (false);
            const auto _Start_offset = this->_Total_off(_Cont);
            if (_Off < 0) {
                do { if (-_Start_offset <= _Off) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2116, 0, "%s", "cannot seek vector<bool> iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector<bool> iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2116, 0); } while (false); } ; } while (false);
            } else if (0 < _Off) {
                do { if (_Off <= static_cast<_Difference_type>(_Cont->_Mysize - _Start_offset)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2119, 0, "%s", "cannot seek vector<bool> iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector<bool> iterator after end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2119, 0); } while (false); } ; } while (false);
#line 2120 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
            }
        }
#line 2123 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off)) { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
            this->_Myoff %= _VBITS;
        } else { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr += this->_Myoff / _VBITS;
            this->_Myoff %= _VBITS;
        }
        return *this;
    }

    [[nodiscard]] inline _Vb_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vb_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _Vb_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return static_cast<difference_type>(_VBITS * (this->_Myptr - _Right._Myptr))
             + static_cast<difference_type>(this->_Myoff) - static_cast<difference_type>(_Right._Myoff);
    }

    [[nodiscard]] inline const_reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff;
    }









#line 2176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    [[nodiscard]] bool operator!=(const _Vb_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myptr < _Right._Myptr || (this->_Myptr == _Right._Myptr && this->_Myoff < _Right._Myoff);
    }

    [[nodiscard]] bool operator>(const _Vb_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Vb_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Vb_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 2197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    inline void _Compat(const _Vb_const_iterator& _Right) const noexcept {
        


#line 2203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2203, 0, "%s", "vector<bool> iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2203, 0); } while (false); } ; } while (false);
#line 2205 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }


    using _Prevent_inheriting_unwrap = _Vb_const_iterator;

    friend inline void _Verify_range(const _Vb_const_iterator& _First, const _Vb_const_iterator& _Last) noexcept {
        
        do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2212, 0, "%s", "vector<bool> iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator range transposed\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2212, 0); } while (false); } ; } while (false);
    }
#line 2215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    inline void _Dec() noexcept { 

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        do { if (_Cont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2219, 0, "%s", "cannot decrement value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized vector<bool> iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2219, 0); } while (false); } ; } while (false);
        do { if (this->_Total_off(_Cont) > 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2220, 0, "%s", "cannot decrement vector<bool> begin iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement vector<bool> begin iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2220, 0); } while (false); } ; } while (false);
#line 2222 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        if (this->_Myoff != 0) {
            --this->_Myoff;
        } else { 
            this->_Myoff = _VBITS - 1;
            --this->_Myptr;
        }
    }

    inline void _Inc() noexcept { 

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        do { if (_Cont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2234, 0, "%s", "cannot increment value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized vector<bool> iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2234, 0); } while (false); } ; } while (false);
        do { if (this->_Total_off(_Cont) < static_cast<_Difference_type>(_Cont->_Mysize)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2236, 0, "%s", "cannot increment vector<bool> end iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment vector<bool> end iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2236, 0); } while (false); } ; } while (false);
#line 2237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 2238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        if (this->_Myoff < _VBITS - 1) {
            ++this->_Myoff;
        } else { 
            this->_Myoff = 0;
            ++this->_Myptr;
        }
    }
};

template <class _Alvbase_wrapped>
[[nodiscard]] inline _Vb_const_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off,
    _Vb_const_iterator<_Alvbase_wrapped> _Right) noexcept {
    _Right += _Off;
    return _Right;
}

template <class _Alvbase_wrapped>
class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> {
public:
    using _Mybase          = _Vb_const_iterator<_Alvbase_wrapped>;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;

    using _Mybase::_Mybase;

    [[nodiscard]] inline reference operator*() const noexcept {

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        do { if (_Cont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2277, 0, "%s", "cannot dereference value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized vector<bool> iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2277, 0); } while (false); } ; } while (false);
        do { if (this->_Total_off(_Cont) < static_cast<_Difference_type>(_Cont->_Mysize)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2279, 0, "%s", "vector<bool> iterator not dereferenceable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator not dereferenceable\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2279, 0); } while (false); } ; } while (false);
#line 2280 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 2281 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return _Reft(*this);
    }

    
    inline _Vb_iterator& operator=(const _Vb_iterator&) noexcept = default;

    inline _Vb_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _Vb_iterator operator++(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _Vb_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _Vb_iterator operator--(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _Vb_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _Vb_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _Vb_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _Vb_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};

template <class _Alvbase_wrapped>
[[nodiscard]] inline _Vb_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_iterator<_Alvbase_wrapped> _Right) noexcept {
    _Right += _Off;
    return _Right;
}

template <class _Alloc>
class _Vb_val : public _Container_base {
public:
    using _Alvbase         = _Rebind_alloc_t<_Alloc, _Vbase>;
    using _Alvbase_traits  = allocator_traits<_Alvbase>;
    using _Vectype         = vector<_Vbase, _Alvbase>;
    using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
    using size_type        = typename _Alvbase_traits::size_type;

    inline _Vb_val() noexcept(is_nothrow_default_constructible_v<_Vectype>) : _Myvec(), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Vectype, _Alvbase>)
        : _Myvec(static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(size_type _Count, const bool& _Val)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0)), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
        : _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(_Vb_val&& _Right) noexcept(is_nothrow_move_constructible_v<_Vectype>)
        : _Myvec(::std:: move(_Right._Myvec)), _Mysize(::std:: exchange(_Right._Mysize, size_type{0})) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(_Vb_val&& _Right, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
        : _Myvec(::std:: move(_Right._Myvec), static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        if (_Right._Myvec.empty()) {
            
            _Right._Mysize = 0;
        }

        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline ~_Vb_val() noexcept {

        this->_Orphan_all();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(this->_Getal());
        _Delete_plain_internal(_Alproxy, ::std:: exchange(this->_Myproxy, nullptr));
#line 2407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }

    inline _Alvbase& _Getal() noexcept {
        return _Myvec._Getal();
    }

    inline const _Alvbase& _Getal() const noexcept {
        return _Myvec._Getal();
    }

    static inline size_type _Nw(size_type _Count) noexcept {
        return (_Count + _VBITS - 1) / _VBITS;
    }

    _Vectype _Myvec; 
    size_type _Mysize; 
};

template <class _Alloc>
class vector<bool, _Alloc> : public _Vb_val<_Alloc> {
public:
    static_assert(!0 || is_same_v<bool, typename _Alloc::value_type>,
        "vector<bool, Allocator>" " requires that Allocator's value_type match " "bool" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    using _Mybase          = _Vb_val<_Alloc>;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;

    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;

    using reference       = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using value_type      = bool;

    using _Reft          = reference;
    using iterator       = _Vb_iterator<_Alvbase_wrapped>;
    using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    static const int _VBITS = ::std:: _VBITS;
    enum { _EEN_VBITS = _VBITS }; 

    inline vector() noexcept(is_nothrow_default_constructible_v<_Mybase>) 
        : _Mybase() {}

    inline explicit vector(const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Mybase, const _Alloc&>) 
        : _Mybase(_Al) {}

    inline explicit vector(__declspec(guard(overflow)) size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, false, _Al) {
        _Trim(_Count);
    }

    inline vector(__declspec(guard(overflow)) size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) {
        _Trim(_Count);
    }

    inline vector(const vector& _Right) : _Mybase(_Right) {}

    inline vector(const vector& _Right, const _Alloc& _Al) : _Mybase(_Right, _Al) {}

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mybase(_Al) {
        _BConstruct(_First, _Last);
    }

    template <class _Iter>
    inline void _BConstruct(_Iter _First, _Iter _Last) {
        insert(begin(), _First, _Last);
    }

    inline vector(vector&& _Right) noexcept(is_nothrow_move_constructible_v<_Mybase>) 
        : _Mybase(::std:: move(_Right)) {
        this->_Swap_proxy_and_iterators(_Right);
    }

    inline vector(vector&& _Right, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>)
        : _Mybase(::std:: move(_Right), _Al) {
        if constexpr (!_Alvbase_traits::is_always_equal::value) {
            if (this->_Getal() != _Right._Getal()) {
                return;
            }
        }

        this->_Swap_proxy_and_iterators(_Right);
    }

private:

    inline void _Move_assign(vector& _Right, _Equal_allocators) noexcept {
        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
        this->_Swap_proxy_and_iterators(_Right);
    }

    inline void _Move_assign(vector& _Right, _Propagate_allocators) noexcept {
        using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
        if (this->_Getal() != _Right._Getal()) { 
            
            _Alproxy_type _Oldal(this->_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this->_Myvec  = ::std:: move(_Right._Myvec);
            this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
            _Proxy._Bind(_Oldal, this);
            this->_Swap_proxy_and_iterators(_Right);
            return;
        }

        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
        this->_Swap_proxy_and_iterators(_Right);
    }

    inline void _Move_assign(vector& _Right, _No_propagate_allocators) {
        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = _Right._Mysize;
        if (_Right._Myvec.empty()) {
            
            _Right._Mysize = 0;
        }

        if (this->_Getal() == _Right._Getal()) {
            this->_Swap_proxy_and_iterators(_Right);
        }
    }
#line 2544 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

public:
    inline vector& operator=(vector&& _Right) noexcept(is_nothrow_move_assignable_v<_Mybase>) {
        if (this != ::std:: addressof(_Right)) {



#line 2552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
            this->_Orphan_all();
            _Move_assign(_Right, _Choose_pocma<_Alvbase>{});
#line 2555 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        }
        return *this;
    }

    template <class... _Valty>
    inline decltype(auto) emplace_back(_Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        push_back(_Tmp);



#line 2567 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    }

    template <class... _Valty>
    inline iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        return insert(_Where, _Tmp);
    }

    inline vector(initializer_list<bool> _Ilist, const _Alloc& _Al = allocator_type()) : _Mybase(0, false, _Al) {
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }

    inline vector& operator=(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    inline void assign(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
    }

    inline iterator insert(const_iterator _Where, initializer_list<bool> _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    inline ~vector() noexcept {}

private:

    inline void _Copy_assign(const vector& _Right, false_type) {
        this->_Myvec  = _Right._Myvec;
        this->_Mysize = _Right._Mysize;
    }

    inline void _Copy_assign(const vector& _Right, true_type) {
        if (this->_Getal() == _Right._Getal()) {
            _Copy_assign(_Right, false_type{});
        } else {
            
            using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
            _Alproxy_type _Oldal(this->_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this->_Myvec  = _Right._Myvec;
            this->_Mysize = _Right._Mysize;
            _Proxy._Bind(_Oldal, this);
        }
    }
#line 2616 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

public:
    inline vector& operator=(const vector& _Right) {
        if (this != ::std:: addressof(_Right)) {



#line 2624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
            this->_Orphan_all();
            _Copy_assign(_Right, _Choose_pocca<_Alvbase>{});
#line 2627 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        }

        return *this;
    }

    inline void reserve(__declspec(guard(overflow)) size_type _Count) {
        this->_Myvec.reserve(this->_Nw(_Count));
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        return this->_Myvec.capacity() * _VBITS;
    }

    [[nodiscard]] inline iterator begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline iterator end() noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] inline iterator _Unchecked_begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline const_iterator _Unchecked_begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline iterator _Unchecked_end() noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator _Unchecked_end() const noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    inline void shrink_to_fit() {
        if (this->_Myvec.capacity() != this->_Myvec.size()) {
            this->_Orphan_all();
            this->_Myvec.shrink_to_fit();
        }
    }

    inline iterator _Make_iter(const_iterator _Where) noexcept {
        iterator _Tmp = begin();
        if (0 < this->_Mysize) {
            _Tmp += _Where - begin();
        }

        return _Tmp;
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    inline void resize(__declspec(guard(overflow)) size_type _Newsize, bool _Val = false) {
        if (size() < _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize < size()) {
            erase(begin() + static_cast<difference_type>(_Newsize), end());
        }
    }

    [[nodiscard]] inline size_type size() const noexcept {
        return this->_Mysize;
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        constexpr auto _Diff_max  = static_cast<size_type>((numeric_limits<difference_type>::max) ());
        const size_type _Ints_max = this->_Myvec.max_size();
        if (_Ints_max > _Diff_max / _VBITS) { 
            return _Diff_max;
        }

        
        return _Ints_max * _VBITS;
    }

    [[nodiscard]] inline bool empty() const noexcept {
        return this->_Mysize == 0;
    }

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(this->_Myvec.get_allocator());
    }

    [[nodiscard]] inline const_reference at(size_type _Off) const {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] inline reference at(size_type _Off) {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] inline const_reference operator[](size_type _Off) const noexcept  {

        do { if (_Off < this->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2769, 0, "%s", "vector<bool> subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2769, 0); } while (false); } ; } while (false);
#line 2771 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] inline reference operator[](size_type _Off) noexcept  {

        do { if (_Off < this->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2779, 0, "%s", "vector<bool> subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2779, 0); } while (false); } ; } while (false);
#line 2781 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] inline reference front() noexcept  {

        do { if (this->_Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2789, 0, "%s", "front() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector<bool>\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2789, 0); } while (false); } ; } while (false);
#line 2791 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return *begin();
    }

    [[nodiscard]] inline const_reference front() const noexcept  {

        do { if (this->_Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2797, 0, "%s", "front() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector<bool>\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2797, 0); } while (false); } ; } while (false);
#line 2799 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return *begin();
    }

    [[nodiscard]] inline reference back() noexcept  {

        do { if (this->_Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2805, 0, "%s", "back() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector<bool>\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2805, 0); } while (false); } ; } while (false);
#line 2807 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return *(end() - 1);
    }

    [[nodiscard]] inline const_reference back() const noexcept  {

        do { if (this->_Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2813, 0, "%s", "back() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector<bool>\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2813, 0); } while (false); } ; } while (false);
#line 2815 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        return *(end() - 1);
    }

    inline void push_back(const bool& _Val) {
        insert(end(), _Val);
    }

    inline void pop_back() noexcept  {
        erase(end() - 1);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline void assign(_Iter _First, _Iter _Last) {
        clear();
        insert(begin(), _First, _Last);
    }

    inline void assign(__declspec(guard(overflow)) size_type _Count, const bool& _Val) {
        clear();
        _Insert_n(begin(), _Count, _Val);
    }

    inline iterator insert(const_iterator _Where, const bool& _Val) {
        return _Insert_n(_Where, static_cast<size_type>(1), _Val);
    }

    inline iterator insert(const_iterator _Where, __declspec(guard(overflow)) size_type _Count, const bool& _Val) {
        return _Insert_n(_Where, _Count, _Val);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        difference_type _Off = _Where - begin();
        _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>{});
        return begin() + _Off;
    }

    template <class _Iter>
    inline void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
        difference_type _Off = _Where - begin();

        for (; _First != _Last; ++_First, (void) ++_Off) {
            insert(begin() + _Off, *_First);
        }
    }

    template <class _Iter>
    inline void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
        _Adl_verify_range(_First, _Last);
        auto _Count    = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        size_type _Off = _Insert_x(_Where, _Count);
        _Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), begin() + static_cast<difference_type>(_Off));
    }

    inline iterator erase(const_iterator _Where_arg) noexcept  {
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();


        do { if (end() > _Where) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2875, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> erase iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2875, 0); } while (false); } ; } while (false);
        ::std:: copy(_Next_iter(_Where), end(), _Where);
        _Orphan_range(static_cast<size_type>(_Off), this->_Mysize);



#line 2882 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        _Trim(this->_Mysize - 1);
        return begin() + _Off;
    }

    inline iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept
     {
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();

        if (_First != _Last) { 

            do { if (_Last >= _First && end() >= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2895, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> erase iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2895, 0); } while (false); } ; } while (false);
            iterator _Next      = ::std:: copy(_Last, end(), _First);
            const auto _Newsize = static_cast<size_type>(_Next - begin());
            _Orphan_range(_Newsize, this->_Mysize);
            _Trim(_Newsize);




#line 2905 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        }
        return begin() + _Off;
    }

    inline void clear() noexcept {
        this->_Orphan_all();
        this->_Myvec.clear();
        this->_Mysize = 0;
    }

    inline void flip() noexcept { 
        for (auto& _Elem : this->_Myvec) {
            _Elem = ~_Elem;
        }

        _Trim(this->_Mysize);
    }

    inline void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            this->_Swap_proxy_and_iterators(_Right);
            this->_Myvec.swap(_Right._Myvec);
            ::std:: swap(this->_Mysize, _Right._Mysize);
        }
    }

    static inline void swap(reference _Left, reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

    friend hash<vector<bool, _Alloc>>;

    inline iterator _Insert_n(const_iterator _Where, size_type _Count, const bool& _Val) {
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast<difference_type>(_Off);
        ::std:: fill(_Result, _Result + static_cast<difference_type>(_Count), _Val);
        return _Result;
    }

    inline size_type _Insert_x(const_iterator _Where, size_type _Count) {
        difference_type _Off = _Where - begin();


        do { if (end() >= _Where) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2950, 0, "%s", "vector<bool> insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> insert iterator outside range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector", 2950, 0); } while (false); } ; } while (false);
        bool _Realloc = capacity() - size() < _Count;
#line 2953 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

        if (_Count != 0) {
            if (max_size() - size() < _Count) {
                _Xlen(); 
            }

            
            this->_Myvec.resize(this->_Nw(size() + _Count), 0);
            if (empty()) {
                this->_Mysize += _Count;
            } else { 
                iterator _Oldend = end();
                this->_Mysize += _Count;
                ::std:: copy_backward(begin() + _Off, _Oldend, end());
            }


            _Orphan_range(static_cast<size_type>(_Realloc ? 0 : _Off), this->_Mysize);
#line 2972 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        }

        return static_cast<size_type>(_Off);
    }


    inline void _Orphan_range_unlocked(size_type _Offlo, size_type _Offhi) const {
        const auto _Base = this->_Myvec.data();

        _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
        while (*_Pnext) { 
            const auto& _Pnextiter = static_cast<const_iterator&>(**_Pnext);
            const auto _Temp       = *_Pnext; 
            if (!_Pnextiter._Myptr) { 
                _Temp->_Myproxy = nullptr;
                *_Pnext         = _Temp->_Mynextiter;
                continue;
            }
            const auto _Off = static_cast<size_type>(_VBITS * (_Pnextiter._Myptr - _Base)) + _Pnextiter._Myoff;
            if (_Off < _Offlo || _Offhi < _Off) {
                _Pnext = &_Temp->_Mynextiter;
            } else { 
                _Temp->_Myproxy = nullptr;
                *_Pnext         = _Temp->_Mynextiter;
            }
        }
    }

    void _Orphan_range_locked(size_type _Offlo, size_type _Offhi) const {
        _Lockit _Lock(3);
        _Orphan_range_unlocked(_Offlo, _Offhi);
    }

    inline void _Orphan_range(size_type _Offlo, size_type _Offhi) const {




#line 3011 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
        {
            _Orphan_range_locked(_Offlo, _Offhi);
        }
    }
#line 3016 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

    inline void _Trim(size_type _Size) {
        if (max_size() < _Size) {
            _Xlen(); 
        }

        const size_type _Words = this->_Nw(_Size);
        if (_Words < this->_Myvec.size()) {
            this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());
        }

        this->_Mysize = _Size;
        _Size %= _VBITS;
        if (0 < _Size) {
            this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
        }
    }

    [[noreturn]] void _Xlen() const {
        _Xlength_error("vector<bool> too long");
    }

    [[noreturn]] void _Xran() const {
        _Xout_of_range("invalid vector<bool> subscript");
    }
};

template <class _Alloc>
struct hash<vector<bool, _Alloc>> {
     typedef vector<bool, _Alloc> argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const vector<bool, _Alloc>& _Keyval) const noexcept {
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};






#line 3059 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"

template <class _Alloc, bool _RequiresMutable>
 constexpr bool _Is_vb_iterator<_Vb_iterator<_Alloc>, _RequiresMutable> = true;

template <class _Alloc>
 constexpr bool _Is_vb_iterator<_Vb_const_iterator<_Alloc>, false> = true;

template <class _VbIt, class _Ty>
inline void _Fill_vbool(_VbIt _First, _VbIt _Last, const _Ty& _Val) {
    
    if (_First == _Last) {
        return;
    }

    _Vbase* _VbFirst      = const_cast<_Vbase*>(_First._Myptr);
    _Vbase* const _VbLast = const_cast<_Vbase*>(_Last._Myptr);

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;
    const auto _FirstDestMask   = ~_FirstSourceMask;
    const auto _FillVal         = static_cast<_Vbase>(_Val ? -1 : 0);

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _DestMask       = _FirstDestMask | _LastDestMask;
        *_VbFirst                  = (*_VbFirst & _DestMask) | (_FillVal & _SourceMask);
        return;
    }

    *_VbFirst = (*_VbFirst & _FirstDestMask) | (_FillVal & _FirstSourceMask);
    ++_VbFirst;







#line 3100 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
    {
        const auto _VbFirst_ch = reinterpret_cast<const char*>(_VbFirst);
        const auto _VbLast_ch  = reinterpret_cast<const char*>(_VbLast);
        const auto _Count_ch   = static_cast<size_t>(_VbLast_ch - _VbFirst_ch);
        const auto _ValChar    = static_cast<unsigned char>(_Val ? -1 : 0);
        :: memset(_VbFirst, _ValChar, _Count_ch);
        _VbFirst = _VbLast;
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        *_VbFirst                  = (*_VbFirst & _LastDestMask) | (_FillVal & _LastSourceMask);
    }
}

template <class _VbIt, class _Ty>
[[nodiscard]] inline _VbIt _Find_vbool(_VbIt _First, const _VbIt _Last, const _Ty& _Val) {
    
    if (_First == _Last) {
        return _First;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) & _SourceMask;
        const auto _Count          = _Countr_zero(_SelectVal);
        return _Count == _VBITS ? _Last : _First + static_cast<ptrdiff_t>(_Count - _First._Myoff);
    }

    const auto _FirstVal   = (_Val ? *_VbFirst : ~*_VbFirst) & _FirstSourceMask;
    const auto _FirstCount = _Countr_zero(_FirstVal);
    if (_FirstCount != _VBITS) {
        return _First + static_cast<ptrdiff_t>(_FirstCount - _First._Myoff);
    }
    ++_VbFirst;

    _Iter_diff_t<_VbIt> _TotalCount = static_cast<ptrdiff_t>(_VBITS - _First._Myoff);
    for (; _VbFirst != _VbLast; ++_VbFirst, _TotalCount += _VBITS) {
        const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
        const auto _Count     = _Countr_zero(_SelectVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) & _LastSourceMask;
        const auto _Count          = _Countr_zero(_LastVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    return _Last;
}

template <class _VbIt, class _Ty>
[[nodiscard]] inline _Iter_diff_t<_VbIt> _Count_vbool(_VbIt _First, const _VbIt _Last, const _Ty& _Val) {
    if (_First == _Last) {
        return 0;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) & _SourceMask;
        return _Popcount(_SelectVal);
    }

    const auto _FirstVal       = (_Val ? *_VbFirst : ~*_VbFirst) & _FirstSourceMask;
    _Iter_diff_t<_VbIt> _Count = _Popcount(_FirstVal);
    ++_VbFirst;

    for (; _VbFirst != _VbLast; ++_VbFirst) {
        const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
        _Count += _Popcount(_SelectVal);
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) & _LastSourceMask;
        _Count += _Popcount(_LastVal);
    }

    return _Count;
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 3208 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#line 3209 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vector"
#pragma external_header(pop)
#line 4 "C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"









#pragma once









#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"







#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"






#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"








#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"




#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

#pragma warning(push)
#pragma warning(disable:4514 4820)

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\math.h"















#pragma external_header(pop)
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

#pragma warning(pop)




#pragma warning(push)
#pragma warning(disable : 4987)

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"












#pragma once





#pragma warning(push)
#pragma warning(disable:   4514 4820 )


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\setjmp.h"







#pragma once












#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {
























#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\setjmp.h"

    typedef struct __declspec(align(16)) _SETJMP_FLOAT128
    {
        unsigned __int64 Part[2];
    } SETJMP_FLOAT128;

    
    typedef SETJMP_FLOAT128 _JBTYPE;

    typedef struct _JUMP_BUFFER
    {
        unsigned __int64 Frame;
        unsigned __int64 Rbx;
        unsigned __int64 Rsp;
        unsigned __int64 Rbp;
        unsigned __int64 Rsi;
        unsigned __int64 Rdi;
        unsigned __int64 R12;
        unsigned __int64 R13;
        unsigned __int64 R14;
        unsigned __int64 R15;
        unsigned __int64 Rip;
        unsigned long MxCsr;
        unsigned short FpCsr;
        unsigned short Spare;

        SETJMP_FLOAT128 Xmm6;
        SETJMP_FLOAT128 Xmm7;
        SETJMP_FLOAT128 Xmm8;
        SETJMP_FLOAT128 Xmm9;
        SETJMP_FLOAT128 Xmm10;
        SETJMP_FLOAT128 Xmm11;
        SETJMP_FLOAT128 Xmm12;
        SETJMP_FLOAT128 Xmm13;
        SETJMP_FLOAT128 Xmm14;
        SETJMP_FLOAT128 Xmm15;
    } _JUMP_BUFFER;






















































#line 142 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\setjmp.h"





    
    typedef _JBTYPE jmp_buf[16];
#line 150 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\setjmp.h"




    
#line 156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\setjmp.h"




int __cdecl _setjmp(
      jmp_buf _Buf
    );


    __declspec(noreturn) void __cdecl longjmp(
          jmp_buf _Buf,
          int     _Value
        ) noexcept(false);





#line 175 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\setjmp.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"



#line 28 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"



    
        #pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"











#pragma once



#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"







#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"












#pragma once



#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"







#line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"













#pragma once



#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"







#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"













#pragma once



#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"







#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"






#pragma once



#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"







#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"












#pragma once



#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"







#line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
















#pragma once



#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"







#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"



#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"























#pragma once



#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"







#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"










#pragma once






#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"



#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"


extern "C" { 


#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;









































































































































#line 180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"


}; 
#line 184 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"

#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"
#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"
#line 188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mmintrin.h"
#pragma external_header(pop)
#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"
#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;




#line 77 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"
#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 












































































 
 
 


extern "C" { 
  
#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern float _mm_cvtss_f32(__m128 _A);








#line 278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"





extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#line 287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);



















#line 322 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);


#line 346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);
























#line 377 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"







 
 
 





















































































































#line 505 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"



}; 
#line 510 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"

#line 512 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"
#line 513 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"
#line 514 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xmmintrin.h"
#pragma external_header(pop)
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);





#line 162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);










extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);


#line 222 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);


#line 240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);


#line 248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);

extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);

extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);







#line 346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1,__int64 _I0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);


#line 357 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);


#line 365 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);



#line 392 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);






extern __int64 _mm_cvtsd_si64(__m128d);
extern __int64 _mm_cvttsd_si64(__m128d);
extern __m128d _mm_cvtsi64_sd(__m128d, __int64);
extern __m128i _mm_cvtsi64_si128(__int64);
extern __int64 _mm_cvtsi128_si64(__m128i);


#line 437 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"


}; 
#line 441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"

#line 443 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
#line 444 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
#line 445 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\emmintrin.h"
#pragma external_header(pop)
#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"

 
 
 














 
 
 


extern "C" { 
  
#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );





extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );




extern __m128i _mm_lddqu_si128(__m128i const * );







extern void _mm_monitor(void const * , unsigned , unsigned );




extern void _mm_mwait(unsigned , unsigned );


}; 
#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"

#line 101 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"
#line 102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"
#line 103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pmmintrin.h"
#pragma external_header(pop)
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"









extern "C" {
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    
    
    
    
    

    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);





#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    
    
    
    
    
    

    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);





#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    
    
    
    
    
    
    

    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);



#line 83 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);



#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);



#line 101 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);





#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);



#line 123 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);





#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"


};
#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"

#line 142 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"
#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"
#line 144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tmmintrin.h"
#pragma external_header(pop)
#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"


















































extern "C" {
#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128, __m128, const int );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128 );

        
        

        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );

        
        

        extern __m128  _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);

        

        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);

        
        

        extern __m128i _mm_mullo_epi32(__m128i, __m128i);

        
        

        extern __m128i _mm_mul_epi32(__m128i, __m128i);

        
        

        extern int _mm_testz_si128(__m128i , __m128i );

        
        

        extern int _mm_testc_si128(__m128i , __m128i );

        
        
        

        extern int _mm_testnzc_si128(__m128i , __m128i );

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );

        




        
        

        extern int _mm_extract_ps(__m128 , const int );

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );


        extern __m128i _mm_insert_epi64(__m128i , __int64 , const int );
#line 190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i , const int );
        extern int   _mm_extract_epi32(__m128i , const int );


        extern __int64 _mm_extract_epi64(__m128i , const int );
#line 199 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i);

        

        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );

        

        extern __m128  _mm_round_ps(__m128  , int );
        extern __m128  _mm_round_ss(__m128 , __m128  , int );

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);


        
        

        extern __m128i _mm_packus_epi32(__m128i, __m128i);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );

        





#line 252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"
        extern __m128i _mm_stream_load_si128(const __m128i*);
#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"


}; 
#line 258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"

#line 260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"
#line 261 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"
#line 262 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\smmintrin.h"
#pragma external_header(pop)
#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"



extern "C" {
#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int     _mm_cmpistri (__m128i , __m128i , const int );

    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestri (__m128i , int , __m128i , int , const int );





    extern int     _mm_cmpistrz (__m128i , __m128i , const int );
    extern int     _mm_cmpistrc (__m128i , __m128i , const int );
    extern int     _mm_cmpistrs (__m128i , __m128i , const int );
    extern int     _mm_cmpistro (__m128i , __m128i , const int );
    extern int     _mm_cmpistra (__m128i , __m128i , const int );

    extern int     _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestra (__m128i , int , __m128i , int , const int );






    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );





    extern int _mm_popcnt_u32(unsigned int );


    extern __int64 _mm_popcnt_u64(unsigned __int64 );
#line 117 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );


    extern unsigned __int64 _mm_crc32_u64(unsigned __int64 , unsigned __int64 );
#line 129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"


}; 
#line 133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"

#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"
#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"
#line 137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\nmmintrin.h"
#pragma external_header(pop)
#line 28 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"



extern "C" {
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i , __m128i );





extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );





extern __m128i _mm_aesenc_si128(__m128i , __m128i );





extern __m128i _mm_aesenclast_si128(__m128i , __m128i );





extern __m128i _mm_aesimc_si128(__m128i );






extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );







extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );



}; 
#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"

#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"
#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"
#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\wmmintrin.h"
#pragma external_header(pop)
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"


extern "C" {
#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);





extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);





extern int __cdecl _mm_comi_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);



























#line 612 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"








extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);

extern void __cdecl _xsave64(void *, unsigned __int64);
#line 1260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);

extern void __cdecl _xsaveopt64(void *, unsigned __int64);
#line 1270 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"





extern void __cdecl _xsavec(void *, unsigned __int64);

extern void __cdecl _xsavec64(void *, unsigned __int64);
#line 1279 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);

extern void __cdecl _xrstor64(void const *, unsigned __int64);
#line 1289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"






extern void __cdecl _xsaves(void *, unsigned __int64);

extern void __cdecl _xsaves64(void *, unsigned __int64);
#line 1299 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"






extern void __cdecl _xrstors(void const *, unsigned __int64);

extern void __cdecl _xrstors64(void const *, unsigned __int64);
#line 1309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);

extern void __cdecl _fxsave64(void *);
#line 1318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);

extern void __cdecl _fxrstor64(void const *);
#line 1327 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);

extern int __cdecl _rdrand64_step(unsigned __int64 *);
#line 1339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"





extern unsigned int     __cdecl _readfsbase_u32(void);
extern unsigned int     __cdecl _readgsbase_u32(void);
extern unsigned __int64 __cdecl _readfsbase_u64(void);
extern unsigned __int64 __cdecl _readgsbase_u64(void);




extern void __cdecl _writefsbase_u32(unsigned int);
extern void __cdecl _writegsbase_u32(unsigned int);
extern void __cdecl _writefsbase_u64(unsigned __int64);
extern void __cdecl _writegsbase_u64(unsigned __int64);
#line 1357 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);


extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
















extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _bextr2_u32(unsigned int ,
                                    unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );


extern unsigned __int64 _bextr_u64(unsigned __int64 ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned __int64 _bextr2_u64(unsigned __int64 ,
                                    unsigned __int64 );
extern unsigned __int64 _blsi_u64(unsigned __int64);
extern unsigned __int64 _blsmsk_u64(unsigned __int64);
extern unsigned __int64 _blsr_u64(unsigned __int64);
extern unsigned __int64 _bzhi_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _mulx_u64(unsigned __int64 ,
                                  unsigned __int64 ,
                                  unsigned __int64 * );
extern unsigned __int64 _pdep_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _pext_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _rorx_u64(unsigned __int64 ,
                                  const unsigned int );
extern __int64          _sarx_i64(__int64 ,
                                  unsigned int );
extern unsigned __int64 _shlx_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _shrx_u64(unsigned __int64 ,
                                          unsigned int );
#line 1894 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);

extern unsigned __int64 _lzcnt_u64(unsigned __int64);
#line 1906 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"








extern unsigned int     _tzcnt_u32(unsigned int);

extern unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 1918 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);


extern void _Store64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedExchangeAdd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchangeAdd64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedAnd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedAnd64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLERelease(__int64 volatile *,__int64);

extern unsigned char _interlockedbittestandset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandset64_HLERelease(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLERelease(__int64 *,__int64);
#line 1977 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);

extern int __cdecl _rdseed64_step(unsigned __int64 *);
#line 2005 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"










extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );



extern unsigned char __cdecl _addcarryx_u64(unsigned char ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 * );
#line 2027 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"





extern unsigned short   __cdecl _load_be_u16(void const*);
extern unsigned int     __cdecl _load_be_u32(void const*);
extern unsigned __int64 __cdecl _load_be_u64(void const*);







extern void __cdecl _store_be_u16(void *, unsigned short);
extern void __cdecl _store_be_u32(void *, unsigned int);
extern void __cdecl _store_be_u64(void *, unsigned __int64);







extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int);

extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);




extern void * __cdecl _bnd_set_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t);
extern void * __cdecl _bnd_copy_ptr_bounds(const void *, const void *);
extern void * __cdecl _bnd_init_ptr_bounds(const void *);
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *);
extern void __cdecl _bnd_chk_ptr_lbounds(const void *);
extern void __cdecl _bnd_chk_ptr_ubounds(const void *);
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_load_ptr_bounds(const void **, const void *);
extern const void * __cdecl _bnd_get_ptr_lbound(const void *);
extern const void * __cdecl _bnd_get_ptr_ubound(const void *);


extern __m256i __cdecl _mm256_insert_epi8 (__m256i , int , const int );
extern __m256i __cdecl _mm256_insert_epi16(__m256i , int , const int );
extern __m256i __cdecl _mm256_insert_epi32(__m256i , int , const int );

extern __m256i __cdecl _mm256_insert_epi64(__m256i , __int64 , const int );
#line 2083 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"


extern int __cdecl _mm256_extract_epi8 (__m256i , const int );
extern int __cdecl _mm256_extract_epi16(__m256i , const int );
extern int __cdecl _mm256_extract_epi32(__m256i , const int );

extern __int64 __cdecl _mm256_extract_epi64(__m256i , const int );
#line 2091 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"


extern __m256d __cdecl _mm256_zextpd128_pd256(__m128d);
extern __m256  __cdecl _mm256_zextps128_ps256(__m128);
extern __m256i __cdecl _mm256_zextsi128_si256(__m128i);


extern unsigned int __cdecl _rdpid_u32(void);

extern void         __cdecl _ptwrite32(unsigned int);

extern void         __cdecl _ptwrite64(unsigned __int64);
#line 2104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"


extern __m128i __cdecl _mm_dpbusd_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusd_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbusds_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusds_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwssd_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssd_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwssds_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssds_avx_epi32(__m256i, __m256i, __m256i);


extern unsigned int __cdecl _pconfig_u32(const int, size_t __data[]);
extern void __cdecl _wbnoinvd(void);


extern unsigned int __cdecl _encls_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclu_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclv_u32(const int, size_t __data[]);



extern unsigned __int64 __cdecl _udiv128(unsigned __int64 , unsigned __int64 , unsigned __int64 , unsigned __int64* );
extern __int64          __cdecl _div128(__int64 , __int64 , __int64 , __int64* );
#line 2129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"
extern unsigned         __cdecl _udiv64(unsigned __int64 , unsigned , unsigned* );
extern int              __cdecl _div64(__int64 , int , int* );


extern unsigned char _mm_aesdec128kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesdec256kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesdecwide128kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned char _mm_aesdecwide256kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned char _mm_aesenc128kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesenc256kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesencwide128kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned char _mm_aesencwide256kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned int  _mm_encodekey128_u32(unsigned int , __m128i , void* );
extern unsigned int  _mm_encodekey256_u32(unsigned int , __m128i , __m128i , void* );
extern void          _mm_loadiwkey(unsigned int , __m128i , __m128i , __m128i );


extern unsigned int     __cdecl _rdpkru_u32(void);
extern void             __cdecl _wrpkru(unsigned int);


extern int              __cdecl _enqcmd(void * , const void * );
extern int              __cdecl _enqcmds(void * , const void * );




extern void             __cdecl _incsspd (unsigned int);
extern unsigned int     __cdecl _rdsspd (void);
extern void             __cdecl _saveprevssp (void);
extern void             __cdecl _rstorssp (void *);
extern void             __cdecl _wrssd (unsigned int, void *);
extern void             __cdecl _wrussd (unsigned int, void *);
extern void             __cdecl _setssbsy (void);
extern void             __cdecl _clrssbsy (void *);
extern void *           __cdecl _switchssp(void *);

extern void             __cdecl _incsspq (unsigned __int64);
extern unsigned __int64 __cdecl _rdsspq (void);
extern void             __cdecl _wrssq (unsigned __int64, void *);
extern void             __cdecl _wrussq(unsigned __int64, void *);
#line 2171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"






extern __m128i _mm_div_epi8(__m128i, __m128i);
extern __m128i _mm_div_epi16(__m128i, __m128i);
extern __m128i _mm_div_epi32(__m128i, __m128i);
extern __m128i _mm_div_epi64(__m128i, __m128i);
extern __m128i _mm_div_epu8(__m128i, __m128i);
extern __m128i _mm_div_epu16(__m128i, __m128i);
extern __m128i _mm_div_epu32(__m128i, __m128i);
extern __m128i _mm_div_epu64(__m128i, __m128i);
extern __m128i _mm_rem_epi8(__m128i, __m128i);
extern __m128i _mm_rem_epi16(__m128i, __m128i);
extern __m128i _mm_rem_epi32(__m128i, __m128i);
extern __m128i _mm_rem_epi64(__m128i, __m128i);
extern __m128i _mm_rem_epu8(__m128i, __m128i);
extern __m128i _mm_rem_epu16(__m128i, __m128i);
extern __m128i _mm_rem_epu32(__m128i, __m128i);
extern __m128i _mm_rem_epu64(__m128i, __m128i);
extern __m256i _mm256_div_epi8(__m256i, __m256i);
extern __m256i _mm256_div_epi16(__m256i, __m256i);
extern __m256i _mm256_div_epi32(__m256i, __m256i);
extern __m256i _mm256_div_epi64(__m256i, __m256i);
extern __m256i _mm256_div_epu8(__m256i, __m256i);
extern __m256i _mm256_div_epu16(__m256i, __m256i);
extern __m256i _mm256_div_epu32(__m256i, __m256i);
extern __m256i _mm256_div_epu64(__m256i, __m256i);
extern __m256i _mm256_rem_epi8(__m256i, __m256i);
extern __m256i _mm256_rem_epi16(__m256i, __m256i);
extern __m256i _mm256_rem_epi32(__m256i, __m256i);
extern __m256i _mm256_rem_epi64(__m256i, __m256i);
extern __m256i _mm256_rem_epu8(__m256i, __m256i);
extern __m256i _mm256_rem_epu16(__m256i, __m256i);
extern __m256i _mm256_rem_epu32(__m256i, __m256i);
extern __m256i _mm256_rem_epu64(__m256i, __m256i);










extern __m128i _mm_divrem_epi32(__m128i * , __m128i, __m128i);
extern __m128i _mm_divrem_epu32(__m128i * , __m128i, __m128i);
extern __m256i _mm256_divrem_epi32(__m256i * , __m256i, __m256i);
extern __m256i _mm256_divrem_epu32(__m256i * , __m256i, __m256i);







extern __m128  _mm_sin_ps(__m128);
extern __m128d _mm_sin_pd(__m128d);
extern __m256  _mm256_sin_ps(__m256);
extern __m256d _mm256_sin_pd(__m256d);
extern __m128  _mm_cos_ps(__m128);
extern __m128d _mm_cos_pd(__m128d);
extern __m256  _mm256_cos_ps(__m256);
extern __m256d _mm256_cos_pd(__m256d);
extern __m128  _mm_sincos_ps(__m128  * , __m128);
extern __m128d _mm_sincos_pd(__m128d * , __m128d);
extern __m256  _mm256_sincos_ps(__m256  * , __m256);
extern __m256d _mm256_sincos_pd(__m256d * , __m256d);
extern __m128  _mm_tan_ps(__m128);
extern __m128d _mm_tan_pd(__m128d);
extern __m256  _mm256_tan_ps(__m256);
extern __m256d _mm256_tan_pd(__m256d);
extern __m128  _mm_asin_ps(__m128);
extern __m128d _mm_asin_pd(__m128d);
extern __m256  _mm256_asin_ps(__m256);
extern __m256d _mm256_asin_pd(__m256d);
extern __m128  _mm_acos_ps(__m128);
extern __m128d _mm_acos_pd(__m128d);
extern __m256  _mm256_acos_ps(__m256);
extern __m256d _mm256_acos_pd(__m256d);
extern __m128  _mm_atan_ps(__m128);
extern __m128d _mm_atan_pd(__m128d);
extern __m256  _mm256_atan_ps(__m256);
extern __m256d _mm256_atan_pd(__m256d);
extern __m128  _mm_atan2_ps(__m128, __m128);
extern __m128d _mm_atan2_pd(__m128d, __m128d);
extern __m256  _mm256_atan2_ps(__m256, __m256);
extern __m256d _mm256_atan2_pd(__m256d, __m256d);
extern __m128  _mm_sind_ps(__m128);
extern __m128d _mm_sind_pd(__m128d);
extern __m256  _mm256_sind_ps(__m256);
extern __m256d _mm256_sind_pd(__m256d);
extern __m128  _mm_cosd_ps(__m128);
extern __m128d _mm_cosd_pd(__m128d);
extern __m256  _mm256_cosd_ps(__m256);
extern __m256d _mm256_cosd_pd(__m256d);
extern __m128  _mm_tand_ps(__m128);
extern __m128d _mm_tand_pd(__m128d);
extern __m256  _mm256_tand_ps(__m256);
extern __m256d _mm256_tand_pd(__m256d);
extern __m128  _mm_sinh_ps(__m128);
extern __m128d _mm_sinh_pd(__m128d);
extern __m256  _mm256_sinh_ps(__m256);
extern __m256d _mm256_sinh_pd(__m256d);
extern __m128  _mm_cosh_ps(__m128);
extern __m128d _mm_cosh_pd(__m128d);
extern __m256  _mm256_cosh_ps(__m256);
extern __m256d _mm256_cosh_pd(__m256d);
extern __m128  _mm_tanh_ps(__m128);
extern __m128d _mm_tanh_pd(__m128d);
extern __m256  _mm256_tanh_ps(__m256);
extern __m256d _mm256_tanh_pd(__m256d);
extern __m128  _mm_asinh_ps(__m128);
extern __m128d _mm_asinh_pd(__m128d);
extern __m256  _mm256_asinh_ps(__m256);
extern __m256d _mm256_asinh_pd(__m256d);
extern __m128  _mm_acosh_ps(__m128);
extern __m128d _mm_acosh_pd(__m128d);
extern __m256  _mm256_acosh_ps(__m256);
extern __m256d _mm256_acosh_pd(__m256d);
extern __m128  _mm_atanh_ps(__m128);
extern __m128d _mm_atanh_pd(__m128d);
extern __m256  _mm256_atanh_ps(__m256);
extern __m256d _mm256_atanh_pd(__m256d);
extern __m128  _mm_log_ps(__m128);
extern __m128d _mm_log_pd(__m128d);
extern __m256  _mm256_log_ps(__m256);
extern __m256d _mm256_log_pd(__m256d);
extern __m128  _mm_log1p_ps(__m128);
extern __m128d _mm_log1p_pd(__m128d);
extern __m256  _mm256_log1p_ps(__m256);
extern __m256d _mm256_log1p_pd(__m256d);
extern __m128  _mm_log10_ps(__m128);
extern __m128d _mm_log10_pd(__m128d);
extern __m256  _mm256_log10_ps(__m256);
extern __m256d _mm256_log10_pd(__m256d);
extern __m128  _mm_log2_ps(__m128);
extern __m128d _mm_log2_pd(__m128d);
extern __m256  _mm256_log2_ps(__m256);
extern __m256d _mm256_log2_pd(__m256d);
extern __m128  _mm_logb_ps(__m128);
extern __m128d _mm_logb_pd(__m128d);
extern __m256  _mm256_logb_ps(__m256);
extern __m256d _mm256_logb_pd(__m256d);
extern __m128  _mm_exp_ps(__m128);
extern __m128d _mm_exp_pd(__m128d);
extern __m256  _mm256_exp_ps(__m256);
extern __m256d _mm256_exp_pd(__m256d);
extern __m128  _mm_exp10_ps(__m128);
extern __m128d _mm_exp10_pd(__m128d);
extern __m256  _mm256_exp10_ps(__m256);
extern __m256d _mm256_exp10_pd(__m256d);
extern __m128  _mm_exp2_ps(__m128);
extern __m128d _mm_exp2_pd(__m128d);
extern __m256  _mm256_exp2_ps(__m256);
extern __m256d _mm256_exp2_pd(__m256d);
extern __m128  _mm_expm1_ps(__m128);
extern __m128d _mm_expm1_pd(__m128d);
extern __m256  _mm256_expm1_ps(__m256);
extern __m256d _mm256_expm1_pd(__m256d);
extern __m128  _mm_pow_ps(__m128, __m128);
extern __m128d _mm_pow_pd(__m128d, __m128d);
extern __m256  _mm256_pow_ps(__m256, __m256);
extern __m256d _mm256_pow_pd(__m256d, __m256d);
extern __m128  _mm_trunc_ps(__m128);
extern __m128d _mm_trunc_pd(__m128d);
extern __m256  _mm256_trunc_ps(__m256);
extern __m256d _mm256_trunc_pd(__m256d);
extern __m128  _mm_svml_floor_ps(__m128);
extern __m128d _mm_svml_floor_pd(__m128d);
extern __m256  _mm256_svml_floor_ps(__m256);
extern __m256d _mm256_svml_floor_pd(__m256d);
extern __m128  _mm_svml_ceil_ps(__m128);
extern __m128d _mm_svml_ceil_pd(__m128d);
extern __m256  _mm256_svml_ceil_ps(__m256);
extern __m256d _mm256_svml_ceil_pd(__m256d);
extern __m128  _mm_svml_round_ps(__m128);
extern __m128d _mm_svml_round_pd(__m128d);
extern __m256  _mm256_svml_round_ps(__m256);
extern __m256d _mm256_svml_round_pd(__m256d);
extern __m128  _mm_fmod_ps(__m128, __m128);
extern __m128d _mm_fmod_pd(__m128d, __m128d);
extern __m256  _mm256_fmod_ps(__m256, __m256);
extern __m256d _mm256_fmod_pd(__m256d, __m256d);
extern __m128  _mm_svml_sqrt_ps(__m128);
extern __m128d _mm_svml_sqrt_pd(__m128d);
extern __m256  _mm256_svml_sqrt_ps(__m256);
extern __m256d _mm256_svml_sqrt_pd(__m256d);
extern __m128  _mm_invsqrt_ps(__m128);
extern __m128d _mm_invsqrt_pd(__m128d);
extern __m256  _mm256_invsqrt_ps(__m256);
extern __m256d _mm256_invsqrt_pd(__m256d);
extern __m128  _mm_cbrt_ps(__m128);
extern __m128d _mm_cbrt_pd(__m128d);
extern __m256  _mm256_cbrt_ps(__m256);
extern __m256d _mm256_cbrt_pd(__m256d);
extern __m128  _mm_invcbrt_ps(__m128);
extern __m128d _mm_invcbrt_pd(__m128d);
extern __m256  _mm256_invcbrt_ps(__m256);
extern __m256d _mm256_invcbrt_pd(__m256d);
extern __m128  _mm_hypot_ps(__m128, __m128);
extern __m128d _mm_hypot_pd(__m128d, __m128d);
extern __m256  _mm256_hypot_ps(__m256, __m256);
extern __m256d _mm256_hypot_pd(__m256d, __m256d);
extern __m128  _mm_cdfnorm_ps(__m128);
extern __m128d _mm_cdfnorm_pd(__m128d);
extern __m256  _mm256_cdfnorm_ps(__m256);
extern __m256d _mm256_cdfnorm_pd(__m256d);
extern __m128  _mm_cdfnorminv_ps(__m128);
extern __m128d _mm_cdfnorminv_pd(__m128d);
extern __m256  _mm256_cdfnorminv_ps(__m256);
extern __m256d _mm256_cdfnorminv_pd(__m256d);
extern __m128  _mm_cexp_ps(__m128);
extern __m256  _mm256_cexp_ps(__m256);
extern __m128  _mm_clog_ps(__m128);
extern __m256  _mm256_clog_ps(__m256);
extern __m128  _mm_csqrt_ps(__m128);
extern __m256  _mm256_csqrt_ps(__m256);
extern __m128  _mm_erf_ps(__m128);
extern __m128d _mm_erf_pd(__m128d);
extern __m256  _mm256_erf_ps(__m256);
extern __m256d _mm256_erf_pd(__m256d);
extern __m128  _mm_erfc_ps(__m128);
extern __m128d _mm_erfc_pd(__m128d);
extern __m256  _mm256_erfc_ps(__m256);
extern __m256d _mm256_erfc_pd(__m256d);
extern __m128  _mm_erfcinv_ps(__m128);
extern __m128d _mm_erfcinv_pd(__m128d);
extern __m256  _mm256_erfcinv_ps(__m256);
extern __m256d _mm256_erfcinv_pd(__m256d);
extern __m128  _mm_erfinv_ps(__m128);
extern __m128d _mm_erfinv_pd(__m128d);
extern __m256  _mm256_erfinv_ps(__m256);
extern __m256d _mm256_erfinv_pd(__m256d);


extern void _mm_cldemote(void const *);



extern void _directstoreu_u32(void *, unsigned int);

extern void _directstoreu_u64(void *, unsigned __int64);
#line 2418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"
extern void _movdir64b(void *, void const *);


extern void __cdecl _serialize(void);
extern void __cdecl _xsusldtrk(void);
extern void __cdecl _xresldtrk(void);


extern void _umonitor(void *);
extern unsigned char _umwait(unsigned int, unsigned __int64);
extern unsigned char _tpause(unsigned int, unsigned __int64);



extern void _clui(void);
extern void _stui(void);
extern unsigned char _testui(void);
extern void _senduipi(unsigned __int64);
#line 2437 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"


extern void _hreset(unsigned __int32);


extern __m128 _mm_svml_cvtepu32_ps (__m128i);
extern __m256 _mm256_svml_cvtepu32_ps (__m256i);
extern __m128d _mm_svml_cvtepu32_pd (__m128i);
extern __m256d _mm256_svml_cvtepu32_pd (__m128i);
extern __m128d _mm_svml_cvtepi64_pd (__m128i);
extern __m256d _mm256_svml_cvtepi64_pd (__m256i);
extern __m128d _mm_svml_cvtepu64_pd (__m128i);
extern __m256d _mm256_svml_cvtepu64_pd (__m256i);


}; 
#line 2454 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\zmmintrin.h"









































typedef unsigned char       __mmask8;
typedef unsigned short      __mmask16;
typedef unsigned int        __mmask32;
typedef unsigned __int64    __mmask64;

typedef union __declspec(intrin_type) __declspec(align(64)) __m512 {
    float m512_f32[16];
} __m512;

typedef struct __declspec(intrin_type) __declspec(align(64)) __m512d {
    double m512d_f64[8];
} __m512d;

typedef union  __declspec(intrin_type) __declspec(align(64)) __m512i {
    __int8              m512i_i8[64];
    __int16             m512i_i16[32];
    __int32             m512i_i32[16];
    __int64             m512i_i64[8];
    unsigned __int8     m512i_u8[64];
    unsigned __int16    m512i_u16[32];
    unsigned __int32    m512i_u32[16];
    unsigned __int64    m512i_u64[8];
} __m512i;



extern "C" {

#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\zmmintrin.h"


extern __m256  __cdecl _mm512_castps512_ps256(__m512);
extern __m512  __cdecl _mm512_castpd_ps(__m512d);
extern __m512  __cdecl _mm512_castps256_ps512(__m256);
extern __m512  __cdecl _mm512_castsi512_ps(__m512i);
extern __m512  __cdecl _mm512_castps128_ps512(__m128);

extern __m256d __cdecl _mm512_castpd512_pd256(__m512d);
extern __m512d __cdecl _mm512_castpd256_pd512(__m256d);
extern __m512d __cdecl _mm512_castps_pd(__m512);
extern __m512d __cdecl _mm512_castsi512_pd(__m512i);
extern __m512d __cdecl _mm512_castpd128_pd512(__m128d);

extern __m256i __cdecl _mm512_castsi512_si256(__m512i);
extern __m512i __cdecl _mm512_castpd_si512(__m512d);
extern __m512i __cdecl _mm512_castps_si512(__m512);
extern __m512i __cdecl _mm512_castsi256_si512(__m256i);








typedef enum {
    _MM_BROADCAST32_NONE,   

    _MM_BROADCAST_1X16,     
    _MM_BROADCAST_4X16      
} _MM_BROADCAST32_ENUM;


typedef enum {
    _MM_BROADCAST64_NONE,   

    _MM_BROADCAST_1X8,      
    _MM_BROADCAST_4X8       
} _MM_BROADCAST64_ENUM;






typedef enum {
    _MM_ROUND_MODE_NEAREST,             
    _MM_ROUND_MODE_DOWN,                
    _MM_ROUND_MODE_UP,                  
    _MM_ROUND_MODE_TOWARD_ZERO,         
    _MM_ROUND_MODE_DEFAULT,             
    _MM_ROUND_MODE_NO_EXC = 8,          
} _MM_ROUND_MODE_ENUM;


typedef enum {
    _MM_EXPADJ_NONE,               
    _MM_EXPADJ_4,                  
    _MM_EXPADJ_5,                  
    _MM_EXPADJ_8,                  
    _MM_EXPADJ_16,                 
    _MM_EXPADJ_24,                 
    _MM_EXPADJ_31,                 
    _MM_EXPADJ_32                  
} _MM_EXP_ADJ_ENUM;


typedef enum {
    _MM_SCALE_1 = 1,
    _MM_SCALE_2 = 2,
    _MM_SCALE_4 = 4,
    _MM_SCALE_8 = 8
} _MM_INDEX_SCALE_ENUM;


typedef enum {
    _MM_PERM_AAAA = 0x00, _MM_PERM_AAAB = 0x01, _MM_PERM_AAAC = 0x02,
    _MM_PERM_AAAD = 0x03, _MM_PERM_AABA = 0x04, _MM_PERM_AABB = 0x05,
    _MM_PERM_AABC = 0x06, _MM_PERM_AABD = 0x07, _MM_PERM_AACA = 0x08,
    _MM_PERM_AACB = 0x09, _MM_PERM_AACC = 0x0A, _MM_PERM_AACD = 0x0B,
    _MM_PERM_AADA = 0x0C, _MM_PERM_AADB = 0x0D, _MM_PERM_AADC = 0x0E,
    _MM_PERM_AADD = 0x0F, _MM_PERM_ABAA = 0x10, _MM_PERM_ABAB = 0x11,
    _MM_PERM_ABAC = 0x12, _MM_PERM_ABAD = 0x13, _MM_PERM_ABBA = 0x14,
    _MM_PERM_ABBB = 0x15, _MM_PERM_ABBC = 0x16, _MM_PERM_ABBD = 0x17,
    _MM_PERM_ABCA = 0x18, _MM_PERM_ABCB = 0x19, _MM_PERM_ABCC = 0x1A,
    _MM_PERM_ABCD = 0x1B, _MM_PERM_ABDA = 0x1C, _MM_PERM_ABDB = 0x1D,
    _MM_PERM_ABDC = 0x1E, _MM_PERM_ABDD = 0x1F, _MM_PERM_ACAA = 0x20,
    _MM_PERM_ACAB = 0x21, _MM_PERM_ACAC = 0x22, _MM_PERM_ACAD = 0x23,
    _MM_PERM_ACBA = 0x24, _MM_PERM_ACBB = 0x25, _MM_PERM_ACBC = 0x26,
    _MM_PERM_ACBD = 0x27, _MM_PERM_ACCA = 0x28, _MM_PERM_ACCB = 0x29,
    _MM_PERM_ACCC = 0x2A, _MM_PERM_ACCD = 0x2B, _MM_PERM_ACDA = 0x2C,
    _MM_PERM_ACDB = 0x2D, _MM_PERM_ACDC = 0x2E, _MM_PERM_ACDD = 0x2F,
    _MM_PERM_ADAA = 0x30, _MM_PERM_ADAB = 0x31, _MM_PERM_ADAC = 0x32,
    _MM_PERM_ADAD = 0x33, _MM_PERM_ADBA = 0x34, _MM_PERM_ADBB = 0x35,
    _MM_PERM_ADBC = 0x36, _MM_PERM_ADBD = 0x37, _MM_PERM_ADCA = 0x38,
    _MM_PERM_ADCB = 0x39, _MM_PERM_ADCC = 0x3A, _MM_PERM_ADCD = 0x3B,
    _MM_PERM_ADDA = 0x3C, _MM_PERM_ADDB = 0x3D, _MM_PERM_ADDC = 0x3E,
    _MM_PERM_ADDD = 0x3F, _MM_PERM_BAAA = 0x40, _MM_PERM_BAAB = 0x41,
    _MM_PERM_BAAC = 0x42, _MM_PERM_BAAD = 0x43, _MM_PERM_BABA = 0x44,
    _MM_PERM_BABB = 0x45, _MM_PERM_BABC = 0x46, _MM_PERM_BABD = 0x47,
    _MM_PERM_BACA = 0x48, _MM_PERM_BACB = 0x49, _MM_PERM_BACC = 0x4A,
    _MM_PERM_BACD = 0x4B, _MM_PERM_BADA = 0x4C, _MM_PERM_BADB = 0x4D,
    _MM_PERM_BADC = 0x4E, _MM_PERM_BADD = 0x4F, _MM_PERM_BBAA = 0x50,
    _MM_PERM_BBAB = 0x51, _MM_PERM_BBAC = 0x52, _MM_PERM_BBAD = 0x53,
    _MM_PERM_BBBA = 0x54, _MM_PERM_BBBB = 0x55, _MM_PERM_BBBC = 0x56,
    _MM_PERM_BBBD = 0x57, _MM_PERM_BBCA = 0x58, _MM_PERM_BBCB = 0x59,
    _MM_PERM_BBCC = 0x5A, _MM_PERM_BBCD = 0x5B, _MM_PERM_BBDA = 0x5C,
    _MM_PERM_BBDB = 0x5D, _MM_PERM_BBDC = 0x5E, _MM_PERM_BBDD = 0x5F,
    _MM_PERM_BCAA = 0x60, _MM_PERM_BCAB = 0x61, _MM_PERM_BCAC = 0x62,
    _MM_PERM_BCAD = 0x63, _MM_PERM_BCBA = 0x64, _MM_PERM_BCBB = 0x65,
    _MM_PERM_BCBC = 0x66, _MM_PERM_BCBD = 0x67, _MM_PERM_BCCA = 0x68,
    _MM_PERM_BCCB = 0x69, _MM_PERM_BCCC = 0x6A, _MM_PERM_BCCD = 0x6B,
    _MM_PERM_BCDA = 0x6C, _MM_PERM_BCDB = 0x6D, _MM_PERM_BCDC = 0x6E,
    _MM_PERM_BCDD = 0x6F, _MM_PERM_BDAA = 0x70, _MM_PERM_BDAB = 0x71,
    _MM_PERM_BDAC = 0x72, _MM_PERM_BDAD = 0x73, _MM_PERM_BDBA = 0x74,
    _MM_PERM_BDBB = 0x75, _MM_PERM_BDBC = 0x76, _MM_PERM_BDBD = 0x77,
    _MM_PERM_BDCA = 0x78, _MM_PERM_BDCB = 0x79, _MM_PERM_BDCC = 0x7A,
    _MM_PERM_BDCD = 0x7B, _MM_PERM_BDDA = 0x7C, _MM_PERM_BDDB = 0x7D,
    _MM_PERM_BDDC = 0x7E, _MM_PERM_BDDD = 0x7F, _MM_PERM_CAAA = 0x80,
    _MM_PERM_CAAB = 0x81, _MM_PERM_CAAC = 0x82, _MM_PERM_CAAD = 0x83,
    _MM_PERM_CABA = 0x84, _MM_PERM_CABB = 0x85, _MM_PERM_CABC = 0x86,
    _MM_PERM_CABD = 0x87, _MM_PERM_CACA = 0x88, _MM_PERM_CACB = 0x89,
    _MM_PERM_CACC = 0x8A, _MM_PERM_CACD = 0x8B, _MM_PERM_CADA = 0x8C,
    _MM_PERM_CADB = 0x8D, _MM_PERM_CADC = 0x8E, _MM_PERM_CADD = 0x8F,
    _MM_PERM_CBAA = 0x90, _MM_PERM_CBAB = 0x91, _MM_PERM_CBAC = 0x92,
    _MM_PERM_CBAD = 0x93, _MM_PERM_CBBA = 0x94, _MM_PERM_CBBB = 0x95,
    _MM_PERM_CBBC = 0x96, _MM_PERM_CBBD = 0x97, _MM_PERM_CBCA = 0x98,
    _MM_PERM_CBCB = 0x99, _MM_PERM_CBCC = 0x9A, _MM_PERM_CBCD = 0x9B,
    _MM_PERM_CBDA = 0x9C, _MM_PERM_CBDB = 0x9D, _MM_PERM_CBDC = 0x9E,
    _MM_PERM_CBDD = 0x9F, _MM_PERM_CCAA = 0xA0, _MM_PERM_CCAB = 0xA1,
    _MM_PERM_CCAC = 0xA2, _MM_PERM_CCAD = 0xA3, _MM_PERM_CCBA = 0xA4,
    _MM_PERM_CCBB = 0xA5, _MM_PERM_CCBC = 0xA6, _MM_PERM_CCBD = 0xA7,
    _MM_PERM_CCCA = 0xA8, _MM_PERM_CCCB = 0xA9, _MM_PERM_CCCC = 0xAA,
    _MM_PERM_CCCD = 0xAB, _MM_PERM_CCDA = 0xAC, _MM_PERM_CCDB = 0xAD,
    _MM_PERM_CCDC = 0xAE, _MM_PERM_CCDD = 0xAF, _MM_PERM_CDAA = 0xB0,
    _MM_PERM_CDAB = 0xB1, _MM_PERM_CDAC = 0xB2, _MM_PERM_CDAD = 0xB3,
    _MM_PERM_CDBA = 0xB4, _MM_PERM_CDBB = 0xB5, _MM_PERM_CDBC = 0xB6,
    _MM_PERM_CDBD = 0xB7, _MM_PERM_CDCA = 0xB8, _MM_PERM_CDCB = 0xB9,
    _MM_PERM_CDCC = 0xBA, _MM_PERM_CDCD = 0xBB, _MM_PERM_CDDA = 0xBC,
    _MM_PERM_CDDB = 0xBD, _MM_PERM_CDDC = 0xBE, _MM_PERM_CDDD = 0xBF,
    _MM_PERM_DAAA = 0xC0, _MM_PERM_DAAB = 0xC1, _MM_PERM_DAAC = 0xC2,
    _MM_PERM_DAAD = 0xC3, _MM_PERM_DABA = 0xC4, _MM_PERM_DABB = 0xC5,
    _MM_PERM_DABC = 0xC6, _MM_PERM_DABD = 0xC7, _MM_PERM_DACA = 0xC8,
    _MM_PERM_DACB = 0xC9, _MM_PERM_DACC = 0xCA, _MM_PERM_DACD = 0xCB,
    _MM_PERM_DADA = 0xCC, _MM_PERM_DADB = 0xCD, _MM_PERM_DADC = 0xCE,
    _MM_PERM_DADD = 0xCF, _MM_PERM_DBAA = 0xD0, _MM_PERM_DBAB = 0xD1,
    _MM_PERM_DBAC = 0xD2, _MM_PERM_DBAD = 0xD3, _MM_PERM_DBBA = 0xD4,
    _MM_PERM_DBBB = 0xD5, _MM_PERM_DBBC = 0xD6, _MM_PERM_DBBD = 0xD7,
    _MM_PERM_DBCA = 0xD8, _MM_PERM_DBCB = 0xD9, _MM_PERM_DBCC = 0xDA,
    _MM_PERM_DBCD = 0xDB, _MM_PERM_DBDA = 0xDC, _MM_PERM_DBDB = 0xDD,
    _MM_PERM_DBDC = 0xDE, _MM_PERM_DBDD = 0xDF, _MM_PERM_DCAA = 0xE0,
    _MM_PERM_DCAB = 0xE1, _MM_PERM_DCAC = 0xE2, _MM_PERM_DCAD = 0xE3,
    _MM_PERM_DCBA = 0xE4, _MM_PERM_DCBB = 0xE5, _MM_PERM_DCBC = 0xE6,
    _MM_PERM_DCBD = 0xE7, _MM_PERM_DCCA = 0xE8, _MM_PERM_DCCB = 0xE9,
    _MM_PERM_DCCC = 0xEA, _MM_PERM_DCCD = 0xEB, _MM_PERM_DCDA = 0xEC,
    _MM_PERM_DCDB = 0xED, _MM_PERM_DCDC = 0xEE, _MM_PERM_DCDD = 0xEF,
    _MM_PERM_DDAA = 0xF0, _MM_PERM_DDAB = 0xF1, _MM_PERM_DDAC = 0xF2,
    _MM_PERM_DDAD = 0xF3, _MM_PERM_DDBA = 0xF4, _MM_PERM_DDBB = 0xF5,
    _MM_PERM_DDBC = 0xF6, _MM_PERM_DDBD = 0xF7, _MM_PERM_DDCA = 0xF8,
    _MM_PERM_DDCB = 0xF9, _MM_PERM_DDCC = 0xFA, _MM_PERM_DDCD = 0xFB,
    _MM_PERM_DDDA = 0xFC, _MM_PERM_DDDB = 0xFD, _MM_PERM_DDDC = 0xFE,
    _MM_PERM_DDDD = 0xFF
} _MM_PERM_ENUM;





typedef enum {
    _MM_FIXUP_NO_CHANGE,
    _MM_FIXUP_NEG_INF,
    _MM_FIXUP_NEG_ZERO,
    _MM_FIXUP_POS_ZERO,
    _MM_FIXUP_POS_INF,
    _MM_FIXUP_NAN,
    _MM_FIXUP_MAX_FLOAT,
    _MM_FIXUP_MIN_FLOAT
} _MM_FIXUPRESULT_ENUM;





















typedef enum {
    _MM_MANT_NORM_1_2,      
    _MM_MANT_NORM_p5_2,     
    _MM_MANT_NORM_p5_1,     
    _MM_MANT_NORM_p75_1p5   
} _MM_MANTISSA_NORM_ENUM;

typedef enum {
    _MM_MANT_SIGN_src,      
    _MM_MANT_SIGN_zero,     
    _MM_MANT_SIGN_nan       
} _MM_MANTISSA_SIGN_ENUM;






typedef enum {
    _MM_CMPINT_EQ,      
    _MM_CMPINT_LT,      
    _MM_CMPINT_LE,      
    _MM_CMPINT_UNUSED,
    _MM_CMPINT_NE,      
    _MM_CMPINT_NLT,     

    _MM_CMPINT_NLE      

} _MM_CMPINT_ENUM;





extern __m512  __cdecl _mm512_setzero_ps(void);
extern __m512d __cdecl _mm512_setzero_pd(void);

extern __m512  __cdecl _mm512_set_ps(float , float, float, float, float, float, float, float, float, float, float, float, float, float, float, float );
extern __m512d __cdecl _mm512_set_pd(double , double, double, double, double, double, double, double );

extern __m512  __cdecl _mm512_setr_ps(float , float, float, float, float, float, float, float, float, float, float, float, float, float, float, float );
extern __m512d __cdecl _mm512_setr_pd(double , double, double, double, double, double, double, double );

extern __m512  __cdecl _mm512_set1_ps(float);
extern __m512d __cdecl _mm512_set1_pd(double);

extern __m512  __cdecl _mm512_load_ps(void const*);
extern __m512d __cdecl _mm512_load_pd(void const*);
extern __m512  __cdecl _mm512_maskz_load_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_load_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_load_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_load_pd(__m512d, __mmask8, void const*);
extern __m512  __cdecl _mm512_loadu_ps(void const*);
extern __m512d __cdecl _mm512_loadu_pd(void const*);
extern __m512  __cdecl _mm512_maskz_loadu_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_loadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_loadu_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_loadu_pd(__m512d, __mmask8, void const*);

extern void    __cdecl _mm512_store_ps(void*, __m512);
extern void    __cdecl _mm512_store_pd(void*, __m512d);
extern void    __cdecl _mm512_storeu_ps(void*, __m512);
extern void    __cdecl _mm512_storeu_pd(void*, __m512d);
extern void    __cdecl _mm512_mask_store_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_store_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_storeu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_storeu_pd(void*, __mmask8, __m512d);

extern __m512  __cdecl _mm512_add_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_add_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_add_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_add_round_ps(__m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_add_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_add_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_add_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_add_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_add_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_add_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_add_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_add_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_sub_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_sub_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_sub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_sub_round_ps(__m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_sub_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_sub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_sub_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_sub_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_sub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_sub_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_sub_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_sub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_mul_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_mul_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_mul_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mul_round_ps( __m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_mul_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_mul_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mul_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_mul_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_mul_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mul_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_mul_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_mul_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_div_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_div_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_div_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_div_round_ps(__m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_div_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_div_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_div_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_div_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_div_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_div_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_div_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_div_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmadd_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmadd_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmsub_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmsub_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmaddsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmaddsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmaddsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmaddsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmaddsub_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmaddsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmaddsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmaddsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmaddsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmaddsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmaddsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmaddsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmaddsub_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmaddsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmaddsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmaddsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmsubadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmsubadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmsubadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmsubadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmsubadd_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmsubadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmsubadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmsubadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmsubadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmsubadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmsubadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmsubadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmsubadd_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmsubadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmsubadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmsubadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fnmadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fnmadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fnmadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fnmadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fnmadd_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fnmadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fnmadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fnmadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fnmadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fnmadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fnmadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fnmadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fnmadd_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fnmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fnmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fnmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fnmsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fnmsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fnmsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fnmsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fnmsub_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fnmsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fnmsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fnmsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fnmsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fnmsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fnmsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fnmsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fnmsub_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fnmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fnmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fnmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_sqrt_ps(__m512);
extern __m512d __cdecl _mm512_sqrt_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_sqrt_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_sqrt_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_sqrt_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_sqrt_pd(__m512d, __mmask8, __m512d);
extern __m512  __cdecl _mm512_sqrt_round_ps(__m512, const int );
extern __m512d __cdecl _mm512_sqrt_round_pd(__m512d, const int );
extern __m512  __cdecl _mm512_maskz_sqrt_round_ps(__mmask16, __m512, const int );
extern __m512d __cdecl _mm512_maskz_sqrt_round_pd(__mmask8, __m512d, const int );
extern __m512  __cdecl _mm512_mask_sqrt_round_ps(__m512, __mmask16, __m512, const int );
extern __m512d __cdecl _mm512_mask_sqrt_round_pd(__m512d, __mmask8, __m512d, const int );

extern __m512  __cdecl _mm512_abs_ps(__m512);
extern __m512  __cdecl _mm512_maskz_abs_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_mask_abs_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_abs_pd(__m512d);
extern __m512d __cdecl _mm512_maskz_abs_pd(__mmask8, __m512d);
extern __m512d __cdecl _mm512_mask_abs_pd(__m512d, __mmask8, __m512d);

extern __m512  __cdecl _mm512_max_ps(__m512, __m512);
extern __m512d __cdecl _mm512_max_pd(__m512d, __m512d);
extern __m512  __cdecl _mm512_maskz_max_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_maskz_max_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_max_ps(__m512, __mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_max_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_max_round_ps(__m512, __m512, const int );
extern __m512d __cdecl _mm512_max_round_pd(__m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_max_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_max_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_max_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_max_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_min_ps(__m512, __m512);
extern __m512d __cdecl _mm512_min_pd(__m512d, __m512d);
extern __m512  __cdecl _mm512_maskz_min_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_maskz_min_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_min_ps(__m512, __mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_min_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_min_round_ps(__m512, __m512, const int );
extern __m512d __cdecl _mm512_min_round_pd(__m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_min_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_min_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_min_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_min_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_rcp14_ps(__m512);
extern __m512d __cdecl _mm512_rcp14_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_rcp14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rcp14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rcp14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rcp14_pd(__m512d, __mmask8, __m512d);

extern __m512  __cdecl _mm512_rsqrt14_ps(__m512);
extern __m512d __cdecl _mm512_rsqrt14_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_rsqrt14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rsqrt14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rsqrt14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rsqrt14_pd(__m512d, __mmask8, __m512d);

extern __m512d __cdecl _mm512_cvtps_pd(__m256);
extern __m256  __cdecl _mm512_cvtpd_ps(__m512d);
extern __m512d __cdecl _mm512_maskz_cvtps_pd(__mmask8, __m256);
extern __m256  __cdecl _mm512_maskz_cvtpd_ps(__mmask8, __m512d);
extern __m512d __cdecl _mm512_mask_cvtps_pd(__m512d, __mmask8, __m256);
extern __m256  __cdecl _mm512_mask_cvtpd_ps(__m256, __mmask8, __m512d);
extern __m512d __cdecl _mm512_cvt_roundps_pd(__m256, const int );
extern __m256  __cdecl _mm512_cvt_roundpd_ps(__m512d, const int );
extern __m512d __cdecl _mm512_maskz_cvt_roundps_pd(__mmask8, __m256, const int );
extern __m256  __cdecl _mm512_maskz_cvt_roundpd_ps(__mmask8, __m512d, const int );
extern __m512d __cdecl _mm512_mask_cvt_roundps_pd(__m512d, __mmask8, __m256, const int );
extern __m256  __cdecl _mm512_mask_cvt_roundpd_ps(__m256, __mmask8, __m512d, const int );

extern __mmask16 __cdecl _mm512_cmp_ps_mask(__m512, __m512, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_ps_mask(__mmask16, __m512, __m512, const int);
extern __mmask16 __cdecl _mm512_cmp_round_ps_mask(__m512, __m512, const int, const int );
extern __mmask16 __cdecl _mm512_mask_cmp_round_ps_mask(__mmask16, __m512, __m512, const int, const int );
extern __mmask8  __cdecl _mm512_cmp_pd_mask(__m512d, __m512d, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_pd_mask(__mmask8, __m512d, __m512d, const int);
extern __mmask8  __cdecl _mm512_cmp_round_pd_mask(__m512d, __m512d, const int, const int );
extern __mmask8  __cdecl _mm512_mask_cmp_round_pd_mask(__mmask8, __m512d, __m512d, const int, const int );

extern __m512  __cdecl _mm512_broadcast_f32x2(__m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x2(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x2(__mmask16, __m128);
extern __m512  __cdecl _mm512_broadcast_f32x4(__m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x4(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x4(__mmask16, __m128);
extern __m512  __cdecl _mm512_broadcast_f32x8(__m256);
extern __m512  __cdecl _mm512_mask_broadcast_f32x8(__m512, __mmask16, __m256);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x8(__mmask16, __m256);
extern __m512d __cdecl _mm512_broadcast_f64x2(__m128d);
extern __m512d __cdecl _mm512_mask_broadcast_f64x2(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m512d __cdecl _mm512_broadcast_f64x4(__m256d);
extern __m512d __cdecl _mm512_mask_broadcast_f64x4(__m512d, __mmask8, __m256d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x4(__mmask8, __m256d);
extern __m512d __cdecl _mm512_broadcastsd_pd(__m128d);
extern __m512d __cdecl _mm512_mask_broadcastsd_pd(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m512  __cdecl _mm512_broadcastss_ps(__m128);
extern __m512  __cdecl _mm512_mask_broadcastss_ps(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcastss_ps(__mmask16, __m128);

extern __m128  __cdecl _mm512_extractf32x4_ps(__m512, int);
extern __m128  __cdecl _mm512_mask_extractf32x4_ps(__m128, __mmask8, __m512, const int);
extern __m128  __cdecl _mm512_maskz_extractf32x4_ps(__mmask8, __m512, int);
extern __m256  __cdecl _mm512_extractf32x8_ps(__m512, int);
extern __m256  __cdecl _mm512_mask_extractf32x8_ps(__m256, __mmask8, __m512, const int);
extern __m256  __cdecl _mm512_maskz_extractf32x8_ps(__mmask8, __m512, int);
extern __m128d __cdecl _mm512_extractf64x2_pd(__m512d, int);
extern __m128d __cdecl _mm512_mask_extractf64x2_pd(__m128d, __mmask8, __m512d, const int);
extern __m128d __cdecl _mm512_maskz_extractf64x2_pd(__mmask8, __m512d, int);
extern __m256d __cdecl _mm512_extractf64x4_pd(__m512d, int);
extern __m256d __cdecl _mm512_mask_extractf64x4_pd(__m256d, __mmask8, __m512d, const int);
extern __m256d __cdecl _mm512_maskz_extractf64x4_pd(__mmask8, __m512d, int);

extern __m512  __cdecl _mm512_insertf32x4(__m512, __m128, int);
extern __m512  __cdecl _mm512_mask_insertf32x4(__m512, __mmask16, __m512, __m128, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x4(__mmask16, __m512, __m128, int);
extern __m512  __cdecl _mm512_insertf32x8(__m512, __m256, int);
extern __m512  __cdecl _mm512_mask_insertf32x8(__m512, __mmask16, __m512, __m256, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x8(__mmask16, __m512, __m256, int);
extern __m512d __cdecl _mm512_insertf64x2(__m512d, __m128d, int);
extern __m512d __cdecl _mm512_mask_insertf64x2(__m512d, __mmask8, __m512d, __m128d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x2(__mmask8, __m512d, __m128d, int);
extern __m512d __cdecl _mm512_insertf64x4(__m512d, __m256d, int);
extern __m512d __cdecl _mm512_mask_insertf64x4(__m512d, __mmask8, __m512d, __m256d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x4(__mmask8, __m512d, __m256d, int);

extern __m512  __cdecl _mm512_shuffle_f32x4(__m512, __m512, const int);
extern __m512  __cdecl _mm512_mask_shuffle_f32x4(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_f32x4(__mmask16, __m512, __m512, const int);
extern __m512d __cdecl _mm512_shuffle_f64x2(__m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_shuffle_f64x2(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_f64x2(__mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_shuffle_pd(__m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_shuffle_pd(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_pd(__mmask8, __m512d, __m512d, const int);
extern __m512  __cdecl _mm512_shuffle_ps(__m512, __m512, const int);
extern __m512  __cdecl _mm512_mask_shuffle_ps(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_ps(__mmask16, __m512, __m512, const int);

extern __mmask16 _mm512_cmpeq_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmple_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmplt_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpneq_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpnle_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpnlt_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpord_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpunord_ps_mask(__m512, __m512);

extern __mmask16 _mm512_mask_cmpeq_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmple_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmplt_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpneq_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpnle_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpnlt_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpord_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpunord_ps_mask(__mmask16, __m512, __m512);

extern __mmask8 _mm512_cmpeq_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmple_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmplt_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpneq_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpnle_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpnlt_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpord_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpunord_pd_mask(__m512d, __m512d);

extern __mmask8 _mm512_mask_cmpeq_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmple_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmplt_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpneq_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpnle_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpnlt_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpord_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpunord_pd_mask(__mmask8, __m512d, __m512d);





































extern __m512i __cdecl _mm512_setzero_si512(void);

extern __m512i __cdecl _mm512_set_epi8(char , char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char );
extern __m512i __cdecl _mm512_set_epi16(short , short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short );
extern __m512i __cdecl _mm512_set_epi32(int , int, int, int, int, int, int, int, int, int, int, int, int, int, int, int );
extern __m512i __cdecl _mm512_set_epi64(__int64 , __int64, __int64, __int64, __int64, __int64, __int64, __int64 );

extern __m512i __cdecl _mm512_setr_epi8(char , char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char );
extern __m512i __cdecl _mm512_setr_epi16(short , short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short );
extern __m512i __cdecl _mm512_setr_epi32(int , int, int, int, int, int, int, int, int, int, int, int, int, int, int, int );
extern __m512i __cdecl _mm512_setr_epi64(__int64 , __int64, __int64, __int64, __int64, __int64, __int64, __int64 );

extern __m512i __cdecl _mm512_set1_epi8(char);
extern __m512i __cdecl _mm512_mask_set1_epi8(__m512i, __mmask64, char);
extern __m512i __cdecl _mm512_maskz_set1_epi8(__mmask64, char);
extern __m512i __cdecl _mm512_set1_epi16(short);
extern __m512i __cdecl _mm512_mask_set1_epi16(__m512i, __mmask32, short);
extern __m512i __cdecl _mm512_maskz_set1_epi16(__mmask32, short);
extern __m512i __cdecl _mm512_set1_epi32(int);
extern __m512i __cdecl _mm512_mask_set1_epi32(__m512i, __mmask16, int);
extern __m512i __cdecl _mm512_maskz_set1_epi32(__mmask16, int);
extern __m512i __cdecl _mm512_set1_epi64(__int64);
extern __m512i __cdecl _mm512_mask_set1_epi64(__m512i, __mmask8, __int64);
extern __m512i __cdecl _mm512_maskz_set1_epi64(__mmask8, __int64);

extern __m512i __cdecl _mm512_add_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_abs_epi8(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_abs_epi16(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_abs_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_abs_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi64(__mmask8, __m512i);

extern __m512i  __cdecl _mm512_broadcast_i32x2(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x2(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x2(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i32x4(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x4(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x4(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i32x8(__m256i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x8(__m512i, __mmask16, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x8(__mmask16, __m256i);
extern __m512i  __cdecl _mm512_broadcast_i64x2(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x2(__m512i, __mmask8, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i64x4(__m256i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x4(__m512i, __mmask8, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x4(__mmask8, __m256i);
extern __m512i __cdecl _mm512_broadcastb_epi8(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastb_epi8(__m512i, __mmask64, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastb_epi8(__mmask64, __m128i);
extern __m512i __cdecl _mm512_broadcastw_epi16(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastw_epi16(__m512i, __mmask32, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastw_epi16(__mmask32, __m128i);
extern __m512i __cdecl _mm512_broadcastd_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastd_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastd_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_broadcastq_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastq_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_broadcastmw_epi32(__mmask16);
extern __m512i __cdecl _mm512_broadcastmb_epi64(__mmask8);

extern __m512i __cdecl _mm512_sub_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_max_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_min_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_mul_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epi32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epi32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mul_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epu32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epu32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhi_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhi_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullox_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullox_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhrs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhrs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhrs_epi16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_load_epi32(void const*);
extern __m512i __cdecl _mm512_mask_load_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_load_epi64(void const*);
extern __m512i __cdecl _mm512_mask_load_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi64(__mmask8, void const*);
extern __m512i __cdecl _mm512_loadu_epi8(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi8(__m512i, __mmask64, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi8(__mmask64, void const*);
extern __m512i __cdecl _mm512_loadu_epi16(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi16(__m512i, __mmask32, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi16(__mmask32, void const*);
extern __m512i __cdecl _mm512_loadu_epi32(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_loadu_epi64(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi64(__mmask8, void const*);

extern void    __cdecl _mm512_store_epi32(void*, __m512i);
extern void    __cdecl _mm512_mask_store_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_store_epi64(void*, __m512i);
extern void    __cdecl _mm512_mask_store_epi64(void*, __mmask8, __m512i);
extern void    __cdecl _mm512_storeu_epi8(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_storeu_epi16(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_storeu_epi32(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_storeu_epi64(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi64(void*, __mmask8, __m512i);

extern __m128i __cdecl _mm512_extracti32x4_epi32(__m512i, int);
extern __m128i __cdecl _mm512_mask_extracti32x4_epi32(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti32x4_epi32(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_extracti32x8_epi32(__m512i, int);
extern __m256i __cdecl _mm512_mask_extracti32x8_epi32(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti32x8_epi32(__mmask8, __m512i, int);
extern __m128i __cdecl _mm512_extracti64x2_epi64(__m512i, int);
extern __m128i __cdecl _mm512_mask_extracti64x2_epi64(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti64x2_epi64(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_extracti64x4_epi64(__m512i, int);
extern __m256i __cdecl _mm512_mask_extracti64x4_epi64(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti64x4_epi64(__mmask8, __m512i, int);

extern __m512i __cdecl _mm512_inserti32x4(__m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti32x4(__m512i, __mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x4(__mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_inserti32x8(__m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_inserti32x8(__m512i, __mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x8(__mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_inserti64x2(__m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti64x2(__m512i, __mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x2(__mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_inserti64x4(__m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_inserti64x4(__m512i, __mmask8, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x4(__mmask8, __m512i, __m256i, int);

extern __m512i __cdecl _mm512_shuffle_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shuffle_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shuffle_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_shuffle_epi32(__m512i, int);
extern __m512i __cdecl _mm512_mask_shuffle_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shuffle_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_shuffle_i32x4(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shuffle_i32x4(__m512i, __mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i32x4(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_shuffle_i64x2(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shuffle_i64x2(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i64x2(__mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_shufflehi_epi16(__m512i, int);
extern __m512i __cdecl _mm512_mask_shufflehi_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflehi_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_shufflelo_epi16(__m512i, int);
extern __m512i __cdecl _mm512_mask_shufflelo_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflelo_epi16(__mmask32, __m512i, int);

extern __m512  __cdecl _mm512_mask_mov_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_mov_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_mask_mov_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_mov_pd(__mmask8, __m512d);
extern __m512i __cdecl _mm512_mask_mov_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_movedup_pd(__m512d);
extern __m512d __cdecl _mm512_mask_movedup_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_movedup_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_movehdup_ps(__m512);
extern __m512  __cdecl _mm512_mask_movehdup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_movehdup_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_moveldup_ps(__m512);
extern __m512  __cdecl _mm512_mask_moveldup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_moveldup_ps(__mmask16, __m512);

extern __m512i __cdecl _mm512_movm_epi8(__mmask64);
extern __m512i __cdecl _mm512_movm_epi16(__mmask32);
extern __m512i __cdecl _mm512_movm_epi32(__mmask16);
extern __m512i __cdecl _mm512_movm_epi64(__mmask8);
extern __mmask64 __cdecl _mm512_movepi8_mask(__m512i);
extern __mmask32 __cdecl _mm512_movepi16_mask(__m512i);
extern __mmask16 __cdecl _mm512_movepi32_mask(__m512i);
extern __mmask8  __cdecl _mm512_movepi64_mask(__m512i);

extern __m512i __cdecl _mm512_alignr_epi8(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi8(__m512i, __mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi8(__mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_alignr_epi32(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi32(__m512i, __mmask16, __m512i, __m512i, const int );
extern __m512i __cdecl _mm512_maskz_alignr_epi32(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_alignr_epi64(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi64(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi64(__mmask8, __m512i, __m512i, const int);

extern __m512d __cdecl _mm512_and_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_and_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_and_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_and_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_and_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_and_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_and_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_and_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_and_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_and_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_andnot_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_andnot_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_andnot_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_andnot_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_andnot_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_andnot_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_andnot_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_andnot_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_andnot_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_andnot_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_or_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_or_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_or_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_or_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_or_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_or_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_or_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_or_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_or_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_or_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_xor_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_xor_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_xor_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_xor_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_xor_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_xor_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_xor_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_xor_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_xor_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_xor_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi64(__mmask8, __m512i, __m512i);

extern __m512  __cdecl _mm512_mask_blend_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_blend_pd(__mmask8, __m512d, __m512d);
extern __m512i __cdecl _mm512_mask_blend_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_sll_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_sll_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_sll_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_slli_epi16(__m512i, unsigned int);
extern __m512i __cdecl _mm512_slli_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_slli_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_sllv_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_sllv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_sllv_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_sll_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_slli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_sllv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_srl_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_srl_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_srl_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_srli_epi16(__m512i, int);
extern __m512i __cdecl _mm512_srli_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srli_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srlv_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_srlv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_srlv_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_srl_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_mask_srli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srlv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_sra_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_sra_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_sra_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_srai_epi16(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srai_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srai_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srav_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_srav_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_srav_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_sra_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srai_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srav_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_bslli_epi128(__m512i, int);
extern __m512i __cdecl _mm512_bsrli_epi128(__m512i, int);

extern __m512i __cdecl _mm512_rol_epi32(__m512i, const int);
extern __m512i __cdecl _mm512_mask_rol_epi32(__m512i, __mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi32(__mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_rol_epi64(__m512i, const int);
extern __m512i __cdecl _mm512_mask_rol_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi64(__mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_rolv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rolv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_rolv_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rolv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_ror_epi32(__m512i, int);
extern __m512i __cdecl _mm512_mask_ror_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_ror_epi64(__m512i, int);
extern __m512i __cdecl _mm512_mask_ror_epi64(__m512i, __mmask8, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi64(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_rorv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rorv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_rorv_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rorv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_unpackhi_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_unpackhi_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpackhi_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_unpackhi_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_unpackhi_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpackhi_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_unpacklo_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_unpacklo_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpacklo_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_unpacklo_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_unpacklo_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpacklo_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_unpackhi_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi64(__mmask8, __m512i, __m512i);

extern __m512  __cdecl _mm512_getexp_ps(__m512);
extern __m512  __cdecl _mm512_mask_getexp_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_getexp_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_getexp_round_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_getexp_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_getexp_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_getexp_pd(__m512d);
extern __m512d __cdecl _mm512_mask_getexp_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_getexp_pd(__mmask8, __m512d);
extern __m512d __cdecl _mm512_getexp_round_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_getexp_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_getexp_round_pd(__mmask8, __m512d, int);

extern __m512  __cdecl _mm512_getmant_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_getmant_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_getmant_ps(__mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_getmant_round_ps(__m512, int, int, int);
extern __m512  __cdecl _mm512_mask_getmant_round_ps(__m512, __mmask16, __m512, int, int, int);
extern __m512  __cdecl _mm512_maskz_getmant_round_ps(__mmask16, __m512, int, int, int);
extern __m512d __cdecl _mm512_getmant_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_getmant_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_getmant_pd(__mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_getmant_round_pd(__m512d, int, int, int);
extern __m512d __cdecl _mm512_mask_getmant_round_pd(__m512d, __mmask8, __m512d, int, int, int);
extern __m512d __cdecl _mm512_maskz_getmant_round_pd(__mmask8, __m512d, int, int, int);

extern __m512d __cdecl _mm512_permute_pd(__m512d, const int);
extern __m512d __cdecl _mm512_mask_permute_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permute_pd(__mmask8, __m512d, const int);
extern __m512  __cdecl _mm512_permute_ps(__m512, const int);
extern __m512  __cdecl _mm512_mask_permute_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_permute_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_permutevar_pd(__m512d, __m512i);
extern __m512d __cdecl _mm512_mask_permutevar_pd(__m512d, __mmask8, __m512d, __m512i);
extern __m512d __cdecl _mm512_maskz_permutevar_pd(__mmask8, __m512d, __m512i);
extern __m512  __cdecl _mm512_permutevar_ps(__m512, __m512i);
extern __m512  __cdecl _mm512_mask_permutevar_ps(__m512, __mmask16, __m512, __m512i);
extern __m512  __cdecl _mm512_maskz_permutevar_ps(__mmask16, __m512, __m512i);
extern __m512i __cdecl _mm512_permutevar_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutevar_epi32(__m512i, __mmask16, __m512i, __m512i);

extern __m512d __cdecl _mm512_permutex_pd(__m512d, const int);
extern __m512d __cdecl _mm512_mask_permutex_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permutex_pd(__mmask8, __m512d, const int);
extern __m512i __cdecl _mm512_permutex_epi64(__m512i, const int);
extern __m512i __cdecl _mm512_mask_permutex_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_permutex_epi64(__mmask8, __m512i, const int);
extern __m512d __cdecl _mm512_permutexvar_pd(__m512i, __m512d);
extern __m512d __cdecl _mm512_mask_permutexvar_pd(__m512d, __mmask8, __m512i, __m512d);
extern __m512d __cdecl _mm512_maskz_permutexvar_pd(__mmask8, __m512i, __m512d);
extern __m512  __cdecl _mm512_permutexvar_ps(__m512i, __m512);
extern __m512  __cdecl _mm512_mask_permutexvar_ps(__m512, __mmask16, __m512i, __m512);
extern __m512  __cdecl _mm512_maskz_permutexvar_ps(__mmask16, __m512i, __m512);
extern __m512i __cdecl _mm512_permutexvar_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_permutexvar_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_permutexvar_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_permutex2var_pd(__m512d, __m512i , __m512d);
extern __m512d __cdecl _mm512_mask_permutex2var_pd(__m512d, __mmask8, __m512i , __m512d);
extern __m512d __cdecl _mm512_mask2_permutex2var_pd(__m512d, __m512i , __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_permutex2var_pd(__mmask8, __m512d, __m512i , __m512d);
extern __m512  __cdecl _mm512_permutex2var_ps(__m512, __m512i , __m512);
extern __m512  __cdecl _mm512_mask_permutex2var_ps(__m512, __mmask16, __m512i , __m512);
extern __m512  __cdecl _mm512_mask2_permutex2var_ps(__m512, __m512i , __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_permutex2var_ps(__mmask16, __m512, __m512i , __m512);
extern __m512i __cdecl _mm512_permutex2var_epi16(__m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi16(__m512i, __mmask32, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi16(__m512i, __m512i , __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi16(__mmask32, __m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_permutex2var_epi32(__m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi32(__m512i, __mmask16, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi32(__m512i, __m512i , __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi32(__mmask16, __m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_permutex2var_epi64(__m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi64(__m512i, __mmask8, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi64(__m512i, __m512i , __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi64(__mmask8, __m512i, __m512i , __m512i);

extern __m512d __cdecl _mm512_mask_compress_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_compress_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_compress_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_compress_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_compress_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi64(__mmask8, __m512i);

extern void    __cdecl _mm512_mask_compressstoreu_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_compressstoreu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_compressstoreu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi64(void*, __mmask8, __m512i);

extern __m512d __cdecl _mm512_mask_expand_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_expand_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_expand_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_expand_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_expand_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_expandloadu_pd(__m512d, __mmask8, void const*);
extern __m512d __cdecl _mm512_maskz_expandloadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_expandloadu_ps(__m512, __mmask16, void const*);
extern __m512  __cdecl _mm512_maskz_expandloadu_ps(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi8(__m512i, __mmask64, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi8(__mmask64, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi16(__m512i, __mmask32, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi16(__mmask32, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi64(__mmask8, void const*);

extern __m512i __cdecl _mm512_ternarylogic_epi32(__m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi32(__mmask16, __m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_ternarylogic_epi64(__m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi64(__mmask8, __m512i, __m512i, __m512i, int);

extern __m512i __cdecl _mm512_conflict_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_conflict_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_conflict_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_conflict_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi64(__mmask8, __m512i);

extern __m512i __cdecl _mm512_lzcnt_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_lzcnt_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi64(__mmask8, __m512i);

extern __m512i __cdecl _mm512_avg_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_avg_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_sad_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_dbsad_epu8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_dbsad_epu8(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_dbsad_epu8(__mmask32, __m512i, __m512i, int);

extern float   __cdecl _mm512_reduce_add_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_add_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_add_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_add_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_add_epi8(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi8(__mmask64, __m512i);
extern int     __cdecl _mm512_reduce_add_epi16(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi16(__mmask32, __m512i);
extern int     __cdecl _mm512_reduce_add_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_add_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_add_epi64(__mmask8, __m512i);
extern int     __cdecl _mm512_reduce_add_epu8(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epu8(__mmask64, __m512i);
extern int     __cdecl _mm512_reduce_add_epu16(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epu16(__mmask32, __m512i);

extern float   __cdecl _mm512_reduce_mul_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_mul_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_mul_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_mul_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_mul_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_mul_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_mul_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_mul_epi64(__mmask8, __m512i);

extern float   __cdecl _mm512_reduce_min_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_min_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_min_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_min_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_min_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_min_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_min_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_min_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_min_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_min_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_min_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_min_epu64(__mmask8, __m512i);

extern float   __cdecl _mm512_reduce_max_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_max_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_max_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_max_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_max_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_max_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_max_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_max_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_max_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_max_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_max_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_max_epu64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_and_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_and_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_and_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_and_epi64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_or_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_or_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_or_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_or_epi64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_xor_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_xor_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_xor_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_xor_epi64(__mmask8, __m512i);

extern __m512d __cdecl _mm512_reduce_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_reduce_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_reduce_pd(__mmask8, __m512d, int);
extern __m512d __cdecl _mm512_reduce_round_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_reduce_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_reduce_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_reduce_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_reduce_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_reduce_ps(__mmask16, __m512, int);
extern __m512  __cdecl _mm512_reduce_round_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_reduce_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_reduce_round_ps(__mmask16, __m512, int, int);

extern __m512d __cdecl _mm512_roundscale_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_roundscale_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_roundscale_pd(__mmask8, __m512d, int);
extern __m512d __cdecl _mm512_roundscale_round_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_roundscale_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_roundscale_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_roundscale_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_roundscale_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_roundscale_ps(__mmask16, __m512, int);
extern __m512  __cdecl _mm512_roundscale_round_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_roundscale_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_roundscale_round_ps(__mmask16, __m512, int, int);

extern __m512d __cdecl _mm512_scalef_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_scalef_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_scalef_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_scalef_round_pd(__m512d, __m512d, int);
extern __m512d __cdecl _mm512_mask_scalef_round_pd(__m512d, __mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_maskz_scalef_round_pd(__mmask8, __m512d, __m512d, int);
extern __m512  __cdecl _mm512_scalef_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_scalef_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_scalef_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_scalef_round_ps(__m512, __m512, int);
extern __m512  __cdecl _mm512_mask_scalef_round_ps(__m512, __mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_maskz_scalef_round_ps(__mmask16, __m512, __m512, int);

extern __m512d __cdecl _mm512_fixupimm_pd(__m512d, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_mask_fixupimm_pd(__m512d, __mmask8, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_maskz_fixupimm_pd(__mmask8, __m512d, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_fixupimm_round_pd(__m512d, __m512d, __m512i, const int, const int);
extern __m512d __cdecl _mm512_mask_fixupimm_round_pd(__m512d, __mmask8, __m512d, __m512i, const int, const int);
extern __m512d __cdecl _mm512_maskz_fixupimm_round_pd(__mmask8, __m512d, __m512d, __m512i, const int, const int);
extern __m512  __cdecl _mm512_fixupimm_ps(__m512, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_mask_fixupimm_ps(__m512, __mmask16, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_maskz_fixupimm_ps(__mmask16, __m512, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_fixupimm_round_ps(__m512, __m512, __m512i, const int, const int);
extern __m512  __cdecl _mm512_mask_fixupimm_round_ps(__m512, __mmask16, __m512, __m512i, const int, const int);
extern __m512  __cdecl _mm512_maskz_fixupimm_round_ps(__mmask16, __m512, __m512, __m512i, const int, const int);

extern void    __cdecl _mm512_stream_pd(void*, __m512d);
extern void    __cdecl _mm512_stream_ps(void*, __m512);
extern void    __cdecl _mm512_stream_si512(void*, __m512i);
extern __m512i __cdecl _mm512_stream_load_si512(void const*);

extern __m128d __cdecl _mm512_castpd512_pd128(__m512d);
extern __m128  __cdecl _mm512_castps512_ps128(__m512);
extern __m128i __cdecl _mm512_castsi512_si128(__m512i);
extern __m512i __cdecl _mm512_castsi128_si512(__m128i);

extern __mmask16 __cdecl _mm512_fpclass_ps_mask(__m512, int);
extern __mmask16 __cdecl _mm512_mask_fpclass_ps_mask(__mmask16, __m512, int);
extern __mmask8  __cdecl _mm512_fpclass_pd_mask(__m512d, int);
extern __mmask8  __cdecl _mm512_mask_fpclass_pd_mask(__mmask8, __m512d, int);

extern __m512d __cdecl _mm512_range_pd(__m512d, __m512d, int);
extern __m512d __cdecl _mm512_mask_range_pd(__m512d, __mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_maskz_range_pd(__mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_range_round_pd(__m512d, __m512d, int, int);
extern __m512d __cdecl _mm512_mask_range_round_pd(__m512d, __mmask8, __m512d, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_range_round_pd(__mmask8, __m512d, __m512d, int, int);
extern __m512  __cdecl _mm512_range_ps(__m512, __m512, int);
extern __m512  __cdecl _mm512_mask_range_ps(__m512, __mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_maskz_range_ps(__mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_range_round_ps(__m512, __m512, int, int);
extern __m512  __cdecl _mm512_mask_range_round_ps(__m512, __mmask16, __m512, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_range_round_ps(__mmask16, __m512, __m512, int, int);

extern __m512i __cdecl _mm512_madd_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd_epi16(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd_epi16(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maddubs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_maddubs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_maddubs_epi16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_packs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_packs_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi32(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_packus_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_packus_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi32(__mmask32, __m512i, __m512i);

extern __mmask64 __cdecl _mm512_cmp_epi8_mask(__m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_cmp_epi8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_cmp_epi16_mask(__m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epi16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_cmp_epi32_mask(__m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epi32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_cmp_epi64_mask(__m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epi64_mask(__mmask8, __m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_cmp_epu8_mask(__m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_cmp_epu8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_cmp_epu16_mask(__m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epu16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_cmp_epu32_mask(__m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epu32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_cmp_epu64_mask(__m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epu64_mask(__mmask8, __m512i, __m512i, const int);

extern __mmask64 __cdecl _mm512_test_epi8_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_test_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_test_epi16_mask(__m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_test_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask64 __cdecl _mm512_testn_epi8_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_testn_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_testn_epi16_mask(__m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_testn_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_test_epi32_mask(__m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_test_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_test_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_test_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_testn_epi32_mask(__m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_testn_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_testn_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_testn_epi64_mask(__mmask8, __m512i, __m512i);

extern __mmask16 __cdecl _mm512_kunpackb(__mmask16, __mmask16);
extern __mmask32 __cdecl _mm512_kunpackw(__mmask32, __mmask32);
extern __mmask64 __cdecl _mm512_kunpackd(__mmask64, __mmask64);

extern unsigned char __cdecl _mm512_testz_and_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_and_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_and_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_and_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_andn_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_andn_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_andn_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_andn_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_or_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_or_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_or_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_or_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_nor_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_nor_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_nor_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_nor_mask64(__mmask64, __mmask64);

extern __m512  __cdecl _mm512_i32gather_ps(__m512i, void const*, int);
extern __m512  __cdecl _mm512_mask_i32gather_ps(__m512, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_ps(void*, __m512i, __m512, int);
extern void    __cdecl _mm512_mask_i32scatter_ps(void*, __mmask16, __m512i, __m512, int);
extern __m512d __cdecl _mm512_i64gather_pd(__m512i, void const*, int);
extern __m512d __cdecl _mm512_mask_i64gather_pd(__m512d, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_pd(void*, __m512i, __m512d, int);
extern void    __cdecl _mm512_mask_i64scatter_pd(void*, __mmask8, __m512i, __m512d, int);
extern __m512d __cdecl _mm512_i32gather_pd(__m256i, void const*, int);
extern __m512d __cdecl _mm512_mask_i32gather_pd(__m512d, __mmask8, __m256i, void const*, int);
extern void    __cdecl _mm512_i32scatter_pd(void*, __m256i, __m512d, int);
extern void    __cdecl _mm512_mask_i32scatter_pd(void*, __mmask8, __m256i, __m512d, int);
extern __m512i __cdecl _mm512_i32gather_epi32(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi32(__m512i, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi32(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi32(void*, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_i32gather_epi64(__m256i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi64(__m512i, __mmask8, __m256i, void const*, int);
extern __m512i __cdecl _mm512_i64gather_epi64(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i64gather_epi64(__m512i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi64(void*, __m256i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi64(void*, __mmask8, __m256i, __m512i, int);
extern void    __cdecl _mm512_i64scatter_epi64(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi64(void*, __mmask8, __m512i, __m512i, int);
extern __m256  __cdecl _mm512_i64gather_ps(__m512i, void const*, int);
extern __m256  __cdecl _mm512_mask_i64gather_ps(__m256, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_ps(void*, __m512i, __m256, int);
extern void    __cdecl _mm512_mask_i64scatter_ps(void*, __mmask8, __m512i, __m256, int);
extern __m256i __cdecl _mm512_i64gather_epi32(__m512i, void const*, int);
extern __m256i __cdecl _mm512_mask_i64gather_epi32(__m256i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_epi32(void*, __m512i, __m256i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi32(void*, __mmask8, __m512i, __m256i, int);

extern __m512d __cdecl _mm512_cvtpslo_pd(__m512);
extern __m512d __cdecl _mm512_mask_cvtpslo_pd(__m512d, __mmask8, __m512);
extern __m512d __cdecl _mm512_cvtepi32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepi32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_cvtepu32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepu32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_cvtepi32_pd(__m256i);
extern __m512d __cdecl _mm512_mask_cvtepi32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepi32_pd(__mmask8, __m256i);
extern __m512d __cdecl _mm512_cvtepu32_pd(__m256i);
extern __m512d __cdecl _mm512_mask_cvtepu32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepu32_pd(__mmask8, __m256i);

extern __m512  __cdecl _mm512_cvtepi32_ps( __m512i);
extern __m512  __cdecl _mm512_mask_cvtepi32_ps(__m512, __mmask16, __m512i);
extern __m512  __cdecl _mm512_maskz_cvtepi32_ps(__mmask16, __m512i);
extern __m512  __cdecl _mm512_cvt_roundepi32_ps(__m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundepi32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepi32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_cvtepu32_ps( __m512i);
extern __m512  __cdecl _mm512_mask_cvtepu32_ps(__m512, __mmask16, __m512i);
extern __m512  __cdecl _mm512_maskz_cvtepu32_ps(__mmask16, __m512i);
extern __m512  __cdecl _mm512_cvt_roundepu32_ps(__m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundepu32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepu32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_cvtph_ps(__m256i);
extern __m512  __cdecl _mm512_mask_cvtph_ps(__m512, __mmask16, __m256i);
extern __m512  __cdecl _mm512_maskz_cvtph_ps(__mmask16, __m256i);
extern __m512  __cdecl _mm512_cvt_roundph_ps(__m256i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundph_ps(__m512, __mmask16, __m256i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundph_ps(__mmask16, __m256i, int);
extern __m256i __cdecl _mm512_cvtps_ph(__m512, int);
extern __m256i __cdecl _mm512_mask_cvtps_ph(__m256i, __mmask16, __m512, int);
extern __m256i __cdecl _mm512_maskz_cvtps_ph(__mmask16, __m512, int);
extern __m256i __cdecl _mm512_cvt_roundps_ph(__m512, int);
extern __m256i __cdecl _mm512_mask_cvt_roundps_ph(__m256i, __mmask16, __m512, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundps_ph(__mmask16, __m512, int);
extern __m256  __cdecl _mm512_cvtepi64_ps(__m512i);
extern __m256  __cdecl _mm512_mask_cvtepi64_ps(__m256, __mmask8, __m512i);
extern __m256  __cdecl _mm512_maskz_cvtepi64_ps(__mmask8, __m512i);
extern __m256  __cdecl _mm512_cvt_roundepi64_ps(__m512i, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepi64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepi64_ps(__mmask8, __m512i, int);
extern __m256  __cdecl _mm512_cvtepu64_ps(__m512i);
extern __m256  __cdecl _mm512_mask_cvtepu64_ps(__m256, __mmask8, __m512i);
extern __m256  __cdecl _mm512_maskz_cvtepu64_ps(__mmask8, __m512i);
extern __m256  __cdecl _mm512_cvt_roundepu64_ps(__m512i, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepu64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepu64_ps(__mmask8, __m512i, int);

extern __m512i __cdecl _mm512_cvtepi8_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_cvtepi8_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepi16_epi32(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_cvtepi16_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i __cdecl _mm512_cvtepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_cvtsepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_cvtusepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtsepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtusepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m512i __cdecl _mm512_cvtepi32_epi64(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi32_epi64(__mmask8, __m256i);
extern __m128i __cdecl _mm512_cvtepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtsepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtusepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtsepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtusepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtsepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtusepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m512i __cdecl _mm512_cvtepu8_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_cvtepu8_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepu16_epi32(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_cvtepu16_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepu32_epi64(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu32_epi64(__mmask8, __m256i);

extern __m512i __cdecl _mm512_cvtps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_cvtps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvtps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvt_roundps_epi32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvttps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_cvttps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvttps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvtt_roundps_epi32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvtps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_cvtps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvtps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvt_roundps_epu32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvttps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_cvttps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvttps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvtt_roundps_epu32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu32(__mmask16, __m512, int);
extern __m256i __cdecl _mm512_cvtpd_epi32(__m512d);
extern __m256i __cdecl _mm512_mask_cvtpd_epi32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvtpd_epi32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvt_roundpd_epi32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvttpd_epi32(__m512d);
extern __m256i __cdecl _mm512_mask_cvttpd_epi32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvttpd_epi32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvtt_roundpd_epi32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvtpd_epu32(__m512d);
extern __m256i __cdecl _mm512_mask_cvtpd_epu32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvtpd_epu32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvt_roundpd_epu32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epu32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvttpd_epu32(__m512d);
extern __m256i __cdecl _mm512_mask_cvttpd_epu32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvttpd_epu32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvtt_roundpd_epu32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epu32(__mmask8, __m512d, int);

extern __m512i __cdecl _mm512_cvtepi8_epi16(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi16(__mmask32, __m256i);
extern __m512i __cdecl _mm512_cvtepu8_epi16(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi16(__mmask32, __m256i);
extern __m256i __cdecl _mm512_cvtepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_cvtsepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_cvtusepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi16_storeu_epi8(void*, __mmask32, __m512i);

extern __m512d __cdecl _mm512_cvtepi64_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepi64_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_maskz_cvtepi64_pd(__mmask8, __m512i);
extern __m512d __cdecl _mm512_cvt_roundepi64_pd(__m512i, int);
extern __m512d __cdecl _mm512_mask_cvt_roundepi64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepi64_pd(__mmask8, __m512i, int);
extern __m512d __cdecl _mm512_cvtepu64_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepu64_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_maskz_cvtepu64_pd(__mmask8, __m512i);
extern __m512d __cdecl _mm512_cvt_roundepu64_pd(__m512i, int);
extern __m512d __cdecl _mm512_mask_cvt_roundepu64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepu64_pd(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_cvtpd_epi64(__m512d);
extern __m512i __cdecl _mm512_mask_cvtpd_epi64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvtpd_epi64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvt_roundpd_epi64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvtpd_epu64(__m512d);
extern __m512i __cdecl _mm512_mask_cvtpd_epu64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvtpd_epu64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvt_roundpd_epu64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvttpd_epi64(__m512d);
extern __m512i __cdecl _mm512_mask_cvttpd_epi64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvttpd_epi64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtt_roundpd_epi64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvttpd_epu64(__m512d);
extern __m512i __cdecl _mm512_mask_cvttpd_epu64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvttpd_epu64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtt_roundpd_epu64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvtps_epi64(__m256);
extern __m512i __cdecl _mm512_mask_cvtps_epi64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvtps_epi64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvt_roundps_epi64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvtps_epu64(__m256);
extern __m512i __cdecl _mm512_mask_cvtps_epu64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvtps_epu64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvt_roundps_epu64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvttps_epi64(__m256);
extern __m512i __cdecl _mm512_mask_cvttps_epi64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvttps_epi64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvtt_roundps_epi64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvttps_epu64(__m256);
extern __m512i __cdecl _mm512_mask_cvttps_epu64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvttps_epu64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvtt_roundps_epu64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu64(__mmask8, __m256, int);

extern __mmask64  __cdecl _mm512_cmpeq_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpge_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpgt_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmple_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmplt_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpneq_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpeq_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpge_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpgt_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmple_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmplt_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpneq_epu8_mask(__m512i, __m512i);

extern __mmask64  __cdecl _mm512_mask_cmpeq_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpge_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpgt_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmple_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmplt_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpneq_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpeq_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpge_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpgt_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmple_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmplt_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpneq_epu8_mask(__mmask64, __m512i, __m512i);

extern __mmask32  __cdecl _mm512_cmpeq_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpge_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpgt_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmple_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmplt_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpneq_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpeq_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpge_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpgt_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmple_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmplt_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpneq_epu16_mask(__m512i, __m512i);

extern __mmask32  __cdecl _mm512_mask_cmpeq_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpge_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpgt_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmple_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmplt_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpneq_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpeq_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpge_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpgt_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmple_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmplt_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpneq_epu16_mask(__mmask32, __m512i, __m512i);

extern __mmask16  __cdecl _mm512_cmpeq_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpge_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpgt_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmple_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmplt_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpneq_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpeq_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpge_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpgt_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmple_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmplt_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpneq_epu32_mask(__m512i, __m512i);

extern __mmask16  __cdecl _mm512_mask_cmpeq_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpge_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpgt_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmple_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmplt_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpneq_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpeq_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpge_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpgt_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmple_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmplt_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpneq_epu32_mask(__mmask16, __m512i, __m512i);

extern __mmask8  __cdecl _mm512_cmpeq_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpge_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpgt_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmple_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmplt_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpneq_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpeq_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpge_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpgt_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmple_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmplt_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpneq_epu64_mask(__m512i, __m512i);

extern __mmask8  __cdecl _mm512_mask_cmpeq_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpge_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpgt_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmple_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmplt_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpneq_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpeq_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpge_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpgt_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmple_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmplt_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpneq_epu64_mask(__mmask8, __m512i, __m512i);































































extern __m128i   __cdecl _mm_mask_abs_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_abs_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_abs_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_abs_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_abs_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_add_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_add_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_add_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_add_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_add_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_add_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_adds_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_alignr_epi32(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi32(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi32(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi32(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi32(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi32(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_alignr_epi64(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi64(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi64(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi64(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi64(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi64(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi8(__m128i, __mmask16, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi8(__mmask16, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi8(__m256i, __mmask32, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi8(__mmask32, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_and_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_and_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_and_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_and_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_and_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_and_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_and_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_and_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_and_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_and_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_and_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_and_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_and_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_and_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_and_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_and_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_andnot_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_andnot_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_andnot_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_andnot_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_andnot_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_andnot_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_andnot_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_andnot_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_andnot_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_andnot_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_andnot_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_andnot_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_andnot_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_andnot_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_andnot_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_andnot_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_avg_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_avg_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_blend_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_blend_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_blend_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_blend_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_broadcast_f32x2(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x2(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x2(__mmask8, __m128);
extern __m256    __cdecl _mm256_broadcast_f32x4(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x4(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x4(__mmask8, __m128);
extern __m256d   __cdecl _mm256_broadcast_f64x2(__m128d);
extern __m256d   __cdecl _mm256_mask_broadcast_f64x2(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m128i   __cdecl _mm_broadcast_i32x2(__m128i);
extern __m128i   __cdecl _mm_mask_broadcast_i32x2(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x4(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x4(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x4(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i64x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i64x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastb_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastb_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastb_epi8(__m256i, __mmask32, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastb_epi8(__mmask32, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastd_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastd_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_broadcastmb_epi64(__mmask8);
extern __m256i   __cdecl _mm256_broadcastmb_epi64(__mmask8);
extern __m128i   __cdecl _mm_broadcastmw_epi32(__mmask16);
extern __m256i   __cdecl _mm256_broadcastmw_epi32(__mmask16);
extern __m128i   __cdecl _mm_mask_broadcastq_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastq_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_broadcastsd_pd(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m128    __cdecl _mm_mask_broadcastss_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_broadcastss_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_broadcastss_ps(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcastss_ps(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_broadcastw_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastw_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastw_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastw_epi16(__mmask16, __m128i);
extern __mmask8  __cdecl _mm_cmp_epi16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epi16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epi16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epi16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epi32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epi64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epi8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epi8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epi8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epi8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epu16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epu16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epu16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epu64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epu8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epu8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epu8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epu8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_pd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_pd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm256_cmp_pd_mask(__m256d, __m256d, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_pd_mask(__mmask8, __m256d, __m256d, const int);
extern __mmask8  __cdecl _mm_cmp_ps_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ps_mask(__mmask8, __m128, __m128, const int);
extern __mmask8  __cdecl _mm256_cmp_ps_mask(__m256, __m256, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_ps_mask(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_compress_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_compress_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_compress_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_compress_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_compress_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_compress_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_compress_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_compress_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_compress_ps(__mmask8, __m256);
extern void      __cdecl _mm_mask_compressstoreu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_compressstoreu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_compressstoreu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_compressstoreu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_conflict_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_conflict_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtps_ph(__m128i, __mmask8, __m128, int);
extern __m128i   __cdecl _mm_maskz_cvtps_ph(__mmask8, __m128, int);
extern __m128i   __cdecl _mm_mask_cvt_roundps_ph(__m128i, __mmask8, __m128, int);
extern __m128i   __cdecl _mm_maskz_cvt_roundps_ph(__mmask8, __m128, int);
extern __m128i   __cdecl _mm256_mask_cvtps_ph(__m128i, __mmask8, __m256, int);
extern __m128i   __cdecl _mm256_maskz_cvtps_ph(__mmask8, __m256, int);
extern __m128i   __cdecl _mm256_mask_cvt_roundps_ph(__m128i, __mmask8, __m256, int);
extern __m128i   __cdecl _mm256_maskz_cvt_roundps_ph(__mmask8, __m256, int);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_cvtepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_cvtepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_cvtepi32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_cvtepi32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m128    __cdecl _mm_mask_cvtepi32_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi32_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtepi32_ps(__m256, __mmask8, __m256i);
extern __m256    __cdecl _mm256_maskz_cvtepi32_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_cvtepi64_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepi64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepi64_pd(__m256i);
extern __m256d   __cdecl _mm256_mask_cvtepi64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepi64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_cvtepi64_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepi64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_cvtepi64_ps(__m256i);
extern __m128    __cdecl _mm256_mask_cvtepi64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepi64_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m128    __cdecl _mm_cvtepu32_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepu32_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepu32_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_cvtepu32_ps(__m256i);
extern __m256    __cdecl _mm256_mask_cvtepu32_ps(__m256, __mmask8, __m256i);
extern __m256    __cdecl _mm256_maskz_cvtepu32_ps(__mmask8, __m256i);
extern __m128d   __cdecl _mm_cvtepu32_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepu32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepu32_pd(__m128i);
extern __m256d   __cdecl _mm256_mask_cvtepu32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m128d   __cdecl _mm_cvtepu64_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepu64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepu64_pd(__m256i);
extern __m256d   __cdecl _mm256_mask_cvtepu64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepu64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_cvtepu64_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepu64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepu64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_cvtepu64_ps(__m256i);
extern __m128    __cdecl _mm256_mask_cvtepu64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepu64_ps(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epi64(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvtpd_epi64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epu32(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_cvtpd_epu32(__m256d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epu64(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvtpd_epu64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epu64(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtpd_ps(__m128, __mmask8, __m128d);
extern __m128    __cdecl _mm_maskz_cvtpd_ps(__mmask8, __m128d);
extern __m128    __cdecl _mm256_mask_cvtpd_ps(__m128, __mmask8, __m256d);
extern __m128    __cdecl _mm256_maskz_cvtpd_ps(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtph_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtph_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtph_ps(__m256, __mmask8, __m128i);
extern __m256    __cdecl _mm256_maskz_cvtph_ps(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvtps_epi64(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epi64(__m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtps_epu32(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epu32(__m256);
extern __m256i   __cdecl _mm256_mask_cvtps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvtps_epu64(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epu64(__m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu64(__mmask8, __m128);
extern __m128d   __cdecl _mm_mask_cvtps_pd(__m128d, __mmask8, __m128);
extern __m128d   __cdecl _mm_maskz_cvtps_pd(__mmask8, __m128);
extern __m256d   __cdecl _mm256_mask_cvtps_pd(__m256d, __mmask8, __m128);
extern __m256d   __cdecl _mm256_maskz_cvtps_pd(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtsepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtsepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtsepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvttpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epi64(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvttpd_epi64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epu32(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_cvttpd_epu32(__m256d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epu64(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvttpd_epu64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epu64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvttps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvttps_epi64(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epi64(__m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvttps_epu32(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epu32(__m256);
extern __m256i   __cdecl _mm256_mask_cvttps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvttps_epu64(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epu64(__m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtusepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtusepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtusepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_dbsad_epu8(__m128i, __m128i, int);
extern __m128i   __cdecl _mm_mask_dbsad_epu8(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_dbsad_epu8(__mmask8, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_dbsad_epu8(__m256i, __m256i, int);
extern __m256i   __cdecl _mm256_mask_dbsad_epu8(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_dbsad_epu8(__mmask16, __m256i, __m256i, int);
extern __m128d   __cdecl _mm_mask_div_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_div_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_div_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_div_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_div_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_div_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_expand_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_expand_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_expand_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_expand_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_expand_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_expand_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_expand_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_expand_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_expand_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_expandloadu_epi8(__m128i, __mmask16, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi8(__mmask16, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi8(__m256i, __mmask32, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi8(__mmask32, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi16(__m128i, __mmask8, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi16(__mmask8, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi16(__m256i, __mmask16, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi16(__mmask16, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_expandloadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_expandloadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_expandloadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_expandloadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_expandloadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_expandloadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_expandloadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_expandloadu_ps(__mmask8, void const*);
extern __m128    __cdecl _mm256_extractf32x4_ps(__m256, int);
extern __m128    __cdecl _mm256_mask_extractf32x4_ps(__m128, __mmask8, __m256, int);
extern __m128    __cdecl _mm256_maskz_extractf32x4_ps(__mmask8, __m256, int);
extern __m128d   __cdecl _mm256_extractf64x2_pd(__m256d, int);
extern __m128d   __cdecl _mm256_mask_extractf64x2_pd(__m128d, __mmask8, __m256d, int);
extern __m128d   __cdecl _mm256_maskz_extractf64x2_pd(__mmask8, __m256d, int);
extern __m128i   __cdecl _mm256_extracti32x4_epi32(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti32x4_epi32(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti32x4_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_extracti64x2_epi64(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti64x2_epi64(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti64x2_epi64(__mmask8, __m256i, int);
extern __m128d   __cdecl _mm_fixupimm_pd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_pd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_pd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m256d   __cdecl _mm256_fixupimm_pd(__m256d, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_mask_fixupimm_pd(__m256d, __mmask8, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_maskz_fixupimm_pd(__mmask8, __m256d, __m256d, __m256i, const int);
extern __m128    __cdecl _mm_fixupimm_ps(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ps(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ps(__mmask8, __m128, __m128, __m128i, const int);
extern __m256    __cdecl _mm256_fixupimm_ps(__m256, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_mask_fixupimm_ps(__m256, __mmask8, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_maskz_fixupimm_ps(__mmask8, __m256, __m256, __m256i, const int);
extern __m128d   __cdecl _mm_mask_fmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmaddsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmaddsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmaddsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmaddsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmaddsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmaddsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmaddsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmaddsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmaddsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmaddsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmaddsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmaddsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsubadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsubadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsubadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsubadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsubadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsubadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsubadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsubadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsubadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsubadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsubadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsubadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmsub_ps(__mmask8, __m256, __m256, __m256);
extern __mmask8  __cdecl _mm_fpclass_pd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_pd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm256_fpclass_pd_mask(__m256d, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_pd_mask(__mmask8, __m256d, int);
extern __mmask8  __cdecl _mm_fpclass_ps_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ps_mask(__mmask8, __m128, int);
extern __mmask8  __cdecl _mm256_fpclass_ps_mask(__m256, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_ps_mask(__mmask8, __m256, int);
extern __m128d   __cdecl _mm_getexp_pd(__m128d);
extern __m128d   __cdecl _mm_mask_getexp_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_getexp_pd(__m256d);
extern __m256d   __cdecl _mm256_mask_getexp_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_getexp_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_getexp_ps(__m128);
extern __m128    __cdecl _mm_mask_getexp_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_getexp_ps(__m256);
extern __m256    __cdecl _mm256_mask_getexp_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_getexp_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_getmant_pd(__m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_pd(__m128d, __mmask8, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_pd(__mmask8, __m128d, int, int);
extern __m256d   __cdecl _mm256_getmant_pd(__m256d, int, int);
extern __m256d   __cdecl _mm256_mask_getmant_pd(__m256d, __mmask8, __m256d, int, int);
extern __m256d   __cdecl _mm256_maskz_getmant_pd(__mmask8, __m256d, int, int);
extern __m128    __cdecl _mm_getmant_ps(__m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ps(__m128, __mmask8, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ps(__mmask8, __m128, int, int);
extern __m256    __cdecl _mm256_getmant_ps(__m256, int, int);
extern __m256    __cdecl _mm256_mask_getmant_ps(__m256, __mmask8, __m256, int, int);
extern __m256    __cdecl _mm256_maskz_getmant_ps(__mmask8, __m256, int, int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi32(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi64(__m256i, __mmask8, __m128i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i32gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i32gather_pd(__m256d, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i32gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m256    __cdecl _mm256_mmask_i32gather_ps(__m256, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i32scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi32(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi32(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi64(void*, __m128i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i32scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i32scatter_pd(void*, __m128i, __m256d, const int);
extern void      __cdecl _mm256_mask_i32scatter_pd(void*, __mmask8, __m128i, __m256d, const int);
extern void      __cdecl _mm_i32scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i32scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i32scatter_ps(void*, __m256i, __m256, const int);
extern void      __cdecl _mm256_mask_i32scatter_ps(void*, __mmask8, __m256i, __m256, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m128i   __cdecl _mm256_mmask_i64gather_epi32(__m128i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i64gather_epi64(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i64gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i64gather_pd(__m256d, __mmask8, __m256i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i64gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm256_mmask_i64gather_ps(__m128, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i64scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi32(void*, __m256i, __m128i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi32(void*, __mmask8, __m256i, __m128i, const int);
extern void      __cdecl _mm_i64scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi64(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi64(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i64scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i64scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i64scatter_pd(void*, __m256i, __m256d, const int);
extern void      __cdecl _mm256_mask_i64scatter_pd(void*, __mmask8, __m256i, __m256d, const int);
extern void      __cdecl _mm_i64scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i64scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i64scatter_ps(void*, __m256i, __m128, const int);
extern void      __cdecl _mm256_mask_i64scatter_ps(void*, __mmask8, __m256i, __m128, const int);
extern __m256    __cdecl _mm256_insertf32x4(__m256, __m128, int);
extern __m256    __cdecl _mm256_mask_insertf32x4(__m256, __mmask8, __m256, __m128, int);
extern __m256    __cdecl _mm256_maskz_insertf32x4(__mmask8, __m256, __m128, int);
extern __m256d   __cdecl _mm256_insertf64x2(__m256d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_insertf64x2(__m256d, __mmask8, __m256d, __m128d, int);
extern __m256d   __cdecl _mm256_maskz_insertf64x2(__mmask8, __m256d, __m128d, int);
extern __m256i   __cdecl _mm256_inserti32x4(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti32x4(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti32x4(__mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_inserti64x2(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti64x2(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti64x2(__mmask8, __m256i, __m128i, int);
extern __m128i   __cdecl _mm_mask_load_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_load_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_load_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_load_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_load_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_load_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_load_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_load_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_load_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_load_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi16(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi16(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi16(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi16(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi16(__m256i, __mmask16, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi16(__mmask16, void const*);
extern __m128i   __cdecl _mm_loadu_epi32(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi32(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi64(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi64(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi64(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi8(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi8(__m128i, __mmask16, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi8(__mmask16, void const*);
extern __m256i   __cdecl _mm256_loadu_epi8(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi8(__m256i, __mmask32, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi8(__mmask32, void const*);
extern __m128d   __cdecl _mm_mask_loadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_loadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_loadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_loadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_loadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_loadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_loadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_loadu_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_lzcnt_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_lzcnt_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_madd_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_madd_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_madd_epi16(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_madd_epi16(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_maddubs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_maddubs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_maddubs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_maddubs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_max_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_max_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_max_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_max_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_max_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_max_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_min_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_min_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_min_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_min_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_min_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_min_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_min_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mov_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi8(__mmask32, __m256i);
extern __m128d   __cdecl _mm_mask_mov_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_mov_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_mov_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_mov_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_mov_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_mov_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_mov_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_mov_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_movedup_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_movedup_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_movedup_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_movedup_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_movehdup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_movehdup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_movehdup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_movehdup_ps(__mmask8, __m256);
extern __m128    __cdecl _mm_mask_moveldup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_moveldup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_moveldup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_moveldup_ps(__mmask8, __m256);
extern __mmask8  __cdecl _mm_movepi16_mask(__m128i);
extern __mmask16 __cdecl _mm256_movepi16_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi32_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi32_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi64_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi64_mask(__m256i);
extern __mmask16 __cdecl _mm_movepi8_mask(__m128i);
extern __mmask32 __cdecl _mm256_movepi8_mask(__m256i);
extern __m128i   __cdecl _mm_movm_epi16(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi16(__mmask16);
extern __m128i   __cdecl _mm_movm_epi32(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi32(__mmask8);
extern __m128i   __cdecl _mm_movm_epi64(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi64(__mmask8);
extern __m128i   __cdecl _mm_movm_epi8(__mmask16);
extern __m256i   __cdecl _mm256_movm_epi8(__mmask32);
extern __m128i   __cdecl _mm_mask_mul_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mul_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epu32(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_mul_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_mul_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_mul_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_mul_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_mul_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_mul_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mulhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhi_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhrs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhrs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhrs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhrs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mullo_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mullo_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_or_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_or_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_or_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_or_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_or_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_or_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_or_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_or_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_or_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_or_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_or_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_or_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_or_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_or_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_or_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_or_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_packs_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packs_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi32(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi32(__mmask16, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permute_pd(__m128d, __mmask8, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_permute_pd(__mmask8, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_permute_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permute_pd(__mmask8, __m256d, const int);
extern __m128    __cdecl _mm_mask_permute_ps(__m128, __mmask8, __m128, const int);
extern __m128    __cdecl _mm_maskz_permute_ps(__mmask8, __m128, const int);
extern __m256    __cdecl _mm256_mask_permute_ps(__m256, __mmask8, __m256, const int);
extern __m256    __cdecl _mm256_maskz_permute_ps(__mmask8, __m256, const int);
extern __m128d   __cdecl _mm_mask_permutevar_pd(__m128d, __mmask8, __m128d, __m128i);
extern __m128d   __cdecl _mm_maskz_permutevar_pd(__mmask8, __m128d, __m128i);
extern __m256d   __cdecl _mm256_mask_permutevar_pd(__m256d, __mmask8, __m256d, __m256i);
extern __m256d   __cdecl _mm256_maskz_permutevar_pd(__mmask8, __m256d, __m256i);
extern __m128    __cdecl _mm_mask_permutevar_ps(__m128, __mmask8, __m128, __m128i);
extern __m128    __cdecl _mm_maskz_permutevar_ps(__mmask8, __m128, __m128i);
extern __m256    __cdecl _mm256_mask_permutevar_ps(__m256, __mmask8, __m256, __m256i);
extern __m256    __cdecl _mm256_maskz_permutevar_ps(__mmask8, __m256, __m256i);
extern __m256i   __cdecl _mm256_mask_permutex_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_permutex_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_permutex_epi64(__m256i, const int);
extern __m256d   __cdecl _mm256_mask_permutex_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permutex_pd(__mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_permutex_pd(__m256d, const int);
extern __m128i   __cdecl _mm_mask_permutex2var_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi16(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi16(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi16(__m256i, __m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi16(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi32(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi32(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi32(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi32(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi64(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi64(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi64(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi64(__m256i, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permutex2var_pd(__m128d, __mmask8, __m128i, __m128d);
extern __m128d   __cdecl _mm_mask2_permutex2var_pd(__m128d, __m128i, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_permutex2var_pd(__mmask8, __m128d, __m128i, __m128d);
extern __m128d   __cdecl _mm_permutex2var_pd(__m128d, __m128i, __m128d);
extern __m256d   __cdecl _mm256_mask_permutex2var_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_mask2_permutex2var_pd(__m256d, __m256i, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutex2var_pd(__mmask8, __m256d, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutex2var_pd(__m256d, __m256i, __m256d);
extern __m128    __cdecl _mm_mask_permutex2var_ps(__m128, __mmask8, __m128i, __m128);
extern __m128    __cdecl _mm_mask2_permutex2var_ps(__m128, __m128i, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_permutex2var_ps(__mmask8, __m128, __m128i, __m128);
extern __m128    __cdecl _mm_permutex2var_ps(__m128, __m128i, __m128);
extern __m256    __cdecl _mm256_mask_permutex2var_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_mask2_permutex2var_ps(__m256, __m256i, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_permutex2var_ps(__mmask8, __m256, __m256i, __m256);
extern __m256    __cdecl _mm256_permutex2var_ps(__m256, __m256i, __m256);
extern __m128i   __cdecl _mm_mask_permutexvar_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_permutexvar_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutexvar_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi16(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi64(__m256i, __m256i);
extern __m256d   __cdecl _mm256_mask_permutexvar_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutexvar_pd(__mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutexvar_pd(__m256i, __m256d);
extern __m256    __cdecl _mm256_mask_permutexvar_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_maskz_permutexvar_ps(__mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_permutexvar_ps(__m256i, __m256);
extern __m128d   __cdecl _mm_mask_range_pd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_range_pd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_range_pd(__m128d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_range_pd(__m256d, __mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_range_pd(__mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_range_pd(__m256d, __m256d, int);
extern __m128    __cdecl _mm_mask_range_ps(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_range_ps(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_range_ps(__m128, __m128, int);
extern __m256    __cdecl _mm256_mask_range_ps(__m256, __mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_maskz_range_ps(__mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_range_ps(__m256, __m256, int);
extern __m128d   __cdecl _mm_mask_rcp14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_pd(__mmask8, __m128d);
extern __m128d   __cdecl _mm_rcp14_pd(__m128d);
extern __m256d   __cdecl _mm256_mask_rcp14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rcp14_pd(__mmask8, __m256d);
extern __m256d   __cdecl _mm256_rcp14_pd(__m256d);
extern __m128    __cdecl _mm_mask_rcp14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ps(__mmask8, __m128);
extern __m128    __cdecl _mm_rcp14_ps(__m128);
extern __m256    __cdecl _mm256_mask_rcp14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rcp14_ps(__mmask8, __m256);
extern __m256    __cdecl _mm256_rcp14_ps(__m256);
extern __m128d   __cdecl _mm_mask_reduce_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_reduce_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_reduce_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_reduce_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_reduce_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_reduce_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_reduce_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_reduce_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_reduce_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_reduce_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_reduce_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_reduce_ps(__m256, int);
extern __m128i   __cdecl _mm_mask_rol_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi32(__m128i, int);
extern __m256i   __cdecl _mm256_mask_rol_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rol_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_rol_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rolv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rolv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ror_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi32(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_ror_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rorv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rorv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi64(__m256i, __m256i);
extern __m128d   __cdecl _mm_mask_roundscale_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_roundscale_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_roundscale_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_roundscale_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_roundscale_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_roundscale_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_roundscale_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_roundscale_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_roundscale_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_roundscale_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_roundscale_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_roundscale_ps(__m256, int);
extern __m128d   __cdecl _mm_mask_rsqrt14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_rsqrt14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rsqrt14_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_rsqrt14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_rsqrt14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rsqrt14_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_scalef_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_pd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_pd(__m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_scalef_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_scalef_pd(__mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_scalef_pd(__m256d, __m256d);
extern __m128    __cdecl _mm_mask_scalef_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ps(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ps(__m128, __m128);
extern __m256    __cdecl _mm256_mask_scalef_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_scalef_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_scalef_ps(__m256, __m256);
extern __m128i   __cdecl _mm_mask_set1_epi16(__m128i, __mmask8, short);
extern __m128i   __cdecl _mm_maskz_set1_epi16(__mmask8, short);
extern __m256i   __cdecl _mm256_mask_set1_epi16(__m256i, __mmask16, short);
extern __m256i   __cdecl _mm256_maskz_set1_epi16(__mmask16, short);
extern __m128i   __cdecl _mm_mask_set1_epi32(__m128i, __mmask8, int);
extern __m128i   __cdecl _mm_maskz_set1_epi32(__mmask8, int);
extern __m256i   __cdecl _mm256_mask_set1_epi32(__m256i, __mmask8, int);
extern __m256i   __cdecl _mm256_maskz_set1_epi32(__mmask8, int);
extern __m128i   __cdecl _mm_mask_set1_epi64(__m128i, __mmask8, __int64);
extern __m128i   __cdecl _mm_maskz_set1_epi64(__mmask8, __int64);
extern __m256i   __cdecl _mm256_mask_set1_epi64(__m256i, __mmask8, __int64);
extern __m256i   __cdecl _mm256_maskz_set1_epi64(__mmask8, __int64);
extern __m128i   __cdecl _mm_mask_set1_epi8(__m128i, __mmask16, char);
extern __m128i   __cdecl _mm_maskz_set1_epi8(__mmask16, char);
extern __m256i   __cdecl _mm256_mask_set1_epi8(__m256i, __mmask32, char);
extern __m256i   __cdecl _mm256_maskz_set1_epi8(__mmask32, char);
extern __m128i   __cdecl _mm_mask_shuffle_epi32(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shuffle_epi32(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shuffle_epi32(__m256i, __mmask8, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm_mask_shuffle_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_shuffle_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_shuffle_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi8(__mmask32, __m256i, __m256i);
extern __m256    __cdecl _mm256_mask_shuffle_f32x4(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_f32x4(__mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_shuffle_f32x4(__m256, __m256, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_f64x2(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_f64x2(__mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_shuffle_f64x2(__m256d, __m256d, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i32x4(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i32x4(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i32x4(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i64x2(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i64x2(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i64x2(__m256i, __m256i, const int);
extern __m128d   __cdecl _mm_mask_shuffle_pd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_shuffle_pd(__mmask8, __m128d, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_pd(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_pd(__mmask8, __m256d, __m256d, const int);
extern __m128    __cdecl _mm_mask_shuffle_ps(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_shuffle_ps(__mmask8, __m128, __m128, const int);
extern __m256    __cdecl _mm256_mask_shuffle_ps(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_ps(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_shufflehi_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflehi_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflehi_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflehi_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_shufflelo_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflelo_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflelo_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflelo_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_sll_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_slli_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_sllv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sllv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_sllv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sqrt_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_sqrt_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_sqrt_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_sqrt_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_sqrt_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_sqrt_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sra_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sra_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi64(__mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_sra_epi64(__m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srai_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi64(__mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_srai_epi64(__m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi64(__mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_srai_epi64(__m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srav_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srl_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srli_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_srli_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_srli_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_srli_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_srli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srlv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srlv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srlv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi64(__mmask8, __m256i, __m256i);
extern void      __cdecl _mm_mask_store_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_store_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_store_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_store_ps(void*, __mmask8, __m256);
extern void      __cdecl _mm_storeu_epi16(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi16(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_storeu_epi32(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi32(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_storeu_epi64(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi64(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_storeu_epi8(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi8(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_storeu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_storeu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_storeu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_storeu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sub_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_sub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_sub_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_sub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_sub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_sub_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_subs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi32(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi32(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi32(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi32(__m256i, __m256i, __m256i, int);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi64(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi64(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi64(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi64(__m256i, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_mask_test_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_test_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_test_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_test_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_test_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_test_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_test_epi8_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_testn_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_testn_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_testn_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_testn_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_testn_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_testn_epi8_mask(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpackhi_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpackhi_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpackhi_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpackhi_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpackhi_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpackhi_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpackhi_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpackhi_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_unpacklo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpacklo_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpacklo_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpacklo_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpacklo_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpacklo_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpacklo_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpacklo_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpacklo_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_xor_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_xor_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_xor_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_xor_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_xor_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_xor_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_xor_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_xor_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_xor_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_xor_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_xor_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_xor_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_xor_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_xor_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_xor_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_xor_ps(__mmask8, __m256, __m256);

extern __mmask16  __cdecl _mm_cmpeq_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpge_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpgt_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmple_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmplt_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpneq_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpeq_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpge_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpgt_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmple_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmplt_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpneq_epu8_mask(__m128i, __m128i);

extern __mmask16  __cdecl _mm_mask_cmpeq_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpge_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpgt_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmple_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmplt_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpneq_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpeq_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpge_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpgt_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmple_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmplt_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpneq_epu8_mask(__mmask16, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu16_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu16_mask(__mmask8, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu32_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu32_mask(__mmask8, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu64_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu64_mask(__mmask8, __m128i, __m128i);

extern __mmask32  __cdecl _mm256_cmpeq_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpge_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpgt_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmple_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmplt_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpneq_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpeq_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpge_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpgt_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmple_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmplt_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpneq_epu8_mask(__m256i, __m256i);

extern __mmask32  __cdecl _mm256_mask_cmpeq_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpge_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpgt_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmple_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmplt_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpneq_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpeq_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpge_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpgt_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmple_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmplt_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpneq_epu8_mask(__mmask32, __m256i, __m256i);

extern __mmask16  __cdecl _mm256_cmpeq_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpge_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpgt_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmple_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmplt_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpneq_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpeq_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpge_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpgt_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmple_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmplt_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpneq_epu16_mask(__m256i, __m256i);

extern __mmask16  __cdecl _mm256_mask_cmpeq_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpge_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpgt_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmple_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmplt_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpneq_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpeq_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpge_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpgt_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmple_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmplt_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpneq_epu16_mask(__mmask16, __m256i, __m256i);

extern __mmask8  __cdecl _mm256_cmpeq_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpeq_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epu32_mask(__m256i, __m256i);

extern __mmask8  __cdecl _mm256_mask_cmpeq_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpeq_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epu32_mask(__mmask8, __m256i, __m256i);

extern __mmask8  __cdecl _mm256_cmpeq_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpeq_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epu64_mask(__m256i, __m256i);

extern __mmask8  __cdecl _mm256_mask_cmpeq_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpeq_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epu64_mask(__mmask8, __m256i, __m256i);


extern __m128d   __cdecl _mm_add_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_add_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_add_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_add_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_add_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_add_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_add_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_add_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ss(__mmask8, __m128, __m128);
extern __mmask8  __cdecl _mm_cmp_round_sd_mask(__m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_sd_mask(__mmask8, __m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_cmp_round_ss_mask(__m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_ss_mask(__mmask8, __m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_cmp_sd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_sd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_cmp_ss_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ss_mask(__mmask8, __m128, __m128, const int);
extern int       __cdecl _mm_comi_round_sd(__m128d, __m128d, const int, const int);
extern int       __cdecl _mm_comi_round_ss(__m128, __m128, const int, const int);
extern __m128    __cdecl _mm_cvt_roundi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvt_roundsd_si32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsd_ss(__m128, __m128d, int);
extern __m128    __cdecl _mm_mask_cvt_roundsd_ss(__m128, __mmask8, __m128, __m128d, int);
extern __m128    __cdecl _mm_maskz_cvt_roundsd_ss(__mmask8, __m128, __m128d, int);
extern unsigned int __cdecl _mm_cvt_roundsd_u32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundss_i32(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundss_sd(__m128d, __m128, int);
extern __m128d   __cdecl _mm_mask_cvt_roundss_sd(__m128d, __mmask8, __m128d, __m128, int);
extern __m128d   __cdecl _mm_maskz_cvt_roundss_sd(__mmask8, __m128d, __m128, int);
extern int       __cdecl _mm_cvt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvt_roundss_u32(__m128, int);
extern __m128    __cdecl _mm_cvt_roundu32_ss(__m128, unsigned int, int);
extern __m128d   __cdecl _mm_cvti32_sd(__m128d, int);
extern __m128    __cdecl _mm_cvti32_ss(__m128, int);
extern int       __cdecl _mm_cvtsd_i32(__m128d);
extern __m128    __cdecl _mm_mask_cvtsd_ss(__m128, __mmask8, __m128, __m128d);
extern __m128    __cdecl _mm_maskz_cvtsd_ss(__mmask8, __m128, __m128d);
extern unsigned int __cdecl _mm_cvtsd_u32(__m128d);
extern int       __cdecl _mm_cvtss_i32(__m128);
extern __m128d   __cdecl _mm_mask_cvtss_sd(__m128d, __mmask8, __m128d, __m128);
extern __m128d   __cdecl _mm_maskz_cvtss_sd(__mmask8, __m128d, __m128);
extern unsigned int __cdecl _mm_cvtss_u32(__m128);
extern int       __cdecl _mm_cvtt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundsd_si32(__m128d, int);
extern unsigned int __cdecl _mm_cvtt_roundsd_u32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundss_i32(__m128, int);
extern int       __cdecl _mm_cvtt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvtt_roundss_u32(__m128, int);
extern int       __cdecl _mm_cvttsd_i32(__m128d);
extern unsigned int __cdecl _mm_cvttsd_u32(__m128d);
extern int       __cdecl _mm_cvttss_i32(__m128);
extern unsigned int __cdecl _mm_cvttss_u32(__m128);
extern __m128d   __cdecl _mm_cvtu32_sd(__m128d, unsigned int);
extern __m128    __cdecl _mm_cvtu32_ss(__m128, unsigned int);
extern __m128d   __cdecl _mm_div_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_div_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_div_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_div_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_div_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_div_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_div_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_div_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_fixupimm_round_sd(__m128d, __m128d, __m128i, const int, int);
extern __m128d   __cdecl _mm_mask_fixupimm_round_sd(__m128d, __mmask8, __m128d, __m128i, const int, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_round_sd(__mmask8, __m128d, __m128d, __m128i, const int, const int);
extern __m128    __cdecl _mm_fixupimm_round_ss(__m128, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_mask_fixupimm_round_ss(__m128, __mmask8, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_round_ss(__mmask8, __m128, __m128, __m128i, const int, const int);
extern __m128d   __cdecl _mm_fixupimm_sd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_sd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_sd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m128    __cdecl _mm_fixupimm_ss(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ss(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ss(__mmask8, __m128, __m128, __m128i, const int);
extern __m128d   __cdecl _mm_fmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ss(__mmask8, __m128, __m128, __m128);
extern __mmask8  __cdecl _mm_fpclass_sd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_sd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm_fpclass_ss_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ss_mask(__mmask8, __m128, int);
extern __m128d   __cdecl _mm_getexp_round_sd(__m128d, __m128d, const int);
extern __m128d   __cdecl _mm_mask_getexp_round_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_getexp_round_sd(__mmask8, __m128d, __m128d, const int);
extern __m128    __cdecl _mm_getexp_round_ss(__m128, __m128, const int);
extern __m128    __cdecl _mm_mask_getexp_round_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_getexp_round_ss(__mmask8, __m128, __m128, const int);
extern __m128d   __cdecl _mm_getexp_sd(__m128d, __m128d);
extern __m128d   __cdecl _mm_mask_getexp_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_getexp_ss(__m128, __m128);
extern __m128    __cdecl _mm_mask_getexp_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_getmant_round_sd(__m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_mask_getmant_round_sd(__m128d, __mmask8, __m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_round_sd(__mmask8, __m128d, __m128d, int, int, int);
extern __m128    __cdecl _mm_getmant_round_ss(__m128, __m128, int, int, int);
extern __m128    __cdecl _mm_mask_getmant_round_ss(__m128, __mmask8, __m128, __m128, int, int, int);
extern __m128    __cdecl _mm_maskz_getmant_round_ss(__mmask8, __m128, __m128, int, int, int);
extern __m128d   __cdecl _mm_getmant_sd(__m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_sd(__m128d, __mmask8, __m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_sd(__mmask8, __m128d, __m128d, int, int);
extern __m128    __cdecl _mm_getmant_ss(__m128, __m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ss(__m128, __mmask8, __m128, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ss(__mmask8, __m128, __m128, int, int);
extern __m128d   __cdecl _mm_mask_load_sd(__m128d, __mmask8, const double*);
extern __m128d   __cdecl _mm_maskz_load_sd(__mmask8, const double*);
extern __m128    __cdecl _mm_mask_load_ss(__m128, __mmask8, const float*);
extern __m128    __cdecl _mm_maskz_load_ss(__mmask8, const float*);
extern __m128d   __cdecl _mm_mask_max_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_max_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_max_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_max_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_max_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_max_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_max_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_max_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_min_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_min_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_min_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_min_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_min_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_min_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_min_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_min_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_move_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_move_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_move_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_move_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_mul_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_mul_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mul_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_mul_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_mul_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mul_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_mul_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_mul_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_range_sd(__m128d, __m128d, const int);
extern __m128d   __cdecl _mm_mask_range_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_range_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_range_round_sd(__m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_mask_range_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_range_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_range_ss(__m128, __m128, const int);
extern __m128    __cdecl _mm_mask_range_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_range_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_range_round_ss(__m128, __m128, const int, int);
extern __m128    __cdecl _mm_mask_range_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_range_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_rcp14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rcp28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rcp28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rcp28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rcp28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rcp28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rcp28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rcp28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_reduce_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_reduce_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_reduce_round_sd(__m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_mask_reduce_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_reduce_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_reduce_round_ss(__m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_reduce_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_reduce_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_reduce_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_reduce_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_reduce_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_reduce_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_roundscale_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_round_sd(__mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_roundscale_round_sd(__m128d, __m128d, const int, const int);
extern __m128    __cdecl _mm_mask_roundscale_round_ss(__m128, __mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_maskz_roundscale_round_ss(__mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_roundscale_round_ss(__m128, __m128, const int, const int);
extern __m128d   __cdecl _mm_mask_roundscale_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_roundscale_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_roundscale_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_roundscale_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_roundscale_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_rsqrt14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rsqrt28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rsqrt28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rsqrt28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rsqrt28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rsqrt28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rsqrt28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rsqrt28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_scalef_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_scalef_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_scalef_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_scalef_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_scalef_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_scalef_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_scalef_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_scalef_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_sqrt_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sqrt_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sqrt_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sqrt_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sqrt_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sqrt_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sqrt_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sqrt_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ss(__mmask8, __m128, __m128);
extern void      __cdecl _mm_mask_store_sd(double*, __mmask8, __m128d);
extern void      __cdecl _mm_mask_store_ss(float*, __mmask8, __m128);
extern __m128d   __cdecl _mm_mask_sub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sub_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sub_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sub_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sub_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ss(__mmask8, __m128, __m128);



extern unsigned __int64 __cdecl _mm_cvtsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvtss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvttsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvttss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvt_roundss_u64(__m128, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundss_u64(__m128, int);

extern __m128d   __cdecl _mm_cvti64_sd(__m128d, __int64);
extern __m128    __cdecl _mm_cvti64_ss(__m128, __int64);
extern __int64   __cdecl _mm_cvtsd_i64(__m128d);
extern __int64   __cdecl _mm_cvtss_i64(__m128);
extern __int64   __cdecl _mm_cvttsd_i64(__m128d);
extern __int64   __cdecl _mm_cvttss_i64(__m128);
extern __int64   __cdecl _mm_cvtt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundsd_si64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvtt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvtu64_sd(__m128d, unsigned __int64);
extern __m128    __cdecl _mm_cvtu64_ss(__m128, unsigned __int64);
extern __m128d   __cdecl _mm_cvt_roundi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvt_roundsd_si64(__m128d, int);
extern __m128d   __cdecl _mm_cvt_roundsi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundsi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundu64_sd(__m128d, unsigned __int64, int);
extern __m128    __cdecl _mm_cvt_roundu64_ss(__m128, unsigned __int64, int);

#line 4344 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\zmmintrin.h"


extern __m512d   __cdecl _mm512_zextpd128_pd512(__m128d);
extern __m512d   __cdecl _mm512_zextpd256_pd512(__m256d);
extern __m512    __cdecl _mm512_zextps128_ps512(__m128);
extern __m512    __cdecl _mm512_zextps256_ps512(__m256);
extern __m512i   __cdecl _mm512_zextsi128_si512(__m128i);
extern __m512i   __cdecl _mm512_zextsi256_si512(__m256i);



























#line 4380 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\zmmintrin.h"


extern __m128i __cdecl _mm_madd52hi_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52hi_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52hi_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52hi_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52hi_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52hi_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52hi_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52hi_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52hi_epu64(__mmask8, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_madd52lo_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52lo_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52lo_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52lo_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52lo_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52lo_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52lo_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52lo_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52lo_epu64(__mmask8, __m512i, __m512i, __m512i);


extern __m128i __cdecl _mm_permutexvar_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_permutexvar_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_permutexvar_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_permutexvar_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutexvar_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_permutexvar_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutexvar_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi8(__mmask64, __m512i, __m512i);

extern __m128i __cdecl _mm_permutex2var_epi8(__m128i, __m128i , __m128i);
extern __m128i __cdecl _mm_mask_permutex2var_epi8(__m128i, __mmask16, __m128i , __m128i);
extern __m128i __cdecl _mm_mask2_permutex2var_epi8(__m128i, __m128i , __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_permutex2var_epi8(__mmask16, __m128i, __m128i , __m128i);
extern __m256i __cdecl _mm256_permutex2var_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutex2var_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask2_permutex2var_epi8(__m256i, __m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_permutex2var_epi8(__mmask32, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutex2var_epi8(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi8(__m512i, __m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi8(__mmask64, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_multishift_epi64_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_multishift_epi64_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_multishift_epi64_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_multishift_epi64_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_multishift_epi64_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_multishift_epi64_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_multishift_epi64_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_multishift_epi64_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_multishift_epi64_epi8(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_dpbusd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusd_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpbusds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusds_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpwssd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpwssds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssds_epi32(__mmask16, __m512i, __m512i, __m512i);


extern __m256i __cdecl _mm256_aesenc_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenc_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesenclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenclast_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdec_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdec_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdeclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdeclast_epi128(__m512i, __m512i);


extern __m256i __cdecl _mm256_clmulepi64_epi128(__m256i, __m256i, const int);
extern __m512i __cdecl _mm512_clmulepi64_epi128(__m512i, __m512i, const int);


extern __m128i __cdecl _mm_popcnt_epi32(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi32(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi32(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi32(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi32(__mmask16, __m512i);

extern __m128i __cdecl _mm_popcnt_epi64(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi64(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi64(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi64(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi64(__mmask8, __m512i);


extern __m128i __cdecl _mm_popcnt_epi8(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi8(__m128i, __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi8(__mmask16, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi8(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi8(__m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi8(__mmask32, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi8(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi8(__mmask64, __m512i);

extern __m128i __cdecl _mm_popcnt_epi16(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi16(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi16(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi16(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi16(__m256i, __mmask16, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi16(__mmask16, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi16(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi16(__mmask32, __m512i);

extern __mmask16 __cdecl _mm_bitshuffle_epi64_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm_mask_bitshuffle_epi64_mask(__mmask16, __m128i, __m128i);
extern __mmask32 __cdecl _mm256_bitshuffle_epi64_mask(__m256i, __m256i);
extern __mmask32 __cdecl _mm256_mask_bitshuffle_epi64_mask(__mmask32, __m256i, __m256i);
extern __mmask64 __cdecl _mm512_bitshuffle_epi64_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_bitshuffle_epi64_mask(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affineinv_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affineinv_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affineinv_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affineinv_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affineinv_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affineinv_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8affine_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affine_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affine_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affine_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affine_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affine_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affine_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affine_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affine_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8mul_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_gf2p8mul_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_gf2p8mul_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_gf2p8mul_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_gf2p8mul_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_gf2p8mul_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_gf2p8mul_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_gf2p8mul_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_gf2p8mul_epi8(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_shldi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi64(__mmask8, __m512i, __m512i, __m512i);


extern __m128i __cdecl _mm_shrdi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi64(__mmask8, __m512i, __m512i, __m512i);






extern __m512i _mm512_div_epi8(__m512i, __m512i);
extern __m512i _mm512_div_epi16(__m512i, __m512i);
extern __m512i _mm512_div_epi32(__m512i, __m512i);
extern __m512i _mm512_div_epi64(__m512i, __m512i);
extern __m512i _mm512_div_epu8(__m512i, __m512i);
extern __m512i _mm512_div_epu16(__m512i, __m512i);
extern __m512i _mm512_div_epu32(__m512i, __m512i);
extern __m512i _mm512_div_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_div_epi32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_div_epu32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_rem_epi8(__m512i, __m512i);
extern __m512i _mm512_rem_epi16(__m512i, __m512i);
extern __m512i _mm512_rem_epi32(__m512i, __m512i);
extern __m512i _mm512_rem_epi64(__m512i, __m512i);
extern __m512i _mm512_rem_epu8(__m512i, __m512i);
extern __m512i _mm512_rem_epu16(__m512i, __m512i);
extern __m512i _mm512_rem_epu32(__m512i, __m512i);
extern __m512i _mm512_rem_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_rem_epi32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_rem_epu32(__m512i , __mmask16, __m512i, __m512i);


extern __m512  _mm512_sin_ps(__m512);
extern __m512  _mm512_mask_sin_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sin_pd(__m512d);
extern __m512d _mm512_mask_sin_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cos_ps(__m512);
extern __m512  _mm512_mask_cos_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cos_pd(__m512d);
extern __m512d _mm512_mask_cos_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_sincos_ps(__m512  * , __m512);
extern __m512  _mm512_mask_sincos_ps(__m512  * , __m512  , __m512  , __mmask16, __m512);
extern __m512d _mm512_sincos_pd(__m512d * , __m512d);
extern __m512d _mm512_mask_sincos_pd(__m512d * , __m512d , __m512d , __mmask8, __m512d);
extern __m512  _mm512_tan_ps(__m512);
extern __m512  _mm512_mask_tan_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tan_pd(__m512d);
extern __m512d _mm512_mask_tan_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_asin_ps(__m512);
extern __m512  _mm512_mask_asin_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_asin_pd(__m512d);
extern __m512d _mm512_mask_asin_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_acos_ps(__m512);
extern __m512  _mm512_mask_acos_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_acos_pd(__m512d);
extern __m512d _mm512_mask_acos_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atan_ps(__m512);
extern __m512  _mm512_mask_atan_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_atan_pd(__m512d);
extern __m512d _mm512_mask_atan_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atan2_ps(__m512, __m512);
extern __m512  _mm512_mask_atan2_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_atan2_pd(__m512d, __m512d);
extern __m512d _mm512_mask_atan2_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_sind_ps(__m512);
extern __m512  _mm512_mask_sind_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sind_pd(__m512d);
extern __m512d _mm512_mask_sind_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cosd_ps(__m512);
extern __m512  _mm512_mask_cosd_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cosd_pd(__m512d);
extern __m512d _mm512_mask_cosd_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_tand_ps(__m512);
extern __m512  _mm512_mask_tand_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tand_pd(__m512d);
extern __m512d _mm512_mask_tand_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_sinh_ps(__m512);
extern __m512  _mm512_mask_sinh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sinh_pd(__m512d);
extern __m512d _mm512_mask_sinh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cosh_ps(__m512);
extern __m512  _mm512_mask_cosh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cosh_pd(__m512d);
extern __m512d _mm512_mask_cosh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_tanh_ps(__m512);
extern __m512  _mm512_mask_tanh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tanh_pd(__m512d);
extern __m512d _mm512_mask_tanh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_asinh_ps(__m512);
extern __m512  _mm512_mask_asinh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_asinh_pd(__m512d);
extern __m512d _mm512_mask_asinh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_acosh_ps(__m512);
extern __m512  _mm512_mask_acosh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_acosh_pd(__m512d);
extern __m512d _mm512_mask_acosh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atanh_ps(__m512);
extern __m512  _mm512_mask_atanh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_atanh_pd(__m512d);
extern __m512d _mm512_mask_atanh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log_ps(__m512);
extern __m512  _mm512_mask_log_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log_pd(__m512d);
extern __m512d _mm512_mask_log_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log1p_ps(__m512);
extern __m512  _mm512_mask_log1p_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log1p_pd(__m512d);
extern __m512d _mm512_mask_log1p_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log10_ps(__m512);
extern __m512  _mm512_mask_log10_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log10_pd(__m512d);
extern __m512d _mm512_mask_log10_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log2_ps(__m512);
extern __m512  _mm512_mask_log2_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log2_pd(__m512d);
extern __m512d _mm512_mask_log2_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_logb_ps(__m512);
extern __m512  _mm512_mask_logb_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_logb_pd(__m512d);
extern __m512d _mm512_mask_logb_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp_ps(__m512);
extern __m512  _mm512_mask_exp_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp_pd(__m512d);
extern __m512d _mm512_mask_exp_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp10_ps(__m512);
extern __m512  _mm512_mask_exp10_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp10_pd(__m512d);
extern __m512d _mm512_mask_exp10_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp2_ps(__m512);
extern __m512  _mm512_mask_exp2_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp2_pd(__m512d);
extern __m512d _mm512_mask_exp2_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_expm1_ps(__m512);
extern __m512  _mm512_mask_expm1_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_expm1_pd(__m512d);
extern __m512d _mm512_mask_expm1_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_pow_ps(__m512, __m512);
extern __m512  _mm512_mask_pow_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_pow_pd(__m512d, __m512d);
extern __m512d _mm512_mask_pow_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_trunc_ps(__m512);
extern __m512  _mm512_mask_trunc_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_trunc_pd(__m512d);
extern __m512d _mm512_mask_trunc_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_floor_ps(__m512);
extern __m512  _mm512_mask_floor_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_floor_pd(__m512d);
extern __m512d _mm512_mask_floor_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_ceil_ps(__m512);
extern __m512  _mm512_mask_ceil_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_ceil_pd(__m512d);
extern __m512d _mm512_mask_ceil_pd(__m512d , __mmask8, __m512d);
extern __m512 _mm512_svml_round_ps(__m512);
extern __m512 _mm512_mask_svml_round_ps(__m512 , __mmask16, __m512);
extern __m512d _mm512_svml_round_pd(__m512d);
extern __m512d _mm512_mask_svml_round_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_fmod_ps(__m512, __m512);
extern __m512  _mm512_mask_fmod_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_fmod_pd(__m512d, __m512d);
extern __m512d _mm512_mask_fmod_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_rint_ps(__m512);
extern __m512  _mm512_mask_rint_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_rint_pd(__m512d);
extern __m512d _mm512_mask_rint_pd(__m512d , __mmask8, __m512d);






extern __m512  _mm512_invsqrt_ps(__m512);
extern __m512  _mm512_mask_invsqrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_invsqrt_pd(__m512d);
extern __m512d _mm512_mask_invsqrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cbrt_ps(__m512);
extern __m512  _mm512_mask_cbrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cbrt_pd(__m512d);
extern __m512d _mm512_mask_cbrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_invcbrt_ps(__m512);
extern __m512  _mm512_mask_invcbrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_invcbrt_pd(__m512d);
extern __m512d _mm512_mask_invcbrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_hypot_ps(__m512, __m512);
extern __m512  _mm512_mask_hypot_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_hypot_pd(__m512d, __m512d);
extern __m512d _mm512_mask_hypot_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_cdfnorm_ps(__m512);
extern __m512  _mm512_mask_cdfnorm_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cdfnorm_pd(__m512d);
extern __m512d _mm512_mask_cdfnorm_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cdfnorminv_ps(__m512);
extern __m512  _mm512_mask_cdfnorminv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cdfnorminv_pd(__m512d);
extern __m512d _mm512_mask_cdfnorminv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erf_ps(__m512);
extern __m512  _mm512_mask_erf_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erf_pd(__m512d);
extern __m512d _mm512_mask_erf_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfc_ps(__m512);
extern __m512  _mm512_mask_erfc_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfc_pd(__m512d);
extern __m512d _mm512_mask_erfc_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfcinv_ps(__m512);
extern __m512  _mm512_mask_erfcinv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfcinv_pd(__m512d);
extern __m512d _mm512_mask_erfcinv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfinv_ps(__m512);
extern __m512  _mm512_mask_erfinv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfinv_pd(__m512d);
extern __m512d _mm512_mask_erfinv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_nearbyint_ps(__m512);
extern __m512  _mm512_mask_nearbyint_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_nearbyint_pd(__m512d);
extern __m512d _mm512_mask_nearbyint_pd(__m512d , __mmask8, __m512d);


typedef __m128i __m128bh;
typedef __m256i __m256bh;
typedef __m512i __m512bh;

extern __m128bh _mm_cvtneps_pbh(__m128);
extern __m128bh _mm_mask_cvtneps_pbh(__m128bh, __mmask8, __m128);
extern __m128bh _mm_maskz_cvtneps_pbh(__mmask8, __m128);
extern __m128bh _mm_cvtne2ps_pbh(__m128, __m128);
extern __m128bh _mm_mask_cvtne2ps_pbh(__m128bh, __mmask8, __m128, __m128);
extern __m128bh _mm_maskz_cvtne2ps_pbh(__mmask8, __m128, __m128);
extern __m128   _mm_dpbf16_ps(__m128, __m128bh, __m128bh);
extern __m128   _mm_mask_dpbf16_ps(__m128, __mmask8, __m128bh, __m128bh);
extern __m128   _mm_maskz_dpbf16_ps(__mmask8, __m128, __m128bh, __m128bh);
extern __m128bh _mm256_cvtneps_pbh(__m256);
extern __m128bh _mm256_mask_cvtneps_pbh(__m128bh, __mmask8, __m256);
extern __m128bh _mm256_maskz_cvtneps_pbh(__mmask8, __m256);
extern __m256bh _mm256_cvtne2ps_pbh(__m256, __m256);
extern __m256bh _mm256_mask_cvtne2ps_pbh(__m256bh, __mmask16, __m256, __m256);
extern __m256bh _mm256_maskz_cvtne2ps_pbh(__mmask16, __m256, __m256);
extern __m256   _mm256_dpbf16_ps(__m256, __m256bh, __m256bh);
extern __m256   _mm256_mask_dpbf16_ps(__m256, __mmask8, __m256bh, __m256bh);
extern __m256   _mm256_maskz_dpbf16_ps(__mmask8, __m256, __m256bh, __m256bh);
extern __m256bh _mm512_cvtneps_pbh(__m512);
extern __m256bh _mm512_mask_cvtneps_pbh(__m256bh, __mmask16, __m512);
extern __m256bh _mm512_maskz_cvtneps_pbh(__mmask16, __m512);
extern __m512bh _mm512_cvtne2ps_pbh(__m512, __m512);
extern __m512bh _mm512_mask_cvtne2ps_pbh(__m512bh, __mmask32, __m512, __m512);
extern __m512bh _mm512_maskz_cvtne2ps_pbh(__mmask32, __m512, __m512);
extern __m512   _mm512_dpbf16_ps(__m512, __m512bh, __m512bh);
extern __m512   _mm512_mask_dpbf16_ps(__m512, __mmask16, __m512bh, __m512bh);
extern __m512   _mm512_maskz_dpbf16_ps(__mmask16, __m512, __m512bh, __m512bh);




















extern __mmask8  __cdecl _kadd_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kadd_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kadd_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kadd_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kand_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kand_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kand_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kand_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kandn_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kandn_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kandn_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kandn_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _knot_mask8(__mmask8);
extern __mmask16 __cdecl _knot_mask16(__mmask16);
extern __mmask32 __cdecl _knot_mask32(__mmask32);
extern __mmask64 __cdecl _knot_mask64(__mmask64);
extern __mmask8  __cdecl _kor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kxnor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kxnor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kxnor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kxnor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kxor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kxor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kxor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kxor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kshiftli_mask8(__mmask8, unsigned int);
extern __mmask16 __cdecl _kshiftli_mask16(__mmask16, unsigned int);
extern __mmask32 __cdecl _kshiftli_mask32(__mmask32, unsigned int);
extern __mmask64 __cdecl _kshiftli_mask64(__mmask64, unsigned int);
extern __mmask8  __cdecl _kshiftri_mask8(__mmask8, unsigned int);
extern __mmask16 __cdecl _kshiftri_mask16(__mmask16, unsigned int);
extern __mmask32 __cdecl _kshiftri_mask32(__mmask32, unsigned int);
extern __mmask64 __cdecl _kshiftri_mask64(__mmask64, unsigned int);
extern __mmask8  __cdecl _load_mask8(__mmask8 *);
extern __mmask16 __cdecl _load_mask16(__mmask16 *);
extern __mmask32 __cdecl _load_mask32(__mmask32 *);
extern __mmask64 __cdecl _load_mask64(__mmask64 *);
extern void      __cdecl _store_mask8(__mmask8 *, __mmask8);
extern void      __cdecl _store_mask16(__mmask16 *, __mmask16);
extern void      __cdecl _store_mask32(__mmask32 *, __mmask32);
extern void      __cdecl _store_mask64(__mmask64 *, __mmask64);
extern unsigned int     __cdecl _cvtmask8_u32(__mmask8);
extern unsigned int     __cdecl _cvtmask16_u32(__mmask16);
extern unsigned int     __cdecl _cvtmask32_u32(__mmask32);
extern unsigned __int64 __cdecl _cvtmask64_u64(__mmask64);
extern __mmask8         __cdecl _cvtu32_mask8(unsigned int);
extern __mmask16        __cdecl _cvtu32_mask16(unsigned int);
extern __mmask32        __cdecl _cvtu32_mask32(unsigned int);
extern __mmask64        __cdecl _cvtu64_mask64(unsigned __int64);
extern __mmask16        __cdecl _mm512_kmov(__mmask16);
extern unsigned char __cdecl _kortest_mask8_u8(__mmask8, __mmask8, unsigned char *);
extern unsigned char __cdecl _kortest_mask16_u8(__mmask16, __mmask16, unsigned char *);
extern unsigned char __cdecl _kortest_mask32_u8(__mmask32, __mmask32, unsigned char *);
extern unsigned char __cdecl _kortest_mask64_u8(__mmask64, __mmask64, unsigned char *);
extern unsigned char __cdecl _ktest_mask8_u8(__mmask8, __mmask8, unsigned char *);
extern unsigned char __cdecl _ktest_mask16_u8(__mmask16, __mmask16, unsigned char *);
extern unsigned char __cdecl _ktest_mask32_u8(__mmask32, __mmask32, unsigned char *);
extern unsigned char __cdecl _ktest_mask64_u8(__mmask64, __mmask64, unsigned char *);





































extern __m512  __cdecl _mm512_mask_exp2a23_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_exp2a23_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_mask_exp2a23_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_exp2a23_round_pd(__mmask8, __m512d, int);


















extern __m512  __cdecl _mm512_mask_rcp28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rcp28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rcp28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rcp28_round_pd(__mmask8, __m512d, const int);


















extern __m512  __cdecl _mm512_mask_rsqrt28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rsqrt28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rsqrt28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rsqrt28_round_pd(__mmask8, __m512d, const int);


















extern void __cdecl _mm512_prefetch_i32gather_pd(__m256i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32gather_ps(__m512i index, void const* mv, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_pd(void* base_addr, __m256i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_ps(void* mv, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_pd(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_ps(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_pd(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_ps(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_pd(__m256i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_ps(__m512i vindex, __mmask16 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_pd(void* base_addr, __mmask8 mask, __m256i vinde, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_ps(void* mv, __mmask16 k, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_pd(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_ps(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_pd(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_ps(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);


extern void __cdecl _mm_2intersect_epi32(__m128i, __m128i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm256_2intersect_epi32(__m256i, __m256i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm512_2intersect_epi32(__m512i, __m512i, __mmask16 *, __mmask16 *);
extern void __cdecl _mm_2intersect_epi64(__m128i, __m128i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm256_2intersect_epi64(__m256i, __m256i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm512_2intersect_epi64(__m512i, __m512i, __mmask8 *, __mmask8 *);




typedef int __tile;

extern void __cdecl _tile_loadconfig(const void *);
extern void __cdecl _tile_storeconfig(void *);
extern void __cdecl _tile_release(void);

extern void __cdecl _tile_loadd(__tile dst, const void *base, int stride);
extern void __cdecl _tile_stream_loadd(__tile dst, const void *base, int stride);
extern void __cdecl _tile_stored(__tile src, void *base, int stride);
extern void __cdecl _tile_zero(__tile dst);

extern void __cdecl _tile_dpbf16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbssd(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbsud(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbusd(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbuud(__tile dst, __tile src1, __tile src2);

#line 5153 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\zmmintrin.h"


}
#line 5157 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\zmmintrin.h"


#line 5160 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\zmmintrin.h"
#pragma external_header(pop)
#line 2456 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"

#line 2458 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"
#line 2459 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"
#line 2460 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\immintrin.h"
#pragma external_header(pop)
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"
        #pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"































#pragma once



#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"







#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"



#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"


extern "C" { 
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb(void);
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);

void __lwpval64(unsigned __int64, unsigned int, unsigned int);
unsigned char __lwpins64(unsigned __int64, unsigned int, unsigned int);
#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);

unsigned __int64 _bextr_u64(unsigned __int64, unsigned int, unsigned int);
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64);
unsigned __int64 _tzcnt_u64(unsigned __int64);
unsigned __int64 _lzcnt_u64(unsigned __int64);
unsigned __int64 _blsr_u64(unsigned __int64);
unsigned __int64 _blsmsk_u64(unsigned __int64);
unsigned __int64 _blsi_u64(unsigned __int64);
#line 295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);

unsigned __int64 _bextri_u64(unsigned __int64, unsigned int);
unsigned __int64 _blcfill_u64(unsigned __int64);
unsigned __int64 _blsfill_u64(unsigned __int64);
unsigned __int64 _blcs_u64(unsigned __int64);
unsigned __int64 _tzmsk_u64(unsigned __int64);
unsigned __int64 _blcic_u64(unsigned __int64);
unsigned __int64 _blsic_u64(unsigned __int64);
unsigned __int64 _t1mskc_u64(unsigned __int64);
unsigned __int64 _blcmsk_u64(unsigned __int64);
unsigned __int64 _blci_u64(unsigned __int64);
#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"

void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);

void _mm_clzero(void const *);



typedef struct rmp_seg {
    unsigned __int64 rmp_gpa;
    __int8           rmp_entry;
    __int8           rmp_pageSize;
    __int8           rmp_pageMark;
    __int8           rmp_reserved;
    __int32          rmp_ASID;
} rmp_seg;

unsigned int __rmpupdate(unsigned __int64, rmp_seg *, int);
unsigned int __pvalidate(unsigned __int64, int, int, int *);
unsigned int __psmash(unsigned __int64);
unsigned int __rmpadjust(unsigned __int64, int, int);
#line 341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"



void __svm_invlpgb(void*, int);
void __svm_tlbsync(void);



}; 
#line 351 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"

#line 353 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"
#line 354 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"
#line 355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ammintrin.h"
#pragma external_header(pop)
#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"
    #line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"

    

#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"

    


#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"

    


#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"
#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"


extern "C" {
#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"


void * _AddressOfReturnAddress(void);










int _cvt_dtoi_fast (double);
int _cvt_dtoi_sat (double);
int _cvt_dtoi_sent (double);
long long _cvt_dtoll_fast (double);
long long _cvt_dtoll_sat (double);
long long _cvt_dtoll_sent (double);
unsigned _cvt_dtoui_fast (double);
unsigned _cvt_dtoui_sat (double);
unsigned _cvt_dtoui_sent (double);
unsigned long long _cvt_dtoull_fast (double);
unsigned long long _cvt_dtoull_sat (double);
unsigned long long _cvt_dtoull_sent (double);
int _cvt_ftoi_fast (float);
int _cvt_ftoi_sat (float);
int _cvt_ftoi_sent (float);
long long _cvt_ftoll_fast (float);
long long _cvt_ftoll_sat (float);
long long _cvt_ftoll_sent (float);
unsigned _cvt_ftoui_fast (float);
unsigned _cvt_ftoui_sat (float);
unsigned _cvt_ftoui_sent (float);
unsigned long long _cvt_ftoull_fast (float);
unsigned long long _cvt_ftoull_sat (float);
unsigned long long _cvt_ftoull_sent (float);




long _interlockedadd(long volatile * _Addend, long _Value);

__int64 _interlockedadd64(__int64 volatile * _Addend, __int64 _Value);







short _InterlockedAnd16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedAnd64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedAnd8_np(char volatile * _Value, char _Mask);
long _InterlockedAnd_np(long volatile * _Value, long _Mask);
unsigned char _InterlockedCompareExchange128_np(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);
short _InterlockedCompareExchange16_np(short volatile * _Destination, short _Exchange, short _Comparand);
__int64 _InterlockedCompareExchange64_np(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);
void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);


void * _InterlockedCompareExchangePointer_np(void * volatile * _Destination, void * _Exchange, void * _Comparand);

long _InterlockedCompareExchange_np(long volatile * _Destination, long _Exchange, long _Comparand);









void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);











short _InterlockedOr16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedOr64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedOr8_np(char volatile * _Value, char _Mask);
long _InterlockedOr_np(long volatile * _Value, long _Mask);
short _InterlockedXor16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedXor64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedXor8_np(char volatile * _Value, char _Mask);
long _InterlockedXor_np(long volatile * _Value, long _Mask);








void _ReadBarrier(void);






void * _ReturnAddress(void);

void _WriteBarrier(void);









void __addgsbyte(unsigned long, unsigned char);
void __addgsdword(unsigned long, unsigned long);
void __addgsqword(unsigned long, unsigned __int64);
void __addgsword(unsigned long, unsigned short);




void __clts(void);
void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);
void __faststorefence(void);
unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);



void __incgsbyte(unsigned long);
void __incgsdword(unsigned long);
void __incgsqword(unsigned long);
void __incgsword(unsigned long);




unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);
void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);
void __movsq(unsigned long long *, unsigned long long const *, size_t);
void __movsw(unsigned short *, unsigned short const *, size_t);
__int64 __mulh(__int64, __int64);
void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);
unsigned __int64 __readcr0(void);

unsigned __int64 __readcr2(void);

unsigned __int64 __readcr3(void);

unsigned __int64 __readcr4(void);

unsigned __int64 __readcr8(void);

unsigned __int64 __readdr(unsigned int);

unsigned __int64 __readeflags(void);





unsigned char __readgsbyte(unsigned long);
unsigned long __readgsdword(unsigned long);
unsigned __int64 __readgsqword(unsigned long);
unsigned short __readgsword(unsigned long);
unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);




unsigned long __segmentlimit(unsigned long);

unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);
void __stosq(unsigned __int64 *, unsigned __int64, size_t);
void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);
unsigned __int64 __umulh(unsigned __int64, unsigned __int64);
void __vmx_off(void);
unsigned char __vmx_on(unsigned __int64 *);
unsigned char __vmx_vmclear(unsigned __int64 *);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned __int64 *);
void __vmx_vmptrst(unsigned __int64 *);
unsigned char __vmx_vmread(size_t, size_t *);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);
void __wbinvd(void);


void __writecr0(unsigned __int64);

void __writecr2(unsigned __int64);

void __writecr3(unsigned __int64);

void __writecr4(unsigned __int64);

void __writecr8(unsigned __int64);

void __writedr(unsigned int, unsigned __int64);

void __writeeflags(unsigned __int64);





void __writegsbyte(unsigned long, unsigned char);
void __writegsdword(unsigned long, unsigned long);
void __writegsqword(unsigned long, unsigned __int64);
void __writegsword(unsigned long, unsigned short);
void __writemsr(unsigned long, unsigned __int64);




unsigned char _bittest64(__int64 const *, __int64);
unsigned char _bittestandcomplement(long *, long);
unsigned char _bittestandcomplement64(__int64 *, __int64);
unsigned char _bittestandreset(long *, long);
unsigned char _bittestandreset64(__int64 *, __int64);
unsigned char _bittestandset(long *, long);
unsigned char _bittestandset64(__int64 *, __int64);
[[nodiscard]]   unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
[[nodiscard]]   unsigned long __cdecl _byteswap_ulong(  unsigned long);
[[nodiscard]]   unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);
unsigned char _interlockedbittestandreset64(__int64 volatile *, __int64);






unsigned char _interlockedbittestandset64(__int64 volatile *, __int64);













[[nodiscard]]   unsigned long __cdecl _lrotl(  unsigned long,   int);
[[nodiscard]]   unsigned long __cdecl _lrotr(  unsigned long,   int);




























































void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);



































__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);



__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);

__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);

__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
void _mm_clzero(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64);
unsigned int _mm_crc32_u8(unsigned int, unsigned char);


__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);

__m128 _mm_cvtpd_ps(__m128d);

__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);
__int64 _mm_cvtsd_si64(__m128d);
__int64 _mm_cvtsd_si64x(__m128d);
__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);
__int64 _mm_cvtsi128_si64(__m128i);
__int64 _mm_cvtsi128_si64x(__m128i);
__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);
__m128d _mm_cvtsi64_sd(__m128d, __int64);
__m128i _mm_cvtsi64_si128(__int64);
__m128 _mm_cvtsi64_ss(__m128, __int64);
__m128d _mm_cvtsi64x_sd(__m128d, __int64);
__m128i _mm_cvtsi64x_si128(__int64);
__m128 _mm_cvtsi64x_ss(__m128, __int64);
__m128d _mm_cvtss_sd(__m128d, __m128);
__int64 _mm_cvtss_si64(__m128);
__int64 _mm_cvtss_si64x(__m128);

int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);

__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);
__int64 _mm_cvttsd_si64(__m128d);
__int64 _mm_cvttsd_si64x(__m128d);
__int64 _mm_cvttss_si64(__m128);
__int64 _mm_cvttss_si64x(__m128);
__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);
__int64 _mm_extract_epi64(__m128i, int);
int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);


__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);

__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);


__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);

__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);
__m128i _mm_insert_epi64(__m128i, __int64, int);
__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);

void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);


__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);

__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);

__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
int _mm_popcnt_u32(unsigned int);
__int64 _mm_popcnt_u64(unsigned __int64);
void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);

__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);



__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);

__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);



__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);

__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);



__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);

void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);

__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);



__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);


#line 869 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"
__m128i _mm_stream_load_si128(const __m128i *);
#line 871 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"
void _mm_stream_pd(double *, __m128d);

void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);
void _mm_stream_si64x(__int64 *, __int64);
void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);

__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct);
unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);
int __cdecl _setjmpex(jmp_buf);
void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);
unsigned int __rmpupdate(unsigned __int64, rmp_seg *, int);
unsigned int __psmash(unsigned __int64);
unsigned int __rmpadjust(unsigned __int64, int, int);
unsigned int __pvalidate(unsigned __int64, int, int, int*);
void __svm_invlpgb(void*, int);
void __svm_tlbsync(void);



    





#line 964 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"

#line 966 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"


}
#line 970 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"
#pragma warning(pop) 
#line 972 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\intrin.h"
#pragma external_header(pop)
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#pragma warning(pop)
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"























#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

#pragma warning(push)
#pragma warning(disable : 4005 4668)


#pragma warning(pop)







#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"













#line 173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"




#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"


#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"











#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

namespace DirectX
{

    



























#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    constexpr float XM_PI = 3.141592654f;
    constexpr float XM_2PI = 6.283185307f;
    constexpr float XM_1DIVPI = 0.318309886f;
    constexpr float XM_1DIV2PI = 0.159154943f;
    constexpr float XM_PIDIV2 = 1.570796327f;
    constexpr float XM_PIDIV4 = 0.785398163f;

    constexpr uint32_t XM_SELECT_0 = 0x00000000;
    constexpr uint32_t XM_SELECT_1 = 0xFFFFFFFF;

    constexpr uint32_t XM_PERMUTE_0X = 0;
    constexpr uint32_t XM_PERMUTE_0Y = 1;
    constexpr uint32_t XM_PERMUTE_0Z = 2;
    constexpr uint32_t XM_PERMUTE_0W = 3;
    constexpr uint32_t XM_PERMUTE_1X = 4;
    constexpr uint32_t XM_PERMUTE_1Y = 5;
    constexpr uint32_t XM_PERMUTE_1Z = 6;
    constexpr uint32_t XM_PERMUTE_1W = 7;

    constexpr uint32_t XM_SWIZZLE_X = 0;
    constexpr uint32_t XM_SWIZZLE_Y = 1;
    constexpr uint32_t XM_SWIZZLE_Z = 2;
    constexpr uint32_t XM_SWIZZLE_W = 3;

    constexpr uint32_t XM_CRMASK_CR6 = 0x000000F0;
    constexpr uint32_t XM_CRMASK_CR6TRUE = 0x00000080;
    constexpr uint32_t XM_CRMASK_CR6FALSE = 0x00000020;
    constexpr uint32_t XM_CRMASK_CR6BOUNDS = XM_CRMASK_CR6FALSE;

    constexpr size_t XM_CACHE_LINE_SIZE = 64;


    













#line 286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

     

    inline constexpr float XMConvertToRadians(float fDegrees) noexcept { return fDegrees * (XM_PI / 180.0f); }
    inline constexpr float XMConvertToDegrees(float fRadians) noexcept { return fRadians * (180.0f / XM_PI); }

    

    inline constexpr bool XMComparisonAllTrue(uint32_t CR) noexcept { return (((CR)&XM_CRMASK_CR6TRUE) == XM_CRMASK_CR6TRUE); }
    inline constexpr bool XMComparisonAnyTrue(uint32_t CR) noexcept { return (((CR)&XM_CRMASK_CR6FALSE) != XM_CRMASK_CR6FALSE); }
    inline constexpr bool XMComparisonAllFalse(uint32_t CR) noexcept { return (((CR)&XM_CRMASK_CR6FALSE) == XM_CRMASK_CR6FALSE); }
    inline constexpr bool XMComparisonAnyFalse(uint32_t CR) noexcept { return (((CR)&XM_CRMASK_CR6TRUE) != XM_CRMASK_CR6TRUE); }
    inline constexpr bool XMComparisonMixed(uint32_t CR) noexcept { return (((CR)&XM_CRMASK_CR6) == 0); }
    inline constexpr bool XMComparisonAllInBounds(uint32_t CR) noexcept { return (((CR)&XM_CRMASK_CR6BOUNDS) == XM_CRMASK_CR6BOUNDS); }
    inline constexpr bool XMComparisonAnyOutOfBounds(uint32_t CR) noexcept { return (((CR)&XM_CRMASK_CR6BOUNDS) != XM_CRMASK_CR6BOUNDS); }


    





#pragma warning(push)
#pragma warning(disable:4068 4201 4365 4324 4820)
     
     
     
     
















#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    
    
    

    using XMVECTOR = __m128;




#line 343 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    

    typedef const XMVECTOR FXMVECTOR;


#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    

    typedef const XMVECTOR GXMVECTOR;


#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    

    typedef const XMVECTOR HXMVECTOR;


#line 364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    
    typedef const XMVECTOR& CXMVECTOR;

    
    
    __declspec(align(16)) struct XMVECTORF32
    {
        union
        {
            float f[4];
            XMVECTOR v;
        };

        inline operator XMVECTOR() const noexcept { return v; }
        inline operator const float* () const noexcept { return f; }


        inline operator __m128i() const noexcept { return _mm_castps_si128(v); }
        inline operator __m128d() const noexcept { return _mm_castps_pd(v); }



#line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    };

    __declspec(align(16)) struct XMVECTORI32
    {
        union
        {
            int32_t i[4];
            XMVECTOR v;
        };

        inline operator XMVECTOR() const noexcept { return v; }


        inline operator __m128i() const noexcept { return _mm_castps_si128(v); }
        inline operator __m128d() const noexcept { return _mm_castps_pd(v); }



#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    };

    __declspec(align(16)) struct XMVECTORU8
    {
        union
        {
            uint8_t u[16];
            XMVECTOR v;
        };

        inline operator XMVECTOR() const noexcept { return v; }


        inline operator __m128i() const noexcept { return _mm_castps_si128(v); }
        inline operator __m128d() const noexcept { return _mm_castps_pd(v); }



#line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    };

    __declspec(align(16)) struct XMVECTORU32
    {
        union
        {
            uint32_t u[4];
            XMVECTOR v;
        };

        inline operator XMVECTOR() const noexcept { return v; }


        inline operator __m128i() const noexcept { return _mm_castps_si128(v); }
        inline operator __m128d() const noexcept { return _mm_castps_pd(v); }



#line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    };

    
    


    XMVECTOR    __vectorcall     operator+ (FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     operator- (FXMVECTOR V) noexcept;

    XMVECTOR& __vectorcall     operator+= (XMVECTOR& V1, FXMVECTOR V2) noexcept;
    XMVECTOR& __vectorcall     operator-= (XMVECTOR& V1, FXMVECTOR V2) noexcept;
    XMVECTOR& __vectorcall     operator*= (XMVECTOR& V1, FXMVECTOR V2) noexcept;
    XMVECTOR& __vectorcall     operator/= (XMVECTOR& V1, FXMVECTOR V2) noexcept;

    XMVECTOR& operator*= (XMVECTOR& V, float S) noexcept;
    XMVECTOR& operator/= (XMVECTOR& V, float S) noexcept;

    XMVECTOR    __vectorcall     operator+ (FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     operator- (FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     operator* (FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     operator/ (FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     operator* (FXMVECTOR V, float S) noexcept;
    XMVECTOR    __vectorcall     operator* (float S, FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     operator/ (FXMVECTOR V, float S) noexcept;
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    
    
    

    struct XMMATRIX;

    

    typedef const XMMATRIX FXMMATRIX;


#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    
    typedef const XMMATRIX& CXMMATRIX;




    __declspec(align(16)) struct XMMATRIX
#line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    {














        XMVECTOR r[4];
#line 509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

        XMMATRIX() = default;

        XMMATRIX(const XMMATRIX&) = default;



#line 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
        XMMATRIX& operator=(const XMMATRIX&) = default;

        XMMATRIX(XMMATRIX&&) = default;
        XMMATRIX& operator=(XMMATRIX&&) = default;
#line 522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

        constexpr XMMATRIX(FXMVECTOR R0, FXMVECTOR R1, FXMVECTOR R2, CXMVECTOR R3) noexcept : r{ R0,R1,R2,R3 } {}
        XMMATRIX(float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23,
            float m30, float m31, float m32, float m33) noexcept;
        explicit XMMATRIX(  const float* pArray) noexcept;






        XMMATRIX    operator+ () const noexcept { return *this; }
        XMMATRIX    operator- () const noexcept;

        XMMATRIX& __vectorcall     operator+= (FXMMATRIX M) noexcept;
        XMMATRIX& __vectorcall     operator-= (FXMMATRIX M) noexcept;
        XMMATRIX& __vectorcall     operator*= (FXMMATRIX M) noexcept;
        XMMATRIX& operator*= (float S) noexcept;
        XMMATRIX& operator/= (float S) noexcept;

        XMMATRIX    __vectorcall     operator+ (FXMMATRIX M) const noexcept;
        XMMATRIX    __vectorcall     operator- (FXMMATRIX M) const noexcept;
        XMMATRIX    __vectorcall     operator* (FXMMATRIX M) const noexcept;
        XMMATRIX    operator* (float S) const noexcept;
        XMMATRIX    operator/ (float S) const noexcept;

        friend XMMATRIX     __vectorcall     operator* (float S, FXMMATRIX M) noexcept;
    };

    
    
    struct XMFLOAT2
    {
        float x;
        float y;

        XMFLOAT2() = default;

        XMFLOAT2(const XMFLOAT2&) = default;
        XMFLOAT2& operator=(const XMFLOAT2&) = default;

        XMFLOAT2(XMFLOAT2&&) = default;
        XMFLOAT2& operator=(XMFLOAT2&&) = default;

        constexpr XMFLOAT2(float _x, float _y) noexcept : x(_x), y(_y) {}
        explicit XMFLOAT2(  const float* pArray)  noexcept : x(pArray[0]), y(pArray[1]) {}
    };

    
    __declspec(align(16)) struct XMFLOAT2A : public XMFLOAT2
    {
        XMFLOAT2A() = default;

        XMFLOAT2A(const XMFLOAT2A&) = default;
        XMFLOAT2A& operator=(const XMFLOAT2A&) = default;

        XMFLOAT2A(XMFLOAT2A&&) = default;
        XMFLOAT2A& operator=(XMFLOAT2A&&) = default;

        constexpr XMFLOAT2A(float _x, float _y) noexcept : XMFLOAT2(_x, _y) {}
        explicit XMFLOAT2A(  const float* pArray) noexcept : XMFLOAT2(pArray) {}
    };

    
    
    struct XMINT2
    {
        int32_t x;
        int32_t y;

        XMINT2() = default;

        XMINT2(const XMINT2&) = default;
        XMINT2& operator=(const XMINT2&) = default;

        XMINT2(XMINT2&&) = default;
        XMINT2& operator=(XMINT2&&) = default;

        constexpr XMINT2(int32_t _x, int32_t _y) noexcept : x(_x), y(_y) {}
        explicit XMINT2(  const int32_t* pArray) noexcept : x(pArray[0]), y(pArray[1]) {}
    };

    
    struct XMUINT2
    {
        uint32_t x;
        uint32_t y;

        XMUINT2() = default;

        XMUINT2(const XMUINT2&) = default;
        XMUINT2& operator=(const XMUINT2&) = default;

        XMUINT2(XMUINT2&&) = default;
        XMUINT2& operator=(XMUINT2&&) = default;

        constexpr XMUINT2(uint32_t _x, uint32_t _y) noexcept : x(_x), y(_y) {}
        explicit XMUINT2(  const uint32_t* pArray) noexcept : x(pArray[0]), y(pArray[1]) {}
    };

    
    
    struct XMFLOAT3
    {
        float x;
        float y;
        float z;

        XMFLOAT3() = default;

        XMFLOAT3(const XMFLOAT3&) = default;
        XMFLOAT3& operator=(const XMFLOAT3&) = default;

        XMFLOAT3(XMFLOAT3&&) = default;
        XMFLOAT3& operator=(XMFLOAT3&&) = default;

        constexpr XMFLOAT3(float _x, float _y, float _z) noexcept : x(_x), y(_y), z(_z) {}
        explicit XMFLOAT3(  const float* pArray) noexcept : x(pArray[0]), y(pArray[1]), z(pArray[2]) {}
    };

    
    __declspec(align(16)) struct XMFLOAT3A : public XMFLOAT3
    {
        XMFLOAT3A() = default;

        XMFLOAT3A(const XMFLOAT3A&) = default;
        XMFLOAT3A& operator=(const XMFLOAT3A&) = default;

        XMFLOAT3A(XMFLOAT3A&&) = default;
        XMFLOAT3A& operator=(XMFLOAT3A&&) = default;

        constexpr XMFLOAT3A(float _x, float _y, float _z) noexcept : XMFLOAT3(_x, _y, _z) {}
        explicit XMFLOAT3A(  const float* pArray) noexcept : XMFLOAT3(pArray) {}
    };

    
    
    struct XMINT3
    {
        int32_t x;
        int32_t y;
        int32_t z;

        XMINT3() = default;

        XMINT3(const XMINT3&) = default;
        XMINT3& operator=(const XMINT3&) = default;

        XMINT3(XMINT3&&) = default;
        XMINT3& operator=(XMINT3&&) = default;

        constexpr XMINT3(int32_t _x, int32_t _y, int32_t _z) noexcept : x(_x), y(_y), z(_z) {}
        explicit XMINT3(  const int32_t* pArray) noexcept : x(pArray[0]), y(pArray[1]), z(pArray[2]) {}
    };

    
    struct XMUINT3
    {
        uint32_t x;
        uint32_t y;
        uint32_t z;

        XMUINT3() = default;

        XMUINT3(const XMUINT3&) = default;
        XMUINT3& operator=(const XMUINT3&) = default;

        XMUINT3(XMUINT3&&) = default;
        XMUINT3& operator=(XMUINT3&&) = default;

        constexpr XMUINT3(uint32_t _x, uint32_t _y, uint32_t _z) noexcept : x(_x), y(_y), z(_z) {}
        explicit XMUINT3(  const uint32_t* pArray) noexcept : x(pArray[0]), y(pArray[1]), z(pArray[2]) {}
    };

    
    
    struct XMFLOAT4
    {
        float x;
        float y;
        float z;
        float w;

        XMFLOAT4() = default;

        XMFLOAT4(const XMFLOAT4&) = default;
        XMFLOAT4& operator=(const XMFLOAT4&) = default;

        XMFLOAT4(XMFLOAT4&&) = default;
        XMFLOAT4& operator=(XMFLOAT4&&) = default;

        constexpr XMFLOAT4(float _x, float _y, float _z, float _w) noexcept : x(_x), y(_y), z(_z), w(_w) {}
        explicit XMFLOAT4(  const float* pArray) noexcept : x(pArray[0]), y(pArray[1]), z(pArray[2]), w(pArray[3]) {}
    };

    
    __declspec(align(16)) struct XMFLOAT4A : public XMFLOAT4
    {
        XMFLOAT4A() = default;

        XMFLOAT4A(const XMFLOAT4A&) = default;
        XMFLOAT4A& operator=(const XMFLOAT4A&) = default;

        XMFLOAT4A(XMFLOAT4A&&) = default;
        XMFLOAT4A& operator=(XMFLOAT4A&&) = default;

        constexpr XMFLOAT4A(float _x, float _y, float _z, float _w) noexcept : XMFLOAT4(_x, _y, _z, _w) {}
        explicit XMFLOAT4A(  const float* pArray) noexcept : XMFLOAT4(pArray) {}
    };

    
    
    struct XMINT4
    {
        int32_t x;
        int32_t y;
        int32_t z;
        int32_t w;

        XMINT4() = default;

        XMINT4(const XMINT4&) = default;
        XMINT4& operator=(const XMINT4&) = default;

        XMINT4(XMINT4&&) = default;
        XMINT4& operator=(XMINT4&&) = default;

        constexpr XMINT4(int32_t _x, int32_t _y, int32_t _z, int32_t _w) noexcept : x(_x), y(_y), z(_z), w(_w) {}
        explicit XMINT4(  const int32_t* pArray) noexcept : x(pArray[0]), y(pArray[1]), z(pArray[2]), w(pArray[3]) {}
    };

    
    struct XMUINT4
    {
        uint32_t x;
        uint32_t y;
        uint32_t z;
        uint32_t w;

        XMUINT4() = default;

        XMUINT4(const XMUINT4&) = default;
        XMUINT4& operator=(const XMUINT4&) = default;

        XMUINT4(XMUINT4&&) = default;
        XMUINT4& operator=(XMUINT4&&) = default;

        constexpr XMUINT4(uint32_t _x, uint32_t _y, uint32_t _z, uint32_t _w) noexcept : x(_x), y(_y), z(_z), w(_w) {}
        explicit XMUINT4(  const uint32_t* pArray) noexcept : x(pArray[0]), y(pArray[1]), z(pArray[2]), w(pArray[3]) {}
    };







    
    
    struct XMFLOAT3X3
    {
        union
        {
            struct
            {
                float _11, _12, _13;
                float _21, _22, _23;
                float _31, _32, _33;
            };
            float m[3][3];
        };

        XMFLOAT3X3() = default;

        XMFLOAT3X3(const XMFLOAT3X3&) = default;
        XMFLOAT3X3& operator=(const XMFLOAT3X3&) = default;

        XMFLOAT3X3(XMFLOAT3X3&&) = default;
        XMFLOAT3X3& operator=(XMFLOAT3X3&&) = default;

        constexpr XMFLOAT3X3(float m00, float m01, float m02,
            float m10, float m11, float m12,
            float m20, float m21, float m22) noexcept
            : _11(m00), _12(m01), _13(m02),
            _21(m10), _22(m11), _23(m12),
            _31(m20), _32(m21), _33(m22) {}
        explicit XMFLOAT3X3(  const float* pArray) noexcept;

        float       operator() (size_t Row, size_t Column) const  noexcept { return m[Row][Column]; }
        float& operator() (size_t Row, size_t Column) noexcept { return m[Row][Column]; }
    };

    
    
    struct XMFLOAT4X3
    {
        union
        {
            struct
            {
                float _11, _12, _13;
                float _21, _22, _23;
                float _31, _32, _33;
                float _41, _42, _43;
            };
            float m[4][3];
            float f[12];
        };

        XMFLOAT4X3() = default;

        XMFLOAT4X3(const XMFLOAT4X3&) = default;
        XMFLOAT4X3& operator=(const XMFLOAT4X3&) = default;

        XMFLOAT4X3(XMFLOAT4X3&&) = default;
        XMFLOAT4X3& operator=(XMFLOAT4X3&&) = default;

        constexpr XMFLOAT4X3(float m00, float m01, float m02,
            float m10, float m11, float m12,
            float m20, float m21, float m22,
            float m30, float m31, float m32) noexcept
            : _11(m00), _12(m01), _13(m02),
            _21(m10), _22(m11), _23(m12),
            _31(m20), _32(m21), _33(m22),
            _41(m30), _42(m31), _43(m32) {}
        explicit XMFLOAT4X3(  const float* pArray) noexcept;

        float       operator() (size_t Row, size_t Column) const  noexcept { return m[Row][Column]; }
        float& operator() (size_t Row, size_t Column) noexcept { return m[Row][Column]; }
    };

    
    __declspec(align(16)) struct XMFLOAT4X3A : public XMFLOAT4X3
    {
        XMFLOAT4X3A() = default;

        XMFLOAT4X3A(const XMFLOAT4X3A&) = default;
        XMFLOAT4X3A& operator=(const XMFLOAT4X3A&) = default;

        XMFLOAT4X3A(XMFLOAT4X3A&&) = default;
        XMFLOAT4X3A& operator=(XMFLOAT4X3A&&) = default;

        constexpr XMFLOAT4X3A(float m00, float m01, float m02,
            float m10, float m11, float m12,
            float m20, float m21, float m22,
            float m30, float m31, float m32)  noexcept :
            XMFLOAT4X3(m00, m01, m02, m10, m11, m12, m20, m21, m22, m30, m31, m32) {}
        explicit XMFLOAT4X3A(  const float* pArray)  noexcept : XMFLOAT4X3(pArray) {}
    };

    
    
    struct XMFLOAT3X4
    {
        union
        {
            struct
            {
                float _11, _12, _13, _14;
                float _21, _22, _23, _24;
                float _31, _32, _33, _34;
            };
            float m[3][4];
            float f[12];
        };

        XMFLOAT3X4() = default;

        XMFLOAT3X4(const XMFLOAT3X4&) = default;
        XMFLOAT3X4& operator=(const XMFLOAT3X4&) = default;

        XMFLOAT3X4(XMFLOAT3X4&&) = default;
        XMFLOAT3X4& operator=(XMFLOAT3X4&&) = default;

        constexpr XMFLOAT3X4(float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23) noexcept
            : _11(m00), _12(m01), _13(m02), _14(m03),
            _21(m10), _22(m11), _23(m12), _24(m13),
            _31(m20), _32(m21), _33(m22), _34(m23) {}
        explicit XMFLOAT3X4(  const float* pArray) noexcept;

        float       operator() (size_t Row, size_t Column) const noexcept { return m[Row][Column]; }
        float& operator() (size_t Row, size_t Column) noexcept { return m[Row][Column]; }
    };

    
    __declspec(align(16)) struct XMFLOAT3X4A : public XMFLOAT3X4
    {
        XMFLOAT3X4A() = default;

        XMFLOAT3X4A(const XMFLOAT3X4A&) = default;
        XMFLOAT3X4A& operator=(const XMFLOAT3X4A&) = default;

        XMFLOAT3X4A(XMFLOAT3X4A&&) = default;
        XMFLOAT3X4A& operator=(XMFLOAT3X4A&&) = default;

        constexpr XMFLOAT3X4A(float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23)  noexcept :
            XMFLOAT3X4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23) {}
        explicit XMFLOAT3X4A(  const float* pArray) noexcept : XMFLOAT3X4(pArray) {}
    };

    
    
    struct XMFLOAT4X4
    {
        union
        {
            struct
            {
                float _11, _12, _13, _14;
                float _21, _22, _23, _24;
                float _31, _32, _33, _34;
                float _41, _42, _43, _44;
            };
            float m[4][4];
        };

        XMFLOAT4X4() = default;

        XMFLOAT4X4(const XMFLOAT4X4&) = default;
        XMFLOAT4X4& operator=(const XMFLOAT4X4&) = default;

        XMFLOAT4X4(XMFLOAT4X4&&) = default;
        XMFLOAT4X4& operator=(XMFLOAT4X4&&) = default;

        constexpr XMFLOAT4X4(float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23,
            float m30, float m31, float m32, float m33) noexcept
            : _11(m00), _12(m01), _13(m02), _14(m03),
            _21(m10), _22(m11), _23(m12), _24(m13),
            _31(m20), _32(m21), _33(m22), _34(m23),
            _41(m30), _42(m31), _43(m32), _44(m33) {}
        explicit XMFLOAT4X4(  const float* pArray) noexcept;

        float       operator() (size_t Row, size_t Column) const noexcept { return m[Row][Column]; }
        float& operator() (size_t Row, size_t Column) noexcept { return m[Row][Column]; }
    };

    
    __declspec(align(16)) struct XMFLOAT4X4A : public XMFLOAT4X4
    {
        XMFLOAT4X4A() = default;

        XMFLOAT4X4A(const XMFLOAT4X4A&) = default;
        XMFLOAT4X4A& operator=(const XMFLOAT4X4A&) = default;

        XMFLOAT4X4A(XMFLOAT4X4A&&) = default;
        XMFLOAT4X4A& operator=(XMFLOAT4X4A&&) = default;

        constexpr XMFLOAT4X4A(float m00, float m01, float m02, float m03,
            float m10, float m11, float m12, float m13,
            float m20, float m21, float m22, float m23,
            float m30, float m31, float m32, float m33) noexcept
            : XMFLOAT4X4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {}
        explicit XMFLOAT4X4A(  const float* pArray) noexcept : XMFLOAT4X4(pArray) {}
    };

    









#pragma warning(pop)







    XMVECTOR    __vectorcall     XMConvertVectorIntToFloat(FXMVECTOR VInt, uint32_t DivExponent) noexcept;
    XMVECTOR    __vectorcall     XMConvertVectorFloatToInt(FXMVECTOR VFloat, uint32_t MulExponent) noexcept;
    XMVECTOR    __vectorcall     XMConvertVectorUIntToFloat(FXMVECTOR VUInt, uint32_t DivExponent) noexcept;
    XMVECTOR    __vectorcall     XMConvertVectorFloatToUInt(FXMVECTOR VFloat, uint32_t MulExponent) noexcept;





#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    XMVECTOR    __vectorcall     XMVectorSetBinaryConstant(uint32_t C0, uint32_t C1, uint32_t C2, uint32_t C3) noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatConstant(int32_t IntConstant, uint32_t DivExponent) noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatConstantInt(int32_t IntConstant) noexcept;

    





    XMVECTOR    __vectorcall     XMLoadInt(  const uint32_t* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadFloat(  const float* pSource) noexcept;

    XMVECTOR    __vectorcall     XMLoadInt2(  const uint32_t* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadInt2A(  const uint32_t* PSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadFloat2(  const XMFLOAT2* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadFloat2A(  const XMFLOAT2A* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadSInt2(  const XMINT2* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadUInt2(  const XMUINT2* pSource) noexcept;

    XMVECTOR    __vectorcall     XMLoadInt3(  const uint32_t* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadInt3A(  const uint32_t* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadFloat3(  const XMFLOAT3* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadFloat3A(  const XMFLOAT3A* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadSInt3(  const XMINT3* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadUInt3(  const XMUINT3* pSource) noexcept;

    XMVECTOR    __vectorcall     XMLoadInt4(  const uint32_t* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadInt4A(  const uint32_t* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadFloat4(  const XMFLOAT4* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadFloat4A(  const XMFLOAT4A* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadSInt4(  const XMINT4* pSource) noexcept;
    XMVECTOR    __vectorcall     XMLoadUInt4(  const XMUINT4* pSource) noexcept;

    XMMATRIX    __vectorcall     XMLoadFloat3x3(  const XMFLOAT3X3* pSource) noexcept;
    XMMATRIX    __vectorcall     XMLoadFloat4x3(  const XMFLOAT4X3* pSource) noexcept;
    XMMATRIX    __vectorcall     XMLoadFloat4x3A(  const XMFLOAT4X3A* pSource) noexcept;
    XMMATRIX    __vectorcall     XMLoadFloat3x4(  const XMFLOAT3X4* pSource) noexcept;
    XMMATRIX    __vectorcall     XMLoadFloat3x4A(  const XMFLOAT3X4A* pSource) noexcept;
    XMMATRIX    __vectorcall     XMLoadFloat4x4(  const XMFLOAT4X4* pSource) noexcept;
    XMMATRIX    __vectorcall     XMLoadFloat4x4A(  const XMFLOAT4X4A* pSource) noexcept;

    





    void        __vectorcall     XMStoreInt(  uint32_t* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreFloat(  float* pDestination,   FXMVECTOR V) noexcept;

    void        __vectorcall     XMStoreInt2(  uint32_t* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreInt2A(  uint32_t* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreFloat2(  XMFLOAT2* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreFloat2A(  XMFLOAT2A* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreSInt2(  XMINT2* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreUInt2(  XMUINT2* pDestination,   FXMVECTOR V) noexcept;

    void        __vectorcall     XMStoreInt3(  uint32_t* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreInt3A(  uint32_t* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreFloat3(  XMFLOAT3* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreFloat3A(  XMFLOAT3A* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreSInt3(  XMINT3* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreUInt3(  XMUINT3* pDestination,   FXMVECTOR V) noexcept;

    void        __vectorcall     XMStoreInt4(  uint32_t* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreInt4A(  uint32_t* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreFloat4(  XMFLOAT4* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreFloat4A(  XMFLOAT4A* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreSInt4(  XMINT4* pDestination,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMStoreUInt4(  XMUINT4* pDestination,   FXMVECTOR V) noexcept;

    void        __vectorcall     XMStoreFloat3x3(  XMFLOAT3X3* pDestination,   FXMMATRIX M) noexcept;
    void        __vectorcall     XMStoreFloat4x3(  XMFLOAT4X3* pDestination,   FXMMATRIX M) noexcept;
    void        __vectorcall     XMStoreFloat4x3A(  XMFLOAT4X3A* pDestination,   FXMMATRIX M) noexcept;
    void        __vectorcall     XMStoreFloat3x4(  XMFLOAT3X4* pDestination,   FXMMATRIX M) noexcept;
    void        __vectorcall     XMStoreFloat3x4A(  XMFLOAT3X4A* pDestination,   FXMMATRIX M) noexcept;
    void        __vectorcall     XMStoreFloat4x4(  XMFLOAT4X4* pDestination,   FXMMATRIX M) noexcept;
    void        __vectorcall     XMStoreFloat4x4A(  XMFLOAT4X4A* pDestination,   FXMMATRIX M) noexcept;

    





    XMVECTOR    __vectorcall     XMVectorZero() noexcept;
    XMVECTOR    __vectorcall     XMVectorSet(float x, float y, float z, float w) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetInt(uint32_t x, uint32_t y, uint32_t z, uint32_t w) noexcept;
    XMVECTOR    __vectorcall     XMVectorReplicate(float Value) noexcept;
    XMVECTOR    __vectorcall     XMVectorReplicatePtr(  const float* pValue) noexcept;
    XMVECTOR    __vectorcall     XMVectorReplicateInt(uint32_t Value) noexcept;
    XMVECTOR    __vectorcall     XMVectorReplicateIntPtr(  const uint32_t* pValue) noexcept;
    XMVECTOR    __vectorcall     XMVectorTrueInt() noexcept;
    XMVECTOR    __vectorcall     XMVectorFalseInt() noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatX(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatY(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatZ(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatW(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatOne() noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatInfinity() noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatQNaN() noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatEpsilon() noexcept;
    XMVECTOR    __vectorcall     XMVectorSplatSignMask() noexcept;

    float       __vectorcall     XMVectorGetByIndex(FXMVECTOR V, size_t i) noexcept;
    float       __vectorcall     XMVectorGetX(FXMVECTOR V) noexcept;
    float       __vectorcall     XMVectorGetY(FXMVECTOR V) noexcept;
    float       __vectorcall     XMVectorGetZ(FXMVECTOR V) noexcept;
    float       __vectorcall     XMVectorGetW(FXMVECTOR V) noexcept;

    void        __vectorcall     XMVectorGetByIndexPtr(  float* f,   FXMVECTOR V,   size_t i) noexcept;
    void        __vectorcall     XMVectorGetXPtr(  float* x,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorGetYPtr(  float* y,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorGetZPtr(  float* z,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorGetWPtr(  float* w,   FXMVECTOR V) noexcept;

    uint32_t    __vectorcall     XMVectorGetIntByIndex(FXMVECTOR V, size_t i) noexcept;
    uint32_t    __vectorcall     XMVectorGetIntX(FXMVECTOR V) noexcept;
    uint32_t    __vectorcall     XMVectorGetIntY(FXMVECTOR V) noexcept;
    uint32_t    __vectorcall     XMVectorGetIntZ(FXMVECTOR V) noexcept;
    uint32_t    __vectorcall     XMVectorGetIntW(FXMVECTOR V) noexcept;

    void        __vectorcall     XMVectorGetIntByIndexPtr(  uint32_t* x,   FXMVECTOR V,   size_t i) noexcept;
    void        __vectorcall     XMVectorGetIntXPtr(  uint32_t* x,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorGetIntYPtr(  uint32_t* y,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorGetIntZPtr(  uint32_t* z,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorGetIntWPtr(  uint32_t* w,   FXMVECTOR V) noexcept;

    XMVECTOR    __vectorcall     XMVectorSetByIndex(FXMVECTOR V, float f, size_t i) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetX(FXMVECTOR V, float x) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetY(FXMVECTOR V, float y) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetZ(FXMVECTOR V, float z) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetW(FXMVECTOR V, float w) noexcept;

    XMVECTOR    __vectorcall     XMVectorSetByIndexPtr(  FXMVECTOR V,   const float* f,   size_t i) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetXPtr(  FXMVECTOR V,   const float* x) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetYPtr(  FXMVECTOR V,   const float* y) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetZPtr(  FXMVECTOR V,   const float* z) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetWPtr(  FXMVECTOR V,   const float* w) noexcept;

    XMVECTOR    __vectorcall     XMVectorSetIntByIndex(FXMVECTOR V, uint32_t x, size_t i) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntX(FXMVECTOR V, uint32_t x) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntY(FXMVECTOR V, uint32_t y) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntZ(FXMVECTOR V, uint32_t z) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntW(FXMVECTOR V, uint32_t w) noexcept;

    XMVECTOR    __vectorcall     XMVectorSetIntByIndexPtr(  FXMVECTOR V,   const uint32_t* x,   size_t i) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntXPtr(  FXMVECTOR V,   const uint32_t* x) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntYPtr(  FXMVECTOR V,   const uint32_t* y) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntZPtr(  FXMVECTOR V,   const uint32_t* z) noexcept;
    XMVECTOR    __vectorcall     XMVectorSetIntWPtr(  FXMVECTOR V,   const uint32_t* w) noexcept;



#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    XMVECTOR    __vectorcall     XMVectorSwizzle(FXMVECTOR V, uint32_t E0, uint32_t E1, uint32_t E2, uint32_t E3) noexcept;
    XMVECTOR    __vectorcall     XMVectorPermute(FXMVECTOR V1, FXMVECTOR V2, uint32_t PermuteX, uint32_t PermuteY, uint32_t PermuteZ, uint32_t PermuteW) noexcept;
    XMVECTOR    __vectorcall     XMVectorSelectControl(uint32_t VectorIndex0, uint32_t VectorIndex1, uint32_t VectorIndex2, uint32_t VectorIndex3) noexcept;
    XMVECTOR    __vectorcall     XMVectorSelect(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR Control) noexcept;
    XMVECTOR    __vectorcall     XMVectorMergeXY(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorMergeZW(FXMVECTOR V1, FXMVECTOR V2) noexcept;






#line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    XMVECTOR    __vectorcall     XMVectorShiftLeft(FXMVECTOR V1, FXMVECTOR V2, uint32_t Elements) noexcept;
    XMVECTOR    __vectorcall     XMVectorRotateLeft(FXMVECTOR V, uint32_t Elements) noexcept;
    XMVECTOR    __vectorcall     XMVectorRotateRight(FXMVECTOR V, uint32_t Elements) noexcept;
    XMVECTOR    __vectorcall     XMVectorInsert(FXMVECTOR VD, FXMVECTOR VS, uint32_t VSLeftRotateElements,
        uint32_t Select0, uint32_t Select1, uint32_t Select2, uint32_t Select3) noexcept;

    XMVECTOR    __vectorcall     XMVectorEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorEqualR(  uint32_t* pCR,   FXMVECTOR V1,   FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorEqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorEqualIntR(  uint32_t* pCR,   FXMVECTOR V,   FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorNearEqual(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR Epsilon) noexcept;
    XMVECTOR    __vectorcall     XMVectorNotEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorNotEqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorGreater(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorGreaterR(  uint32_t* pCR,   FXMVECTOR V1,   FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorGreaterOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorGreaterOrEqualR(  uint32_t* pCR,   FXMVECTOR V1,   FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorLess(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorLessOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorInBounds(FXMVECTOR V, FXMVECTOR Bounds) noexcept;
    XMVECTOR    __vectorcall     XMVectorInBoundsR(  uint32_t* pCR,   FXMVECTOR V,   FXMVECTOR Bounds) noexcept;

    XMVECTOR    __vectorcall     XMVectorIsNaN(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorIsInfinite(FXMVECTOR V) noexcept;

    XMVECTOR    __vectorcall     XMVectorMin(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorMax(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorRound(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorTruncate(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorFloor(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorCeiling(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorClamp(FXMVECTOR V, FXMVECTOR Min, FXMVECTOR Max) noexcept;
    XMVECTOR    __vectorcall     XMVectorSaturate(FXMVECTOR V) noexcept;

    XMVECTOR    __vectorcall     XMVectorAndInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorAndCInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorOrInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorNorInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorXorInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;

    XMVECTOR    __vectorcall     XMVectorNegate(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorAdd(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorSum(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorAddAngles(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorSubtract(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorSubtractAngles(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorMultiply(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorMultiplyAdd(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR V3) noexcept;
    XMVECTOR    __vectorcall     XMVectorDivide(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorNegativeMultiplySubtract(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR V3) noexcept;
    XMVECTOR    __vectorcall     XMVectorScale(FXMVECTOR V, float ScaleFactor) noexcept;
    XMVECTOR    __vectorcall     XMVectorReciprocalEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorReciprocal(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSqrtEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSqrt(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorReciprocalSqrtEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorReciprocalSqrt(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorExp2(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorExp10(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorExpE(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorExp(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorLog2(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorLog10(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorLogE(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorLog(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorPow(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorAbs(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorMod(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVectorModAngles(FXMVECTOR Angles) noexcept;
    XMVECTOR    __vectorcall     XMVectorSin(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSinEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorCos(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorCosEst(FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorSinCos(  XMVECTOR* pSin,   XMVECTOR* pCos,   FXMVECTOR V) noexcept;
    void        __vectorcall     XMVectorSinCosEst(  XMVECTOR* pSin,   XMVECTOR* pCos,   FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorTan(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorTanEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorSinH(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorCosH(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorTanH(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorASin(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorASinEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorACos(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorACosEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorATan(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorATanEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVectorATan2(FXMVECTOR Y, FXMVECTOR X) noexcept;
    XMVECTOR    __vectorcall     XMVectorATan2Est(FXMVECTOR Y, FXMVECTOR X) noexcept;
    XMVECTOR    __vectorcall     XMVectorLerp(FXMVECTOR V0, FXMVECTOR V1, float t) noexcept;
    XMVECTOR    __vectorcall     XMVectorLerpV(FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR T) noexcept;
    XMVECTOR    __vectorcall     XMVectorHermite(FXMVECTOR Position0, FXMVECTOR Tangent0, FXMVECTOR Position1, GXMVECTOR Tangent1, float t) noexcept;
    XMVECTOR    __vectorcall     XMVectorHermiteV(FXMVECTOR Position0, FXMVECTOR Tangent0, FXMVECTOR Position1, GXMVECTOR Tangent1, HXMVECTOR T) noexcept;
    XMVECTOR    __vectorcall     XMVectorCatmullRom(FXMVECTOR Position0, FXMVECTOR Position1, FXMVECTOR Position2, GXMVECTOR Position3, float t) noexcept;
    XMVECTOR    __vectorcall     XMVectorCatmullRomV(FXMVECTOR Position0, FXMVECTOR Position1, FXMVECTOR Position2, GXMVECTOR Position3, HXMVECTOR T) noexcept;
    XMVECTOR    __vectorcall     XMVectorBaryCentric(FXMVECTOR Position0, FXMVECTOR Position1, FXMVECTOR Position2, float f, float g) noexcept;
    XMVECTOR    __vectorcall     XMVectorBaryCentricV(FXMVECTOR Position0, FXMVECTOR Position1, FXMVECTOR Position2, GXMVECTOR F, HXMVECTOR G) noexcept;

    





    bool        __vectorcall     XMVector2Equal(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector2EqualR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2EqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector2EqualIntR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2NearEqual(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR Epsilon) noexcept;
    bool        __vectorcall     XMVector2NotEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2NotEqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2Greater(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector2GreaterR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2GreaterOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector2GreaterOrEqualR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2Less(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2LessOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector2InBounds(FXMVECTOR V, FXMVECTOR Bounds) noexcept;

    bool        __vectorcall     XMVector2IsNaN(FXMVECTOR V) noexcept;
    bool        __vectorcall     XMVector2IsInfinite(FXMVECTOR V) noexcept;

    XMVECTOR    __vectorcall     XMVector2Dot(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector2Cross(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector2LengthSq(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2ReciprocalLengthEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2ReciprocalLength(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2LengthEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2Length(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2NormalizeEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2Normalize(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2ClampLength(FXMVECTOR V, float LengthMin, float LengthMax) noexcept;
    XMVECTOR    __vectorcall     XMVector2ClampLengthV(FXMVECTOR V, FXMVECTOR LengthMin, FXMVECTOR LengthMax) noexcept;
    XMVECTOR    __vectorcall     XMVector2Reflect(FXMVECTOR Incident, FXMVECTOR Normal) noexcept;
    XMVECTOR    __vectorcall     XMVector2Refract(FXMVECTOR Incident, FXMVECTOR Normal, float RefractionIndex) noexcept;
    XMVECTOR    __vectorcall     XMVector2RefractV(FXMVECTOR Incident, FXMVECTOR Normal, FXMVECTOR RefractionIndex) noexcept;
    XMVECTOR    __vectorcall     XMVector2Orthogonal(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector2AngleBetweenNormalsEst(FXMVECTOR N1, FXMVECTOR N2) noexcept;
    XMVECTOR    __vectorcall     XMVector2AngleBetweenNormals(FXMVECTOR N1, FXMVECTOR N2) noexcept;
    XMVECTOR    __vectorcall     XMVector2AngleBetweenVectors(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector2LinePointDistance(FXMVECTOR LinePoint1, FXMVECTOR LinePoint2, FXMVECTOR Point) noexcept;
    XMVECTOR    __vectorcall     XMVector2IntersectLine(FXMVECTOR Line1Point1, FXMVECTOR Line1Point2, FXMVECTOR Line2Point1, GXMVECTOR Line2Point2) noexcept;
    XMVECTOR    __vectorcall     XMVector2Transform(FXMVECTOR V, FXMMATRIX M) noexcept;
    XMFLOAT4* __vectorcall     XMVector2TransformStream(  XMFLOAT4* pOutputStream,
          size_t OutputStride,
          const XMFLOAT2* pInputStream,
          size_t InputStride,   size_t VectorCount,   FXMMATRIX M) noexcept;
    XMVECTOR    __vectorcall     XMVector2TransformCoord(FXMVECTOR V, FXMMATRIX M) noexcept;
    XMFLOAT2* __vectorcall     XMVector2TransformCoordStream(  XMFLOAT2* pOutputStream,
          size_t OutputStride,
          const XMFLOAT2* pInputStream,
          size_t InputStride,   size_t VectorCount,   FXMMATRIX M) noexcept;
    XMVECTOR    __vectorcall     XMVector2TransformNormal(FXMVECTOR V, FXMMATRIX M) noexcept;
    XMFLOAT2* __vectorcall     XMVector2TransformNormalStream(  XMFLOAT2* pOutputStream,
          size_t OutputStride,
          const XMFLOAT2* pInputStream,
          size_t InputStride,   size_t VectorCount,   FXMMATRIX M) noexcept;

    





    bool        __vectorcall     XMVector3Equal(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector3EqualR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3EqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector3EqualIntR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3NearEqual(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR Epsilon) noexcept;
    bool        __vectorcall     XMVector3NotEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3NotEqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3Greater(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector3GreaterR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3GreaterOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector3GreaterOrEqualR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3Less(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3LessOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector3InBounds(FXMVECTOR V, FXMVECTOR Bounds) noexcept;

    bool        __vectorcall     XMVector3IsNaN(FXMVECTOR V) noexcept;
    bool        __vectorcall     XMVector3IsInfinite(FXMVECTOR V) noexcept;

    XMVECTOR    __vectorcall     XMVector3Dot(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector3Cross(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector3LengthSq(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3ReciprocalLengthEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3ReciprocalLength(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3LengthEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3Length(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3NormalizeEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3Normalize(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3ClampLength(FXMVECTOR V, float LengthMin, float LengthMax) noexcept;
    XMVECTOR    __vectorcall     XMVector3ClampLengthV(FXMVECTOR V, FXMVECTOR LengthMin, FXMVECTOR LengthMax) noexcept;
    XMVECTOR    __vectorcall     XMVector3Reflect(FXMVECTOR Incident, FXMVECTOR Normal) noexcept;
    XMVECTOR    __vectorcall     XMVector3Refract(FXMVECTOR Incident, FXMVECTOR Normal, float RefractionIndex) noexcept;
    XMVECTOR    __vectorcall     XMVector3RefractV(FXMVECTOR Incident, FXMVECTOR Normal, FXMVECTOR RefractionIndex) noexcept;
    XMVECTOR    __vectorcall     XMVector3Orthogonal(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector3AngleBetweenNormalsEst(FXMVECTOR N1, FXMVECTOR N2) noexcept;
    XMVECTOR    __vectorcall     XMVector3AngleBetweenNormals(FXMVECTOR N1, FXMVECTOR N2) noexcept;
    XMVECTOR    __vectorcall     XMVector3AngleBetweenVectors(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector3LinePointDistance(FXMVECTOR LinePoint1, FXMVECTOR LinePoint2, FXMVECTOR Point) noexcept;
    void        __vectorcall     XMVector3ComponentsFromNormal(  XMVECTOR* pParallel,   XMVECTOR* pPerpendicular,   FXMVECTOR V,   FXMVECTOR Normal) noexcept;
    XMVECTOR    __vectorcall     XMVector3Rotate(FXMVECTOR V, FXMVECTOR RotationQuaternion) noexcept;
    XMVECTOR    __vectorcall     XMVector3InverseRotate(FXMVECTOR V, FXMVECTOR RotationQuaternion) noexcept;
    XMVECTOR    __vectorcall     XMVector3Transform(FXMVECTOR V, FXMMATRIX M) noexcept;
    XMFLOAT4* __vectorcall     XMVector3TransformStream(  XMFLOAT4* pOutputStream,
          size_t OutputStride,
          const XMFLOAT3* pInputStream,
          size_t InputStride,   size_t VectorCount,   FXMMATRIX M) noexcept;
    XMVECTOR    __vectorcall     XMVector3TransformCoord(FXMVECTOR V, FXMMATRIX M) noexcept;
    XMFLOAT3* __vectorcall     XMVector3TransformCoordStream(  XMFLOAT3* pOutputStream,
          size_t OutputStride,
          const XMFLOAT3* pInputStream,
          size_t InputStride,   size_t VectorCount,   FXMMATRIX M) noexcept;
    XMVECTOR    __vectorcall     XMVector3TransformNormal(FXMVECTOR V, FXMMATRIX M) noexcept;
    XMFLOAT3* __vectorcall     XMVector3TransformNormalStream(  XMFLOAT3* pOutputStream,
          size_t OutputStride,
          const XMFLOAT3* pInputStream,
          size_t InputStride,   size_t VectorCount,   FXMMATRIX M) noexcept;
    XMVECTOR    __vectorcall     XMVector3Project(FXMVECTOR V, float ViewportX, float ViewportY, float ViewportWidth, float ViewportHeight, float ViewportMinZ, float ViewportMaxZ,
        FXMMATRIX Projection, CXMMATRIX View, CXMMATRIX World) noexcept;
    XMFLOAT3* __vectorcall     XMVector3ProjectStream(  XMFLOAT3* pOutputStream,
          size_t OutputStride,
          const XMFLOAT3* pInputStream,
          size_t InputStride,   size_t VectorCount,
          float ViewportX,   float ViewportY,   float ViewportWidth,   float ViewportHeight,   float ViewportMinZ,   float ViewportMaxZ,
          FXMMATRIX Projection,   CXMMATRIX View,   CXMMATRIX World) noexcept;
    XMVECTOR    __vectorcall     XMVector3Unproject(FXMVECTOR V, float ViewportX, float ViewportY, float ViewportWidth, float ViewportHeight, float ViewportMinZ, float ViewportMaxZ,
        FXMMATRIX Projection, CXMMATRIX View, CXMMATRIX World) noexcept;
    XMFLOAT3* __vectorcall     XMVector3UnprojectStream(  XMFLOAT3* pOutputStream,
          size_t OutputStride,
          const XMFLOAT3* pInputStream,
          size_t InputStride,   size_t VectorCount,
          float ViewportX,   float ViewportY,   float ViewportWidth,   float ViewportHeight,   float ViewportMinZ,   float ViewportMaxZ,
          FXMMATRIX Projection,   CXMMATRIX View,   CXMMATRIX World) noexcept;

    





    bool        __vectorcall     XMVector4Equal(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector4EqualR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4EqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector4EqualIntR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4NearEqual(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR Epsilon) noexcept;
    bool        __vectorcall     XMVector4NotEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4NotEqualInt(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4Greater(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector4GreaterR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4GreaterOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    uint32_t    __vectorcall     XMVector4GreaterOrEqualR(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4Less(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4LessOrEqual(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    bool        __vectorcall     XMVector4InBounds(FXMVECTOR V, FXMVECTOR Bounds) noexcept;

    bool        __vectorcall     XMVector4IsNaN(FXMVECTOR V) noexcept;
    bool        __vectorcall     XMVector4IsInfinite(FXMVECTOR V) noexcept;

    XMVECTOR    __vectorcall     XMVector4Dot(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector4Cross(FXMVECTOR V1, FXMVECTOR V2, FXMVECTOR V3) noexcept;
    XMVECTOR    __vectorcall     XMVector4LengthSq(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4ReciprocalLengthEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4ReciprocalLength(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4LengthEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4Length(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4NormalizeEst(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4Normalize(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4ClampLength(FXMVECTOR V, float LengthMin, float LengthMax) noexcept;
    XMVECTOR    __vectorcall     XMVector4ClampLengthV(FXMVECTOR V, FXMVECTOR LengthMin, FXMVECTOR LengthMax) noexcept;
    XMVECTOR    __vectorcall     XMVector4Reflect(FXMVECTOR Incident, FXMVECTOR Normal) noexcept;
    XMVECTOR    __vectorcall     XMVector4Refract(FXMVECTOR Incident, FXMVECTOR Normal, float RefractionIndex) noexcept;
    XMVECTOR    __vectorcall     XMVector4RefractV(FXMVECTOR Incident, FXMVECTOR Normal, FXMVECTOR RefractionIndex) noexcept;
    XMVECTOR    __vectorcall     XMVector4Orthogonal(FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMVector4AngleBetweenNormalsEst(FXMVECTOR N1, FXMVECTOR N2) noexcept;
    XMVECTOR    __vectorcall     XMVector4AngleBetweenNormals(FXMVECTOR N1, FXMVECTOR N2) noexcept;
    XMVECTOR    __vectorcall     XMVector4AngleBetweenVectors(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMVector4Transform(FXMVECTOR V, FXMMATRIX M) noexcept;
    XMFLOAT4* __vectorcall     XMVector4TransformStream(  XMFLOAT4* pOutputStream,
          size_t OutputStride,
          const XMFLOAT4* pInputStream,
          size_t InputStride,   size_t VectorCount,   FXMMATRIX M) noexcept;

    





    bool        __vectorcall     XMMatrixIsNaN(FXMMATRIX M) noexcept;
    bool        __vectorcall     XMMatrixIsInfinite(FXMMATRIX M) noexcept;
    bool        __vectorcall     XMMatrixIsIdentity(FXMMATRIX M) noexcept;

    XMMATRIX    __vectorcall     XMMatrixMultiply(FXMMATRIX M1, CXMMATRIX M2) noexcept;
    XMMATRIX    __vectorcall     XMMatrixMultiplyTranspose(FXMMATRIX M1, CXMMATRIX M2) noexcept;
    XMMATRIX    __vectorcall     XMMatrixTranspose(FXMMATRIX M) noexcept;
    XMMATRIX    __vectorcall     XMMatrixInverse(  XMVECTOR* pDeterminant,   FXMMATRIX M) noexcept;
    XMMATRIX    __vectorcall     XMMatrixVectorTensorProduct(FXMVECTOR V1, FXMVECTOR V2) noexcept;
    XMVECTOR    __vectorcall     XMMatrixDeterminant(FXMMATRIX M) noexcept;

     
    bool        __vectorcall     XMMatrixDecompose(  XMVECTOR* outScale,   XMVECTOR* outRotQuat,   XMVECTOR* outTrans,   FXMMATRIX M) noexcept;

    XMMATRIX    __vectorcall     XMMatrixIdentity() noexcept;
    XMMATRIX    __vectorcall     XMMatrixSet(float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33) noexcept;
    XMMATRIX    __vectorcall     XMMatrixTranslation(float OffsetX, float OffsetY, float OffsetZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixTranslationFromVector(FXMVECTOR Offset) noexcept;
    XMMATRIX    __vectorcall     XMMatrixScaling(float ScaleX, float ScaleY, float ScaleZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixScalingFromVector(FXMVECTOR Scale) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationX(float Angle) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationY(float Angle) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationZ(float Angle) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationRollPitchYaw(float Pitch, float Yaw, float Roll) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationRollPitchYawFromVector(FXMVECTOR Angles) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationNormal(FXMVECTOR NormalAxis, float Angle) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationAxis(FXMVECTOR Axis, float Angle) noexcept;
    XMMATRIX    __vectorcall     XMMatrixRotationQuaternion(FXMVECTOR Quaternion) noexcept;
    XMMATRIX    __vectorcall     XMMatrixTransformation2D(FXMVECTOR ScalingOrigin, float ScalingOrientation, FXMVECTOR Scaling,
        FXMVECTOR RotationOrigin, float Rotation, GXMVECTOR Translation) noexcept;
    XMMATRIX    __vectorcall     XMMatrixTransformation(FXMVECTOR ScalingOrigin, FXMVECTOR ScalingOrientationQuaternion, FXMVECTOR Scaling,
        GXMVECTOR RotationOrigin, HXMVECTOR RotationQuaternion, HXMVECTOR Translation) noexcept;
    XMMATRIX    __vectorcall     XMMatrixAffineTransformation2D(FXMVECTOR Scaling, FXMVECTOR RotationOrigin, float Rotation, FXMVECTOR Translation) noexcept;
    XMMATRIX    __vectorcall     XMMatrixAffineTransformation(FXMVECTOR Scaling, FXMVECTOR RotationOrigin, FXMVECTOR RotationQuaternion, GXMVECTOR Translation) noexcept;
    XMMATRIX    __vectorcall     XMMatrixReflect(FXMVECTOR ReflectionPlane) noexcept;
    XMMATRIX    __vectorcall     XMMatrixShadow(FXMVECTOR ShadowPlane, FXMVECTOR LightPosition) noexcept;

    XMMATRIX    __vectorcall     XMMatrixLookAtLH(FXMVECTOR EyePosition, FXMVECTOR FocusPosition, FXMVECTOR UpDirection) noexcept;
    XMMATRIX    __vectorcall     XMMatrixLookAtRH(FXMVECTOR EyePosition, FXMVECTOR FocusPosition, FXMVECTOR UpDirection) noexcept;
    XMMATRIX    __vectorcall     XMMatrixLookToLH(FXMVECTOR EyePosition, FXMVECTOR EyeDirection, FXMVECTOR UpDirection) noexcept;
    XMMATRIX    __vectorcall     XMMatrixLookToRH(FXMVECTOR EyePosition, FXMVECTOR EyeDirection, FXMVECTOR UpDirection) noexcept;
    XMMATRIX    __vectorcall     XMMatrixPerspectiveLH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixPerspectiveRH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixPerspectiveFovLH(float FovAngleY, float AspectRatio, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixPerspectiveFovRH(float FovAngleY, float AspectRatio, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixPerspectiveOffCenterLH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixPerspectiveOffCenterRH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixOrthographicLH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixOrthographicRH(float ViewWidth, float ViewHeight, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixOrthographicOffCenterLH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop, float NearZ, float FarZ) noexcept;
    XMMATRIX    __vectorcall     XMMatrixOrthographicOffCenterRH(float ViewLeft, float ViewRight, float ViewBottom, float ViewTop, float NearZ, float FarZ) noexcept;


    





    bool        __vectorcall     XMQuaternionEqual(FXMVECTOR Q1, FXMVECTOR Q2) noexcept;
    bool        __vectorcall     XMQuaternionNotEqual(FXMVECTOR Q1, FXMVECTOR Q2) noexcept;

    bool        __vectorcall     XMQuaternionIsNaN(FXMVECTOR Q) noexcept;
    bool        __vectorcall     XMQuaternionIsInfinite(FXMVECTOR Q) noexcept;
    bool        __vectorcall     XMQuaternionIsIdentity(FXMVECTOR Q) noexcept;

    XMVECTOR    __vectorcall     XMQuaternionDot(FXMVECTOR Q1, FXMVECTOR Q2) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionMultiply(FXMVECTOR Q1, FXMVECTOR Q2) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionLengthSq(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionReciprocalLength(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionLength(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionNormalizeEst(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionNormalize(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionConjugate(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionInverse(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionLn(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionExp(FXMVECTOR Q) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionSlerp(FXMVECTOR Q0, FXMVECTOR Q1, float t) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionSlerpV(FXMVECTOR Q0, FXMVECTOR Q1, FXMVECTOR T) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionSquad(FXMVECTOR Q0, FXMVECTOR Q1, FXMVECTOR Q2, GXMVECTOR Q3, float t) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionSquadV(FXMVECTOR Q0, FXMVECTOR Q1, FXMVECTOR Q2, GXMVECTOR Q3, HXMVECTOR T) noexcept;
    void        __vectorcall     XMQuaternionSquadSetup(  XMVECTOR* pA,   XMVECTOR* pB,   XMVECTOR* pC,   FXMVECTOR Q0,   FXMVECTOR Q1,   FXMVECTOR Q2,   GXMVECTOR Q3) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionBaryCentric(FXMVECTOR Q0, FXMVECTOR Q1, FXMVECTOR Q2, float f, float g) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionBaryCentricV(FXMVECTOR Q0, FXMVECTOR Q1, FXMVECTOR Q2, GXMVECTOR F, HXMVECTOR G) noexcept;

    XMVECTOR    __vectorcall     XMQuaternionIdentity() noexcept;
    XMVECTOR    __vectorcall     XMQuaternionRotationRollPitchYaw(float Pitch, float Yaw, float Roll) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionRotationRollPitchYawFromVector(FXMVECTOR Angles) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionRotationNormal(FXMVECTOR NormalAxis, float Angle) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionRotationAxis(FXMVECTOR Axis, float Angle) noexcept;
    XMVECTOR    __vectorcall     XMQuaternionRotationMatrix(FXMMATRIX M) noexcept;

    void        __vectorcall     XMQuaternionToAxisAngle(  XMVECTOR* pAxis,   float* pAngle,   FXMVECTOR Q) noexcept;

    





    bool        __vectorcall     XMPlaneEqual(FXMVECTOR P1, FXMVECTOR P2) noexcept;
    bool        __vectorcall     XMPlaneNearEqual(FXMVECTOR P1, FXMVECTOR P2, FXMVECTOR Epsilon) noexcept;
    bool        __vectorcall     XMPlaneNotEqual(FXMVECTOR P1, FXMVECTOR P2) noexcept;

    bool        __vectorcall     XMPlaneIsNaN(FXMVECTOR P) noexcept;
    bool        __vectorcall     XMPlaneIsInfinite(FXMVECTOR P) noexcept;

    XMVECTOR    __vectorcall     XMPlaneDot(FXMVECTOR P, FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMPlaneDotCoord(FXMVECTOR P, FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMPlaneDotNormal(FXMVECTOR P, FXMVECTOR V) noexcept;
    XMVECTOR    __vectorcall     XMPlaneNormalizeEst(FXMVECTOR P) noexcept;
    XMVECTOR    __vectorcall     XMPlaneNormalize(FXMVECTOR P) noexcept;
    XMVECTOR    __vectorcall     XMPlaneIntersectLine(FXMVECTOR P, FXMVECTOR LinePoint1, FXMVECTOR LinePoint2) noexcept;
    void        __vectorcall     XMPlaneIntersectPlane(  XMVECTOR* pLinePoint1,   XMVECTOR* pLinePoint2,   FXMVECTOR P1,   FXMVECTOR P2) noexcept;
    XMVECTOR    __vectorcall     XMPlaneTransform(FXMVECTOR P, FXMMATRIX M) noexcept;
    XMFLOAT4* __vectorcall     XMPlaneTransformStream(  XMFLOAT4* pOutputStream,
          size_t OutputStride,
          const XMFLOAT4* pInputStream,
          size_t InputStride,   size_t PlaneCount,   FXMMATRIX M) noexcept;

    XMVECTOR    __vectorcall     XMPlaneFromPointNormal(FXMVECTOR Point, FXMVECTOR Normal) noexcept;
    XMVECTOR    __vectorcall     XMPlaneFromPoints(FXMVECTOR Point1, FXMVECTOR Point2, FXMVECTOR Point3) noexcept;

    





    bool        __vectorcall     XMColorEqual(FXMVECTOR C1, FXMVECTOR C2) noexcept;
    bool        __vectorcall     XMColorNotEqual(FXMVECTOR C1, FXMVECTOR C2) noexcept;
    bool        __vectorcall     XMColorGreater(FXMVECTOR C1, FXMVECTOR C2) noexcept;
    bool        __vectorcall     XMColorGreaterOrEqual(FXMVECTOR C1, FXMVECTOR C2) noexcept;
    bool        __vectorcall     XMColorLess(FXMVECTOR C1, FXMVECTOR C2) noexcept;
    bool        __vectorcall     XMColorLessOrEqual(FXMVECTOR C1, FXMVECTOR C2) noexcept;

    bool        __vectorcall     XMColorIsNaN(FXMVECTOR C) noexcept;
    bool        __vectorcall     XMColorIsInfinite(FXMVECTOR C) noexcept;

    XMVECTOR    __vectorcall     XMColorNegative(FXMVECTOR C) noexcept;
    XMVECTOR    __vectorcall     XMColorModulate(FXMVECTOR C1, FXMVECTOR C2) noexcept;
    XMVECTOR    __vectorcall     XMColorAdjustSaturation(FXMVECTOR C, float Saturation) noexcept;
    XMVECTOR    __vectorcall     XMColorAdjustContrast(FXMVECTOR C, float Contrast) noexcept;

    XMVECTOR    __vectorcall     XMColorRGBToHSL(FXMVECTOR rgb) noexcept;
    XMVECTOR    __vectorcall     XMColorHSLToRGB(FXMVECTOR hsl) noexcept;

    XMVECTOR    __vectorcall     XMColorRGBToHSV(FXMVECTOR rgb) noexcept;
    XMVECTOR    __vectorcall     XMColorHSVToRGB(FXMVECTOR hsv) noexcept;

    XMVECTOR    __vectorcall     XMColorRGBToYUV(FXMVECTOR rgb) noexcept;
    XMVECTOR    __vectorcall     XMColorYUVToRGB(FXMVECTOR yuv) noexcept;

    XMVECTOR    __vectorcall     XMColorRGBToYUV_HD(FXMVECTOR rgb) noexcept;
    XMVECTOR    __vectorcall     XMColorYUVToRGB_HD(FXMVECTOR yuv) noexcept;

    XMVECTOR    __vectorcall     XMColorRGBToYUV_UHD(FXMVECTOR rgb) noexcept;
    XMVECTOR    __vectorcall     XMColorYUVToRGB_UHD(FXMVECTOR yuv) noexcept;

    XMVECTOR    __vectorcall     XMColorRGBToXYZ(FXMVECTOR rgb) noexcept;
    XMVECTOR    __vectorcall     XMColorXYZToRGB(FXMVECTOR xyz) noexcept;

    XMVECTOR    __vectorcall     XMColorXYZToSRGB(FXMVECTOR xyz) noexcept;
    XMVECTOR    __vectorcall     XMColorSRGBToXYZ(FXMVECTOR srgb) noexcept;

    XMVECTOR    __vectorcall     XMColorRGBToSRGB(FXMVECTOR rgb) noexcept;
    XMVECTOR    __vectorcall     XMColorSRGBToRGB(FXMVECTOR srgb) noexcept;


    





    bool            XMVerifyCPUSupport() noexcept;

    XMVECTOR    __vectorcall     XMFresnelTerm(FXMVECTOR CosIncidentAngle, FXMVECTOR RefractionIndex) noexcept;

    bool            XMScalarNearEqual(float S1, float S2, float Epsilon) noexcept;
    float           XMScalarModAngle(float Value) noexcept;

    float           XMScalarSin(float Value) noexcept;
    float           XMScalarSinEst(float Value) noexcept;

    float           XMScalarCos(float Value) noexcept;
    float           XMScalarCosEst(float Value) noexcept;

    void            XMScalarSinCos(  float* pSin,   float* pCos, float Value) noexcept;
    void            XMScalarSinCosEst(  float* pSin,   float* pCos, float Value) noexcept;

    float           XMScalarASin(float Value) noexcept;
    float           XMScalarASinEst(float Value) noexcept;

    float           XMScalarACos(float Value) noexcept;
    float           XMScalarACosEst(float Value) noexcept;

    








#line 1684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    template<class T> inline T XMMin(T a, T b) noexcept { return (a < b) ? a : b; }
    template<class T> inline T XMMax(T a, T b) noexcept { return (a > b) ? a : b; }

    




    namespace Internal
    {
        
        template<uint32_t Shuffle, bool WhichX, bool WhichY, bool WhichZ, bool WhichW> struct PermuteHelper
        {
            static XMVECTOR     __vectorcall     Permute(FXMVECTOR v1, FXMVECTOR v2) noexcept
            {
                static const XMVECTORU32 selectMask =
                { { {
                        WhichX ? 0xFFFFFFFF : 0,
                        WhichY ? 0xFFFFFFFF : 0,
                        WhichZ ? 0xFFFFFFFF : 0,
                        WhichW ? 0xFFFFFFFF : 0,
                } } };

                XMVECTOR shuffled1 = _mm_shuffle_ps((v1), (v1), Shuffle );
                XMVECTOR shuffled2 = _mm_shuffle_ps((v2), (v2), Shuffle );

                XMVECTOR masked1 = _mm_andnot_ps(selectMask, shuffled1);
                XMVECTOR masked2 = _mm_and_ps(selectMask, shuffled2);

                return _mm_or_ps(masked1, masked2);
            }
        };

        
        template<uint32_t Shuffle> struct PermuteHelper<Shuffle, false, false, false, false>
        {
            static XMVECTOR     __vectorcall     Permute(FXMVECTOR v1, FXMVECTOR) noexcept { return _mm_shuffle_ps((v1), (v1), Shuffle ); }
        };

        
        template<uint32_t Shuffle> struct PermuteHelper<Shuffle, true, true, true, true>
        {
            static XMVECTOR     __vectorcall     Permute(FXMVECTOR, FXMVECTOR v2) noexcept { return _mm_shuffle_ps((v2), (v2), Shuffle ); }
        };

        
        template<uint32_t Shuffle> struct PermuteHelper<Shuffle, false, false, true, true>
        {
            static XMVECTOR     __vectorcall     Permute(FXMVECTOR v1, FXMVECTOR v2) noexcept { return _mm_shuffle_ps(v1, v2, Shuffle); }
        };

        
        template<uint32_t Shuffle> struct PermuteHelper<Shuffle, true, true, false, false>
        {
            static XMVECTOR     __vectorcall     Permute(FXMVECTOR v1, FXMVECTOR v2) noexcept { return _mm_shuffle_ps(v2, v1, Shuffle); }
        };
    }

#line 1744 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    
    template<uint32_t PermuteX, uint32_t PermuteY, uint32_t PermuteZ, uint32_t PermuteW>
    inline XMVECTOR     __vectorcall     XMVectorPermute(FXMVECTOR V1, FXMVECTOR V2) noexcept
    {
        static_assert(PermuteX <= 7, "PermuteX template parameter out of range");
        static_assert(PermuteY <= 7, "PermuteY template parameter out of range");
        static_assert(PermuteZ <= 7, "PermuteZ template parameter out of range");
        static_assert(PermuteW <= 7, "PermuteW template parameter out of range");


        constexpr uint32_t Shuffle = (((PermuteW & 3) << 6) | ((PermuteZ & 3) << 4) | ((PermuteY & 3) << 2) | ((PermuteX & 3)));

        constexpr bool WhichX = PermuteX > 3;
        constexpr bool WhichY = PermuteY > 3;
        constexpr bool WhichZ = PermuteZ > 3;
        constexpr bool WhichW = PermuteW > 3;

        return Internal::PermuteHelper<Shuffle, WhichX, WhichY, WhichZ, WhichW>::Permute(V1, V2);




#line 1768 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    }

    
    template<> inline constexpr XMVECTOR __vectorcall     XMVectorPermute<0, 1, 2, 3>(FXMVECTOR V1, FXMVECTOR) noexcept { return V1; }
    template<> inline constexpr XMVECTOR __vectorcall     XMVectorPermute<4, 5, 6, 7>(FXMVECTOR, FXMVECTOR V2) noexcept { return V2; }


    template<> inline XMVECTOR      __vectorcall     XMVectorPermute<0, 1, 4, 5>(FXMVECTOR V1, FXMVECTOR V2) noexcept { return _mm_movelh_ps(V1, V2); }
    template<> inline XMVECTOR      __vectorcall     XMVectorPermute<6, 7, 2, 3>(FXMVECTOR V1, FXMVECTOR V2) noexcept { return _mm_movehl_ps(V1, V2); }
    template<> inline XMVECTOR      __vectorcall     XMVectorPermute<0, 4, 1, 5>(FXMVECTOR V1, FXMVECTOR V2) noexcept { return _mm_unpacklo_ps(V1, V2); }
    template<> inline XMVECTOR      __vectorcall     XMVectorPermute<2, 6, 3, 7>(FXMVECTOR V1, FXMVECTOR V2) noexcept { return _mm_unpackhi_ps(V1, V2); }
    template<> inline XMVECTOR      __vectorcall     XMVectorPermute<2, 3, 6, 7>(FXMVECTOR V1, FXMVECTOR V2) noexcept { return _mm_castpd_ps(_mm_unpackhi_pd(_mm_castps_pd(V1), _mm_castps_pd(V2))); }
#line 1781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
















#line 1798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"







































#line 1838 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    

    
    template<uint32_t SwizzleX, uint32_t SwizzleY, uint32_t SwizzleZ, uint32_t SwizzleW>
    inline XMVECTOR     __vectorcall     XMVectorSwizzle(FXMVECTOR V) noexcept
    {
        static_assert(SwizzleX <= 3, "SwizzleX template parameter out of range");
        static_assert(SwizzleY <= 3, "SwizzleY template parameter out of range");
        static_assert(SwizzleZ <= 3, "SwizzleZ template parameter out of range");
        static_assert(SwizzleW <= 3, "SwizzleW template parameter out of range");


        return _mm_shuffle_ps((V), (V), (((SwizzleW) << 6) | ((SwizzleZ) << 4) | ((SwizzleY) << 2) | ((SwizzleX))) );




#line 1857 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    }

    
    template<> inline constexpr XMVECTOR __vectorcall XMVectorSwizzle<0, 1, 2, 3>(FXMVECTOR V) noexcept { return V; }


    template<> inline XMVECTOR      __vectorcall     XMVectorSwizzle<0, 1, 0, 1>(FXMVECTOR V) noexcept { return _mm_movelh_ps(V, V); }
    template<> inline XMVECTOR      __vectorcall     XMVectorSwizzle<2, 3, 2, 3>(FXMVECTOR V) noexcept { return _mm_movehl_ps(V, V); }
    template<> inline XMVECTOR      __vectorcall     XMVectorSwizzle<0, 0, 1, 1>(FXMVECTOR V) noexcept { return _mm_unpacklo_ps(V, V); }
    template<> inline XMVECTOR      __vectorcall     XMVectorSwizzle<2, 2, 3, 3>(FXMVECTOR V) noexcept { return _mm_unpackhi_ps(V, V); }
#line 1868 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"




#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"



#line 1877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"


































#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    

    template<uint32_t Elements>
    inline XMVECTOR     __vectorcall     XMVectorShiftLeft(FXMVECTOR V1, FXMVECTOR V2) noexcept
    {
        static_assert(Elements < 4, "Elements template parameter out of range");
        return XMVectorPermute<Elements, (Elements + 1), (Elements + 2), (Elements + 3)>(V1, V2);
    }

    template<uint32_t Elements>
    inline XMVECTOR     __vectorcall     XMVectorRotateLeft(FXMVECTOR V) noexcept
    {
        static_assert(Elements < 4, "Elements template parameter out of range");
        return XMVectorSwizzle<Elements & 3, (Elements + 1) & 3, (Elements + 2) & 3, (Elements + 3) & 3>(V);
    }

    template<uint32_t Elements>
    inline XMVECTOR     __vectorcall     XMVectorRotateRight(FXMVECTOR V) noexcept
    {
        static_assert(Elements < 4, "Elements template parameter out of range");
        return XMVectorSwizzle<(4 - Elements) & 3, (5 - Elements) & 3, (6 - Elements) & 3, (7 - Elements) & 3>(V);
    }

    template<uint32_t VSLeftRotateElements, uint32_t Select0, uint32_t Select1, uint32_t Select2, uint32_t Select3>
    inline XMVECTOR     __vectorcall     XMVectorInsert(FXMVECTOR VD, FXMVECTOR VS) noexcept
    {
        XMVECTOR Control = XMVectorSelectControl(Select0 & 1, Select1 & 1, Select2 & 1, Select3 & 1);
        return XMVectorSelect(VD, XMVectorRotateLeft<VSLeftRotateElements>(VS), Control);
    }

    





     
     
     
     
     
     
     




#line 1961 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

#line 1963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#line 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"

    extern const __declspec(selectany) XMVECTORF32 g_XMSinCoefficients0 = { { { -0.16666667f, +0.0083333310f, -0.00019840874f, +2.7525562e-06f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMSinCoefficients1 = { { { -2.3889859e-08f, -0.16665852f , +0.0083139502f , -0.00018524670f  } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMCosCoefficients0 = { { { -0.5f, +0.041666638f, -0.0013888378f, +2.4760495e-05f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMCosCoefficients1 = { { { -2.6051615e-07f, -0.49992746f , +0.041493919f , -0.0012712436f  } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMTanCoefficients0 = { { { 1.0f, 0.333333333f, 0.133333333f, 5.396825397e-2f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMTanCoefficients1 = { { { 2.186948854e-2f, 8.863235530e-3f, 3.592128167e-3f, 1.455834485e-3f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMTanCoefficients2 = { { { 5.900274264e-4f, 2.391290764e-4f, 9.691537707e-5f, 3.927832950e-5f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMArcCoefficients0 = { { { +1.5707963050f, -0.2145988016f, +0.0889789874f, -0.0501743046f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMArcCoefficients1 = { { { +0.0308918810f, -0.0170881256f, +0.0066700901f, -0.0012624911f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMATanCoefficients0 = { { { -0.3333314528f, +0.1999355085f, -0.1420889944f, +0.1065626393f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMATanCoefficients1 = { { { -0.0752896400f, +0.0429096138f, -0.0161657367f, +0.0028662257f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMATanEstCoefficients0 = { { { +0.999866f, +0.999866f, +0.999866f, +0.999866f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMATanEstCoefficients1 = { { { -0.3302995f, +0.180141f, -0.085133f, +0.0208351f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMTanEstCoefficients = { { { 2.484f, -1.954923183e-1f, 2.467401101f, XM_1DIVPI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMArcEstCoefficients = { { { +1.5707288f, -0.2121144f, +0.0742610f, -0.0187293f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMPiConstants0 = { { { XM_PI, XM_2PI, XM_1DIVPI, XM_1DIV2PI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMIdentityR0 = { { { 1.0f, 0.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMIdentityR1 = { { { 0.0f, 1.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMIdentityR2 = { { { 0.0f, 0.0f, 1.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMIdentityR3 = { { { 0.0f, 0.0f, 0.0f, 1.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegIdentityR0 = { { { -1.0f, 0.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegIdentityR1 = { { { 0.0f, -1.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegIdentityR2 = { { { 0.0f, 0.0f, -1.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegIdentityR3 = { { { 0.0f, 0.0f, 0.0f, -1.0f } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMNegativeZero = { { { 0x80000000, 0x80000000, 0x80000000, 0x80000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMNegate3 = { { { 0x80000000, 0x80000000, 0x80000000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskXY = { { { 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMask3 = { { { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskX = { { { 0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskY = { { { 0x00000000, 0xFFFFFFFF, 0x00000000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskZ = { { { 0x00000000, 0x00000000, 0xFFFFFFFF, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskW = { { { 0x00000000, 0x00000000, 0x00000000, 0xFFFFFFFF } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMOne = { { { 1.0f, 1.0f, 1.0f, 1.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMOne3 = { { { 1.0f, 1.0f, 1.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMZero = { { { 0.0f, 0.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMTwo = { { { 2.f, 2.f, 2.f, 2.f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFour = { { { 4.f, 4.f, 4.f, 4.f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMSix = { { { 6.f, 6.f, 6.f, 6.f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegativeOne = { { { -1.0f, -1.0f, -1.0f, -1.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMOneHalf = { { { 0.5f, 0.5f, 0.5f, 0.5f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegativeOneHalf = { { { -0.5f, -0.5f, -0.5f, -0.5f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegativeTwoPi = { { { -XM_2PI, -XM_2PI, -XM_2PI, -XM_2PI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegativePi = { { { -XM_PI, -XM_PI, -XM_PI, -XM_PI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMHalfPi = { { { XM_PIDIV2, XM_PIDIV2, XM_PIDIV2, XM_PIDIV2 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMPi = { { { XM_PI, XM_PI, XM_PI, XM_PI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMReciprocalPi = { { { XM_1DIVPI, XM_1DIVPI, XM_1DIVPI, XM_1DIVPI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMTwoPi = { { { XM_2PI, XM_2PI, XM_2PI, XM_2PI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMReciprocalTwoPi = { { { XM_1DIV2PI, XM_1DIV2PI, XM_1DIV2PI, XM_1DIV2PI } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMEpsilon = { { { 1.192092896e-7f, 1.192092896e-7f, 1.192092896e-7f, 1.192092896e-7f } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMInfinity = { { { 0x7F800000, 0x7F800000, 0x7F800000, 0x7F800000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMQNaN = { { { 0x7FC00000, 0x7FC00000, 0x7FC00000, 0x7FC00000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMQNaNTest = { { { 0x007FFFFF, 0x007FFFFF, 0x007FFFFF, 0x007FFFFF } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMAbsMask = { { { 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMFltMin = { { { 0x00800000, 0x00800000, 0x00800000, 0x00800000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMFltMax = { { { 0x7F7FFFFF, 0x7F7FFFFF, 0x7F7FFFFF, 0x7F7FFFFF } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMNegOneMask = { { { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskA8R8G8B8 = { { { 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipA8R8G8B8 = { { { 0x00000000, 0x00000000, 0x00000000, 0x80000000 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFixAA8R8G8B8 = { { { 0.0f, 0.0f, 0.0f, float(0x80000000U) } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNormalizeA8R8G8B8 = { { { 1.0f / (255.0f * float(0x10000)), 1.0f / (255.0f * float(0x100)), 1.0f / 255.0f, 1.0f / (255.0f * float(0x1000000)) } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskA2B10G10R10 = { { { 0x000003FF, 0x000FFC00, 0x3FF00000, 0xC0000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipA2B10G10R10 = { { { 0x00000200, 0x00080000, 0x20000000, 0x80000000 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFixAA2B10G10R10 = { { { -512.0f, -512.0f * float(0x400), -512.0f * float(0x100000), float(0x80000000U) } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNormalizeA2B10G10R10 = { { { 1.0f / 511.0f, 1.0f / (511.0f * float(0x400)), 1.0f / (511.0f * float(0x100000)), 1.0f / (3.0f * float(0x40000000)) } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskX16Y16 = { { { 0x0000FFFF, 0xFFFF0000, 0x00000000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMFlipX16Y16 = { { { 0x00008000, 0x00000000, 0x00000000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFixX16Y16 = { { { -32768.0f, 0.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNormalizeX16Y16 = { { { 1.0f / 32767.0f, 1.0f / (32767.0f * 65536.0f), 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskX16Y16Z16W16 = { { { 0x0000FFFF, 0x0000FFFF, 0xFFFF0000, 0xFFFF0000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMFlipX16Y16Z16W16 = { { { 0x00008000, 0x00008000, 0x00000000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFixX16Y16Z16W16 = { { { -32768.0f, -32768.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNormalizeX16Y16Z16W16 = { { { 1.0f / 32767.0f, 1.0f / 32767.0f, 1.0f / (32767.0f * 65536.0f), 1.0f / (32767.0f * 65536.0f) } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNoFraction = { { { 8388608.0f, 8388608.0f, 8388608.0f, 8388608.0f } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMMaskByte = { { { 0x000000FF, 0x000000FF, 0x000000FF, 0x000000FF } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegateX = { { { -1.0f, 1.0f, 1.0f, 1.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegateY = { { { 1.0f, -1.0f, 1.0f, 1.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegateZ = { { { 1.0f, 1.0f, -1.0f, 1.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMNegateW = { { { 1.0f, 1.0f, 1.0f, -1.0f } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMSelect0101 = { { { XM_SELECT_0, XM_SELECT_1, XM_SELECT_0, XM_SELECT_1 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMSelect1010 = { { { XM_SELECT_1, XM_SELECT_0, XM_SELECT_1, XM_SELECT_0 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMOneHalfMinusEpsilon = { { { 0x3EFFFFFD, 0x3EFFFFFD, 0x3EFFFFFD, 0x3EFFFFFD } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMSelect1000 = { { { XM_SELECT_1, XM_SELECT_0, XM_SELECT_0, XM_SELECT_0 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMSelect1100 = { { { XM_SELECT_1, XM_SELECT_1, XM_SELECT_0, XM_SELECT_0 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMSelect1110 = { { { XM_SELECT_1, XM_SELECT_1, XM_SELECT_1, XM_SELECT_0 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMSelect1011 = { { { XM_SELECT_1, XM_SELECT_0, XM_SELECT_1, XM_SELECT_1 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFixupY16 = { { { 1.0f, 1.0f / 65536.0f, 0.0f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFixupY16W16 = { { { 1.0f, 1.0f, 1.0f / 65536.0f, 1.0f / 65536.0f } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipY = { { { 0, 0x80000000, 0, 0 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipZ = { { { 0, 0, 0x80000000, 0 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipW = { { { 0, 0, 0, 0x80000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipYZ = { { { 0, 0x80000000, 0x80000000, 0 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipZW = { { { 0, 0, 0x80000000, 0x80000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMFlipYW = { { { 0, 0x80000000, 0, 0x80000000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMMaskDec4 = { { { 0x3FF, 0x3FF << 10, 0x3FF << 20, static_cast<int>(0xC0000000) } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMXorDec4 = { { { 0x200, 0x200 << 10, 0x200 << 20, 0 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMAddUDec4 = { { { 0, 0, 0, 32768.0f * 65536.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMAddDec4 = { { { -512.0f, -512.0f * 1024.0f, -512.0f * 1024.0f * 1024.0f, 0 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMMulDec4 = { { { 1.0f, 1.0f / 1024.0f, 1.0f / (1024.0f * 1024.0f), 1.0f / (1024.0f * 1024.0f * 1024.0f) } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMMaskByte4 = { { { 0xFF, 0xFF00, 0xFF0000, 0xFF000000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMXorByte4 = { { { 0x80, 0x8000, 0x800000, 0x00000000 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMAddByte4 = { { { -128.0f, -128.0f * 256.0f, -128.0f * 65536.0f, 0 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMFixUnsigned = { { { 32768.0f * 65536.0f, 32768.0f * 65536.0f, 32768.0f * 65536.0f, 32768.0f * 65536.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMMaxInt = { { { 65536.0f * 32768.0f - 128.0f, 65536.0f * 32768.0f - 128.0f, 65536.0f * 32768.0f - 128.0f, 65536.0f * 32768.0f - 128.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMMaxUInt = { { { 65536.0f * 65536.0f - 256.0f, 65536.0f * 65536.0f - 256.0f, 65536.0f * 65536.0f - 256.0f, 65536.0f * 65536.0f - 256.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMUnsignedFix = { { { 32768.0f * 65536.0f, 32768.0f * 65536.0f, 32768.0f * 65536.0f, 32768.0f * 65536.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMsrgbScale = { { { 12.92f, 12.92f, 12.92f, 1.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMsrgbA = { { { 0.055f, 0.055f, 0.055f, 0.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMsrgbA1 = { { { 1.055f, 1.055f, 1.055f, 1.0f } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMExponentBias = { { { 127, 127, 127, 127 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMSubnormalExponent = { { { -126, -126, -126, -126 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMNumTrailing = { { { 23, 23, 23, 23 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMMinNormal = { { { 0x00800000, 0x00800000, 0x00800000, 0x00800000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMNegInfinity = { { { 0xFF800000, 0xFF800000, 0xFF800000, 0xFF800000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMNegQNaN = { { { 0xFFC00000, 0xFFC00000, 0xFFC00000, 0xFFC00000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XMBin128 = { { { 0x43000000, 0x43000000, 0x43000000, 0x43000000 } } };
    extern const __declspec(selectany) XMVECTORU32 g_XMBinNeg150 = { { { 0xC3160000, 0xC3160000, 0xC3160000, 0xC3160000 } } };
    extern const __declspec(selectany) XMVECTORI32 g_XM253 = { { { 253, 253, 253, 253 } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMExpEst1 = { { { -6.93147182e-1f, -6.93147182e-1f, -6.93147182e-1f, -6.93147182e-1f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMExpEst2 = { { { +2.40226462e-1f, +2.40226462e-1f, +2.40226462e-1f, +2.40226462e-1f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMExpEst3 = { { { -5.55036440e-2f, -5.55036440e-2f, -5.55036440e-2f, -5.55036440e-2f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMExpEst4 = { { { +9.61597636e-3f, +9.61597636e-3f, +9.61597636e-3f, +9.61597636e-3f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMExpEst5 = { { { -1.32823968e-3f, -1.32823968e-3f, -1.32823968e-3f, -1.32823968e-3f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMExpEst6 = { { { +1.47491097e-4f, +1.47491097e-4f, +1.47491097e-4f, +1.47491097e-4f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMExpEst7 = { { { -1.08635004e-5f, -1.08635004e-5f, -1.08635004e-5f, -1.08635004e-5f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst0 = { { { +1.442693f, +1.442693f, +1.442693f, +1.442693f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst1 = { { { -0.721242f, -0.721242f, -0.721242f, -0.721242f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst2 = { { { +0.479384f, +0.479384f, +0.479384f, +0.479384f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst3 = { { { -0.350295f, -0.350295f, -0.350295f, -0.350295f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst4 = { { { +0.248590f, +0.248590f, +0.248590f, +0.248590f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst5 = { { { -0.145700f, -0.145700f, -0.145700f, -0.145700f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst6 = { { { +0.057148f, +0.057148f, +0.057148f, +0.057148f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLogEst7 = { { { -0.010578f, -0.010578f, -0.010578f, -0.010578f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLgE = { { { +1.442695f, +1.442695f, +1.442695f, +1.442695f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMInvLgE = { { { +6.93147182e-1f, +6.93147182e-1f, +6.93147182e-1f, +6.93147182e-1f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMLg10 = { { { +3.321928f, +3.321928f, +3.321928f, +3.321928f } } };
    extern const __declspec(selectany) XMVECTORF32 g_XMInvLg10 = { { { +3.010299956e-1f, +3.010299956e-1f, +3.010299956e-1f, +3.010299956e-1f } } };
    extern const __declspec(selectany) XMVECTORF32 g_UByteMax = { { { 255.0f, 255.0f, 255.0f, 255.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_ByteMin = { { { -127.0f, -127.0f, -127.0f, -127.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_ByteMax = { { { 127.0f, 127.0f, 127.0f, 127.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_ShortMin = { { { -32767.0f, -32767.0f, -32767.0f, -32767.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_ShortMax = { { { 32767.0f, 32767.0f, 32767.0f, 32767.0f } } };
    extern const __declspec(selectany) XMVECTORF32 g_UShortMax = { { { 65535.0f, 65535.0f, 65535.0f, 65535.0f } } };

    





#pragma warning(push)
#pragma warning(disable:4068 4214 4204 4365 4616 4640 6001 6101)
     
     
     
     














    inline XMVECTOR __vectorcall XMVectorSetBinaryConstant(uint32_t C0, uint32_t C1, uint32_t C2, uint32_t C3) noexcept
    {







#line 2144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"






#line 2151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
        static const XMVECTORU32 g_vMask1 = { { { 1, 1, 1, 1 } } };
        
        __m128i vTemp = _mm_set_epi32(static_cast<int>(C3), static_cast<int>(C2), static_cast<int>(C1), static_cast<int>(C0));
        
        vTemp = _mm_and_si128(vTemp, g_vMask1);
        
        vTemp = _mm_cmpeq_epi32(vTemp, g_vMask1);
        
        vTemp = _mm_and_si128(vTemp, g_XMOne);
        return _mm_castsi128_ps(vTemp);
#line 2162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    }

    

    inline XMVECTOR __vectorcall XMVectorSplatConstant(int32_t IntConstant, uint32_t DivExponent) noexcept
    {
        (void)( (!!(IntConstant >= -16 && IntConstant <= 15)) || (_wassert(L"IntConstant >= -16 && IntConstant <= 15", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h", (unsigned)(2168)), 0) );
        (void)( (!!(DivExponent < 32)) || (_wassert(L"DivExponent < 32", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h", (unsigned)(2169)), 0) );







#line 2178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"











#line 2190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
        
        __m128i vScale = _mm_set1_epi32(IntConstant);
        
        XMVECTOR vResult = _mm_cvtepi32_ps(vScale);
        
        uint32_t uScale = 0x3F800000U - (DivExponent << 23);
        
        vScale = _mm_set1_epi32(static_cast<int>(uScale));
        
        vResult = _mm_mul_ps(vResult, _mm_castsi128_ps(vScale));
        return vResult;
#line 2202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    }

    

    inline XMVECTOR __vectorcall XMVectorSplatConstantInt(int32_t IntConstant) noexcept
    {
        (void)( (!!(IntConstant >= -16 && IntConstant <= 15)) || (_wassert(L"IntConstant >= -16 && IntConstant <= 15", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h", (unsigned)(2208)), 0) );





#line 2215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"


#line 2218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
        __m128i V = _mm_set1_epi32(IntConstant);
        return _mm_castsi128_ps(V);
#line 2221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
    }

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"









#pragma once







 

#pragma warning(push)
#pragma warning(disable:4701)


inline XMVECTOR __vectorcall XMConvertVectorIntToFloat
(
    FXMVECTOR    VInt,
    uint32_t     DivExponent
) noexcept
{
    (void)( (!!(DivExponent < 32)) || (_wassert(L"DivExponent < 32", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(30)), 0) );









#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vResult = _mm_cvtepi32_ps(_mm_castps_si128(VInt));
    
    uint32_t uScale = 0x3F800000U - (DivExponent << 23);
    
    __m128i vScale = _mm_set1_epi32(static_cast<int>(uScale));
    vResult = _mm_mul_ps(vResult, _mm_castsi128_ps(vScale));
    return vResult;
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMConvertVectorFloatToInt
(
    FXMVECTOR    VFloat,
    uint32_t     MulExponent
) noexcept
{
    (void)( (!!(MulExponent < 32)) || (_wassert(L"MulExponent < 32", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(64)), 0) );






















#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"










#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMVECTOR vResult = _mm_set_ps1(static_cast<float>(1U << MulExponent));
    vResult = _mm_mul_ps(vResult, VFloat);
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(vResult, g_XMMaxInt);
    
    __m128i vResulti = _mm_cvttps_epi32(vResult);
    
    vResult = _mm_and_ps(vOverflow, g_XMAbsMask);
    vOverflow = _mm_andnot_ps(vOverflow, _mm_castsi128_ps(vResulti));
    vOverflow = _mm_or_ps(vOverflow, vResult);
    return vOverflow;
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMConvertVectorUIntToFloat
(
    FXMVECTOR     VUInt,
    uint32_t      DivExponent
) noexcept
{
    (void)( (!!(DivExponent < 32)) || (_wassert(L"DivExponent < 32", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(121)), 0) );








#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    
    XMVECTOR vMask = _mm_and_ps(VUInt, g_XMNegativeZero);
    
    XMVECTOR vResult = _mm_xor_ps(VUInt, vMask);
    
    vResult = _mm_cvtepi32_ps(_mm_castps_si128(vResult));
    
    __m128i iMask = _mm_srai_epi32(_mm_castps_si128(vMask), 31);
    
    vMask = _mm_and_ps(_mm_castsi128_ps(iMask), g_XMFixUnsigned);
    vResult = _mm_add_ps(vResult, vMask);
    
    uint32_t uScale = 0x3F800000U - (DivExponent << 23);
    
    iMask = _mm_set1_epi32(static_cast<int>(uScale));
    vResult = _mm_mul_ps(vResult, _mm_castsi128_ps(iMask));
    return vResult;
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMConvertVectorFloatToUInt
(
    FXMVECTOR     VFloat,
    uint32_t      MulExponent
) noexcept
{
    (void)( (!!(MulExponent < 32)) || (_wassert(L"MulExponent < 32", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(164)), 0) );






















#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"









#line 198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMVECTOR vResult = _mm_set_ps1(static_cast<float>(1U << MulExponent));
    vResult = _mm_mul_ps(vResult, VFloat);
    
    vResult = _mm_max_ps(vResult, g_XMZero);
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(vResult, g_XMMaxUInt);
    XMVECTOR vValue = g_XMUnsignedFix;
    
    XMVECTOR vMask = _mm_cmpge_ps(vResult, vValue);
    
    vValue = _mm_and_ps(vValue, vMask);
    
    vResult = _mm_sub_ps(vResult, vValue);
    __m128i vResulti = _mm_cvttps_epi32(vResult);
    
    vMask = _mm_and_ps(vMask, g_XMNegativeZero);
    vResult = _mm_xor_ps(_mm_castsi128_ps(vResulti), vMask);
    
    vResult = _mm_or_ps(vResult, vOverflow);
    return vResult;
#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}

#pragma warning(pop)







 

inline XMVECTOR __vectorcall XMLoadInt(const uint32_t* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(233)), 0) );







#line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_load_ss(reinterpret_cast<const float*>(pSource));
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadFloat(const float* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(253)), 0) );







#line 262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_load_ss(pSource);
#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadInt2(const uint32_t* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(273)), 0) );







#line 282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
#line 288 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadInt2A(const uint32_t* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(294)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(295)), 0) );







#line 304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"







#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadFloat2(const XMFLOAT2* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(320)), 0) );







#line 329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadFloat2A(const XMFLOAT2A* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(341)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(342)), 0) );







#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"







#line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadSInt2(const XMINT2* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(367)), 0) );







#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 V = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
    return _mm_cvtepi32_ps(_mm_castps_si128(V));
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadUInt2(const XMUINT2* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(390)), 0) );







#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 V = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
    
    
    XMVECTOR vMask = _mm_and_ps(V, g_XMNegativeZero);
    
    XMVECTOR vResult = _mm_xor_ps(V, vMask);
    
    vResult = _mm_cvtepi32_ps(_mm_castps_si128(vResult));
    
    __m128i iMask = _mm_srai_epi32(_mm_castps_si128(vMask), 31);
    
    vMask = _mm_and_ps(_mm_castsi128_ps(iMask), g_XMFixUnsigned);
    vResult = _mm_add_ps(vResult, vMask);
    return vResult;
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadInt3(const uint32_t* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(425)), 0) );







#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




#line 439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
    __m128 z = _mm_load_ss(reinterpret_cast<const float*>(pSource + 2));
    return _mm_movelh_ps(xy, z);
#line 447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadInt3A(const uint32_t* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(453)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(454)), 0) );







#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"







#line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
    __m128 z = _mm_load_ss(reinterpret_cast<const float*>(pSource + 2));
    return _mm_movelh_ps(xy, z);
#line 479 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadFloat3(const XMFLOAT3* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(485)), 0) );







#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




#line 499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
    __m128 z = _mm_load_ss(&pSource->z);
    return _mm_movelh_ps(xy, z);
#line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadFloat3A(const XMFLOAT3A* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(513)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(514)), 0) );







#line 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"







#line 531 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    __m128 V = _mm_load_ps(&pSource->x);
    return _mm_and_ps(V, g_XMMask3);
#line 535 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadSInt3(const XMINT3* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(541)), 0) );









#line 552 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"





#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
    __m128 z = _mm_load_ss(reinterpret_cast<const float*>(&pSource->z));
    __m128 V = _mm_movelh_ps(xy, z);
    return _mm_cvtepi32_ps(_mm_castps_si128(V));
#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadUInt3(const XMUINT3* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(569)), 0) );







#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"





#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pSource)));
    __m128 z = _mm_load_ss(reinterpret_cast<const float*>(&pSource->z));
    __m128 V = _mm_movelh_ps(xy, z);
    
    
    XMVECTOR vMask = _mm_and_ps(V, g_XMNegativeZero);
    
    XMVECTOR vResult = _mm_xor_ps(V, vMask);
    
    vResult = _mm_cvtepi32_ps(_mm_castps_si128(vResult));
    
    __m128i iMask = _mm_srai_epi32(_mm_castps_si128(vMask), 31);
    
    vMask = _mm_and_ps(_mm_castsi128_ps(iMask), g_XMFixUnsigned);
    vResult = _mm_add_ps(vResult, vMask);
    return vResult;
#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadInt4(const uint32_t* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(607)), 0) );








#line 617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"

#line 619 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128i V = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pSource));
    return _mm_castsi128_ps(V);
#line 622 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadInt4A(const uint32_t* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(628)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(629)), 0) );







#line 638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"





#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128i V = _mm_load_si128(reinterpret_cast<const __m128i*>(pSource));
    return _mm_castsi128_ps(V);
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadFloat4(const XMFLOAT4* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(653)), 0) );







#line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"

#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_loadu_ps(&pSource->x);
#line 666 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadFloat4A(const XMFLOAT4A* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(672)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(673)), 0) );







#line 682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"





#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    return _mm_load_ps(&pSource->x);
#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadSInt4(const XMINT4* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(696)), 0) );









#line 707 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128i V = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pSource));
    return _mm_cvtepi32_ps(V);
#line 713 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMVECTOR __vectorcall XMLoadUInt4(const XMUINT4* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(719)), 0) );







#line 728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128i V = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pSource));
    
    
    XMVECTOR vMask = _mm_and_ps(_mm_castsi128_ps(V), g_XMNegativeZero);
    
    XMVECTOR vResult = _mm_xor_ps(_mm_castsi128_ps(V), vMask);
    
    vResult = _mm_cvtepi32_ps(_mm_castps_si128(vResult));
    
    __m128i iMask = _mm_srai_epi32(_mm_castps_si128(vMask), 31);
    
    vMask = _mm_and_ps(_mm_castsi128_ps(iMask), g_XMFixUnsigned);
    vResult = _mm_add_ps(vResult, vMask);
    return vResult;
#line 746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMMATRIX __vectorcall XMLoadFloat3x3(const XMFLOAT3X3* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(752)), 0) );























#line 777 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"











#line 789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    __m128 Z = _mm_setzero_ps();

    __m128 V1 = _mm_loadu_ps(&pSource->m[0][0]);
    __m128 V2 = _mm_loadu_ps(&pSource->m[1][1]);
    __m128 V3 = _mm_load_ss(&pSource->m[2][2]);

    __m128 T1 = _mm_unpackhi_ps(V1, Z);
    __m128 T2 = _mm_unpacklo_ps(V2, Z);
    __m128 T3 = _mm_shuffle_ps(V3, T2, (((0) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
    __m128 T4 = _mm_movehl_ps(T2, T3);
    __m128 T5 = _mm_movehl_ps(Z, T1);

    XMMATRIX M;
    M.r[0] = _mm_movelh_ps(V1, T1);
    M.r[1] = _mm_add_ps(T4, T5);
    M.r[2] = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((3) << 2) | ((2))));
    M.r[3] = g_XMIdentityR3;
    return M;
#line 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMMATRIX __vectorcall XMLoadFloat4x3(const XMFLOAT4X3* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(814)), 0) );
























#line 840 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"














#line 855 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    
    
    XMVECTOR vTemp1 = _mm_loadu_ps(&pSource->m[0][0]);
    
    XMVECTOR vTemp2 = _mm_loadu_ps(&pSource->m[1][1]);
    
    XMVECTOR vTemp4 = _mm_loadu_ps(&pSource->m[2][2]);
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(vTemp2, vTemp4, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2))));
    
    vTemp2 = _mm_shuffle_ps(vTemp2, vTemp1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0))));
    
    vTemp2 = _mm_shuffle_ps((vTemp2), (vTemp2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );
    
    vTemp1 = _mm_and_ps(vTemp1, g_XMMask3);
    
    vTemp2 = _mm_and_ps(vTemp2, g_XMMask3);
    
    vTemp3 = _mm_and_ps(vTemp3, g_XMMask3);
    
    __m128i vTemp4i = _mm_srli_si128(_mm_castps_si128(vTemp4), 32 / 8);
    
    vTemp4i = _mm_or_si128(vTemp4i, g_XMIdentityR3);
    XMMATRIX M(vTemp1,
        vTemp2,
        vTemp3,
        _mm_castsi128_ps(vTemp4i));
    return M;
#line 885 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMMATRIX __vectorcall XMLoadFloat4x3A(const XMFLOAT4X3A* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(891)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(892)), 0) );
























#line 918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




















#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    
    
    XMVECTOR vTemp1 = _mm_load_ps(&pSource->m[0][0]);
    
    XMVECTOR vTemp2 = _mm_load_ps(&pSource->m[1][1]);
    
    XMVECTOR vTemp4 = _mm_load_ps(&pSource->m[2][2]);
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(vTemp2, vTemp4, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2))));
    
    vTemp2 = _mm_shuffle_ps(vTemp2, vTemp1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0))));
    
    vTemp2 = _mm_shuffle_ps((vTemp2), (vTemp2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );
    
    vTemp1 = _mm_and_ps(vTemp1, g_XMMask3);
    
    vTemp2 = _mm_and_ps(vTemp2, g_XMMask3);
    
    vTemp3 = _mm_and_ps(vTemp3, g_XMMask3);
    
    __m128i vTemp4i = _mm_srli_si128(_mm_castps_si128(vTemp4), 32 / 8);
    
    vTemp4i = _mm_or_si128(vTemp4i, g_XMIdentityR3);
    XMMATRIX M(vTemp1,
        vTemp2,
        vTemp3,
        _mm_castsi128_ps(vTemp4i));
    return M;
#line 969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMMATRIX __vectorcall XMLoadFloat3x4(const XMFLOAT3X4* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(975)), 0) );
























#line 1001 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



















#line 1021 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMMATRIX M;
    M.r[0] = _mm_loadu_ps(&pSource->_11);
    M.r[1] = _mm_loadu_ps(&pSource->_21);
    M.r[2] = _mm_loadu_ps(&pSource->_31);
    M.r[3] = g_XMIdentityR3;

    
    XMVECTOR vTemp1 = _mm_shuffle_ps(M.r[0], M.r[1], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(M.r[0], M.r[1], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    XMVECTOR vTemp2 = _mm_shuffle_ps(M.r[2], M.r[3], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp4 = _mm_shuffle_ps(M.r[2], M.r[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    XMMATRIX mResult;

    
    mResult.r[0] = _mm_shuffle_ps(vTemp1, vTemp2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[1] = _mm_shuffle_ps(vTemp1, vTemp2, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    
    mResult.r[2] = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[3] = _mm_shuffle_ps(vTemp3, vTemp4, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    return mResult;
#line 1047 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMMATRIX __vectorcall XMLoadFloat3x4A(const XMFLOAT3X4A* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1053)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1054)), 0) );
























#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
























#line 1105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMMATRIX M;
    M.r[0] = _mm_load_ps(&pSource->_11);
    M.r[1] = _mm_load_ps(&pSource->_21);
    M.r[2] = _mm_load_ps(&pSource->_31);
    M.r[3] = g_XMIdentityR3;

    
    XMVECTOR vTemp1 = _mm_shuffle_ps(M.r[0], M.r[1], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(M.r[0], M.r[1], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    XMVECTOR vTemp2 = _mm_shuffle_ps(M.r[2], M.r[3], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp4 = _mm_shuffle_ps(M.r[2], M.r[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    XMMATRIX mResult;

    
    mResult.r[0] = _mm_shuffle_ps(vTemp1, vTemp2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[1] = _mm_shuffle_ps(vTemp1, vTemp2, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    
    mResult.r[2] = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[3] = _mm_shuffle_ps(vTemp3, vTemp4, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    return mResult;
#line 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMMATRIX __vectorcall XMLoadFloat4x4(const XMFLOAT4X4* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1137)), 0) );
























#line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"






#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMMATRIX M;
    M.r[0] = _mm_loadu_ps(&pSource->_11);
    M.r[1] = _mm_loadu_ps(&pSource->_21);
    M.r[2] = _mm_loadu_ps(&pSource->_31);
    M.r[3] = _mm_loadu_ps(&pSource->_41);
    return M;
#line 1177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline XMMATRIX __vectorcall XMLoadFloat4x4A(const XMFLOAT4X4A* pSource) noexcept
{
    (void)( (!!(pSource)) || (_wassert(L"pSource", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1183)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pSource) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1184)), 0) );
























#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"













#line 1224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMMATRIX M;
    M.r[0] = _mm_load_ps(&pSource->_11);
    M.r[1] = _mm_load_ps(&pSource->_21);
    M.r[2] = _mm_load_ps(&pSource->_31);
    M.r[3] = _mm_load_ps(&pSource->_41);
    return M;
#line 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}







inline void __vectorcall XMStoreInt
(
    uint32_t* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1245)), 0) );


#line 1249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"

#line 1251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_ss(reinterpret_cast<float*>(pDestination), V);
#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat
(
    float* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1263)), 0) );


#line 1267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"

#line 1269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_ss(pDestination, V);
#line 1271 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreInt2
(
    uint32_t* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1281)), 0) );



#line 1286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
#line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreInt2A
(
    uint32_t* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1301)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1302)), 0) );



#line 1307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"






#line 1314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
#line 1316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat2
(
    XMFLOAT2* pDestination,
    FXMVECTOR  V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1326)), 0) );



#line 1331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 1334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
#line 1336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat2A
(
    XMFLOAT2A* pDestination,
    FXMVECTOR     V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1346)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1347)), 0) );



#line 1352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"






#line 1359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
#line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreSInt2
(
    XMINT2* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1371)), 0) );



#line 1376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(V, g_XMMaxInt);
    
    __m128i vResulti = _mm_cvttps_epi32(V);
    
    XMVECTOR vResult = _mm_and_ps(vOverflow, g_XMAbsMask);
    vOverflow = _mm_andnot_ps(vOverflow, _mm_castsi128_ps(vResulti));
    vOverflow = _mm_or_ps(vOverflow, vResult);
    
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(vOverflow));
#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreUInt2
(
    XMUINT2* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1401)), 0) );



#line 1406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 1410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vResult = _mm_max_ps(V, g_XMZero);
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(vResult, g_XMMaxUInt);
    XMVECTOR vValue = g_XMUnsignedFix;
    
    XMVECTOR vMask = _mm_cmpge_ps(vResult, vValue);
    
    vValue = _mm_and_ps(vValue, vMask);
    
    vResult = _mm_sub_ps(vResult, vValue);
    __m128i vResulti = _mm_cvttps_epi32(vResult);
    
    vMask = _mm_and_ps(vMask, g_XMNegativeZero);
    vResult = _mm_xor_ps(_mm_castsi128_ps(vResulti), vMask);
    
    vResult = _mm_or_ps(vResult, vOverflow);
    
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(vResult));
#line 1430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreInt3
(
    uint32_t* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1440)), 0) );




#line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 1450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
    __m128 z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    _mm_store_ss(reinterpret_cast<float*>(&pDestination[2]), z);
#line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreInt3A
(
    uint32_t* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1464)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1465)), 0) );




#line 1471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"







#line 1479 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
    __m128 z = _mm_movehl_ps(V, V);
    _mm_store_ss(reinterpret_cast<float*>(&pDestination[2]), z);
#line 1483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat3
(
    XMFLOAT3* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1493)), 0) );




#line 1499 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 1503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"



#line 1507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
    __m128 z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    _mm_store_ss(&pDestination->z, z);
#line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat3A
(
    XMFLOAT3A* pDestination,
    FXMVECTOR     V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1521)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1522)), 0) );




#line 1528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"







#line 1536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(V));
    __m128 z = _mm_movehl_ps(V, V);
    _mm_store_ss(&pDestination->z, z);
#line 1543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreSInt3
(
    XMINT3* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1553)), 0) );




#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




#line 1564 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(V, g_XMMaxInt);
    
    __m128i vResulti = _mm_cvttps_epi32(V);
    
    XMVECTOR vResult = _mm_and_ps(vOverflow, g_XMAbsMask);
    vOverflow = _mm_andnot_ps(vOverflow, _mm_castsi128_ps(vResulti));
    vOverflow = _mm_or_ps(vOverflow, vResult);
    
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(vOverflow));
    __m128 z = _mm_shuffle_ps((vOverflow), (vOverflow), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    _mm_store_ss(reinterpret_cast<float*>(&pDestination->z), z);
#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreUInt3
(
    XMUINT3* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1587)), 0) );




#line 1593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vResult = _mm_max_ps(V, g_XMZero);
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(vResult, g_XMMaxUInt);
    XMVECTOR vValue = g_XMUnsignedFix;
    
    XMVECTOR vMask = _mm_cmpge_ps(vResult, vValue);
    
    vValue = _mm_and_ps(vValue, vMask);
    
    vResult = _mm_sub_ps(vResult, vValue);
    __m128i vResulti = _mm_cvttps_epi32(vResult);
    
    vMask = _mm_and_ps(vMask, g_XMNegativeZero);
    vResult = _mm_xor_ps(_mm_castsi128_ps(vResulti), vMask);
    
    vResult = _mm_or_ps(vResult, vOverflow);
    
    _mm_store_sd(reinterpret_cast<double*>(pDestination), _mm_castps_pd(vResult));
    __m128 z = _mm_shuffle_ps((vResult), (vResult), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    _mm_store_ss(reinterpret_cast<float*>(&pDestination->z), z);
#line 1620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreInt4
(
    uint32_t* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1630)), 0) );





#line 1637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"

#line 1639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_storeu_si128(reinterpret_cast<__m128i*>(pDestination), _mm_castps_si128(V));
#line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreInt4A
(
    uint32_t* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1651)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1652)), 0) );





#line 1659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"





#line 1665 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_si128(reinterpret_cast<__m128i*>(pDestination), _mm_castps_si128(V));
#line 1667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat4
(
    XMFLOAT4* pDestination,
    FXMVECTOR  V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1677)), 0) );





#line 1684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"

#line 1686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_storeu_ps(&pDestination->x, V);
#line 1688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat4A
(
    XMFLOAT4A* pDestination,
    FXMVECTOR     V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1698)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1699)), 0) );





#line 1706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"





#line 1712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_ps(&pDestination->x, V);
#line 1714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreSInt4
(
    XMINT4* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1724)), 0) );





#line 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 1734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(V, g_XMMaxInt);
    
    __m128i vResulti = _mm_cvttps_epi32(V);
    
    XMVECTOR vResult = _mm_and_ps(vOverflow, g_XMAbsMask);
    vOverflow = _mm_andnot_ps(vOverflow, _mm_castsi128_ps(vResulti));
    vOverflow = _mm_or_ps(vOverflow, vResult);
    _mm_storeu_si128(reinterpret_cast<__m128i*>(pDestination), _mm_castps_si128(vOverflow));
#line 1744 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreUInt4
(
    XMUINT4* pDestination,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1754)), 0) );





#line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"


#line 1764 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vResult = _mm_max_ps(V, g_XMZero);
    
    XMVECTOR vOverflow = _mm_cmpgt_ps(vResult, g_XMMaxUInt);
    XMVECTOR vValue = g_XMUnsignedFix;
    
    XMVECTOR vMask = _mm_cmpge_ps(vResult, vValue);
    
    vValue = _mm_and_ps(vValue, vMask);
    
    vResult = _mm_sub_ps(vResult, vValue);
    __m128i vResulti = _mm_cvttps_epi32(vResult);
    
    vMask = _mm_and_ps(vMask, g_XMNegativeZero);
    vResult = _mm_xor_ps(_mm_castsi128_ps(vResulti), vMask);
    
    vResult = _mm_or_ps(vResult, vOverflow);
    _mm_storeu_si128(reinterpret_cast<__m128i*>(pDestination), _mm_castps_si128(vResult));
#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat3x3
(
    XMFLOAT3X3* pDestination,
    FXMMATRIX   M
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1793)), 0) );














#line 1809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"









#line 1819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMVECTOR vTemp1 = M.r[0];
    XMVECTOR vTemp2 = M.r[1];
    XMVECTOR vTemp3 = M.r[2];
    XMVECTOR vWork = _mm_shuffle_ps(vTemp1, vTemp2, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
    vTemp1 = _mm_shuffle_ps(vTemp1, vWork, (((2) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    _mm_storeu_ps(&pDestination->m[0][0], vTemp1);
    vTemp2 = _mm_shuffle_ps(vTemp2, vTemp3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
    _mm_storeu_ps(&pDestination->m[1][1], vTemp2);
    vTemp3 = _mm_shuffle_ps((vTemp3), (vTemp3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    _mm_store_ss(&pDestination->m[2][2], vTemp3);
#line 1830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat4x3
(
    XMFLOAT4X3* pDestination,
    FXMMATRIX M
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1840)), 0) );


















#line 1860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"











#line 1872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    XMVECTOR vTemp1 = M.r[0];
    XMVECTOR vTemp2 = M.r[1];
    XMVECTOR vTemp3 = M.r[2];
    XMVECTOR vTemp4 = M.r[3];
    XMVECTOR vTemp2x = _mm_shuffle_ps(vTemp2, vTemp3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
    vTemp2 = _mm_shuffle_ps(vTemp2, vTemp1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0))));
    vTemp1 = _mm_shuffle_ps(vTemp1, vTemp2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0))));
    vTemp3 = _mm_shuffle_ps(vTemp3, vTemp4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
    vTemp3 = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
    _mm_storeu_ps(&pDestination->m[0][0], vTemp1);
    _mm_storeu_ps(&pDestination->m[1][1], vTemp2x);
    _mm_storeu_ps(&pDestination->m[2][2], vTemp3);
#line 1885 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat4x3A
(
    XMFLOAT4X3A* pDestination,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1895)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1896)), 0) );


















#line 1916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"

























#line 1942 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vTemp1 = M.r[0];
    
    XMVECTOR vTemp2 = M.r[1];
    
    XMVECTOR vTemp3 = M.r[2];
    
    XMVECTOR vTemp4 = M.r[3];
    
    XMVECTOR vTemp = _mm_shuffle_ps(vTemp1, vTemp2, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
    
    vTemp2 = _mm_shuffle_ps(vTemp2, vTemp3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
    
    vTemp1 = _mm_shuffle_ps(vTemp1, vTemp, (((2) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    vTemp3 = _mm_shuffle_ps(vTemp3, vTemp4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
    
    vTemp3 = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
    
    _mm_store_ps(&pDestination->m[0][0], vTemp1);
    _mm_store_ps(&pDestination->m[1][1], vTemp2);
    _mm_store_ps(&pDestination->m[2][2], vTemp3);
#line 1965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat3x4
(
    XMFLOAT3X4* pDestination,
    FXMMATRIX M
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(1975)), 0) );

















#line 1994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"









#line 2004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vTemp1 = _mm_shuffle_ps(M.r[0], M.r[1], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(M.r[0], M.r[1], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    XMVECTOR vTemp2 = _mm_shuffle_ps(M.r[2], M.r[3], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp4 = _mm_shuffle_ps(M.r[2], M.r[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));

    
    XMVECTOR r0 = _mm_shuffle_ps(vTemp1, vTemp2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    XMVECTOR r1 = _mm_shuffle_ps(vTemp1, vTemp2, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    
    XMVECTOR r2 = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));

    _mm_storeu_ps(&pDestination->m[0][0], r0);
    _mm_storeu_ps(&pDestination->m[1][0], r1);
    _mm_storeu_ps(&pDestination->m[2][0], r2);
#line 2024 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat3x4A
(
    XMFLOAT3X4A* pDestination,
    FXMMATRIX M
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(2034)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(2035)), 0) );

















#line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"















#line 2070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    
    XMVECTOR vTemp1 = _mm_shuffle_ps(M.r[0], M.r[1], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(M.r[0], M.r[1], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    XMVECTOR vTemp2 = _mm_shuffle_ps(M.r[2], M.r[3], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp4 = _mm_shuffle_ps(M.r[2], M.r[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));

    
    XMVECTOR r0 = _mm_shuffle_ps(vTemp1, vTemp2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    XMVECTOR r1 = _mm_shuffle_ps(vTemp1, vTemp2, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    
    XMVECTOR r2 = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));

    _mm_store_ps(&pDestination->m[0][0], r0);
    _mm_store_ps(&pDestination->m[1][0], r1);
    _mm_store_ps(&pDestination->m[2][0], r2);
#line 2090 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat4x4
(
    XMFLOAT4X4* pDestination,
    FXMMATRIX M
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(2100)), 0) );






















#line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"




#line 2129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_storeu_ps(&pDestination->_11, M.r[0]);
    _mm_storeu_ps(&pDestination->_21, M.r[1]);
    _mm_storeu_ps(&pDestination->_31, M.r[2]);
    _mm_storeu_ps(&pDestination->_41, M.r[3]);
#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}



inline void __vectorcall XMStoreFloat4x4A
(
    XMFLOAT4X4A* pDestination,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pDestination)) || (_wassert(L"pDestination", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(2144)), 0) );
    (void)( (!!((reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0)) || (_wassert(L"(reinterpret_cast<uintptr_t>(pDestination) & 0xF) == 0", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl", (unsigned)(2145)), 0) );






















#line 2169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"











#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
    _mm_store_ps(&pDestination->_11, M.r[0]);
    _mm_store_ps(&pDestination->_21, M.r[1]);
    _mm_store_ps(&pDestination->_31, M.r[2]);
    _mm_store_ps(&pDestination->_41, M.r[3]);
#line 2186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathConvert.inl"
}

#pragma external_header(pop)
#line 2224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"









#pragma once




#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
















#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







 
 
 

 
 
inline XMVECTOR __vectorcall XMVectorZero() noexcept
{



#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_setzero_ps();
#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSet
(
    float x,
    float y,
    float z,
    float w
) noexcept
{



#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 80 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_set_ps(w, z, y, x);
#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSetInt
(
    uint32_t x,
    uint32_t y,
    uint32_t z,
    uint32_t w
) noexcept
{



#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_set_epi32(static_cast<int>(w), static_cast<int>(z), static_cast<int>(y), static_cast<int>(x));
    return _mm_castsi128_ps(V);
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorReplicate(float Value) noexcept
{







#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_set_ps1(Value);
#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorReplicatePtr(const float* pValue) noexcept
{








#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_load_ps1(pValue);
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorReplicateInt(uint32_t Value) noexcept
{







#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_set1_epi32(static_cast<int>(Value));
    return _mm_castsi128_ps(vTemp);
#line 164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorReplicateIntPtr(const uint32_t* pValue) noexcept
{








#line 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_load_ps1(reinterpret_cast<const float*>(pValue));
#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorTrueInt() noexcept
{



#line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_set1_epi32(-1);
    return _mm_castsi128_ps(V);
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorFalseInt() noexcept
{



#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_setzero_ps();
#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatX(FXMVECTOR V) noexcept
{







#line 227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatY(FXMVECTOR V) noexcept
{







#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatZ(FXMVECTOR V) noexcept
{







#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatW(FXMVECTOR V) noexcept
{







#line 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatOne() noexcept
{







#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return g_XMOne;
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatInfinity() noexcept
{







#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 321 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return g_XMInfinity;
#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatQNaN() noexcept
{







#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return g_XMQNaN;
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatEpsilon() noexcept
{







#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return g_XMEpsilon;
#line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSplatSignMask() noexcept
{







#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_set1_epi32(static_cast<int>(0x80000000));
    return _mm_castsi128_ps(V);
#line 378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline float __vectorcall XMVectorGetByIndex(FXMVECTOR V, size_t i) noexcept
{
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(385)), 0) );
    ;


#line 390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTORF32 U;
    U.v = V;
    return U.f[i];
#line 394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline float __vectorcall XMVectorGetX(FXMVECTOR V) noexcept
{


#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_cvtss_f32(V);
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline float __vectorcall XMVectorGetY(FXMVECTOR V) noexcept
{


#line 415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    return _mm_cvtss_f32(vTemp);
#line 420 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline float __vectorcall XMVectorGetZ(FXMVECTOR V) noexcept
{


#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    return _mm_cvtss_f32(vTemp);
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline float __vectorcall XMVectorGetW(FXMVECTOR V) noexcept
{


#line 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    return _mm_cvtss_f32(vTemp);
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline void __vectorcall XMVectorGetByIndexPtr(float* f, FXMVECTOR V, size_t i) noexcept
{
    (void)( (!!(f != nullptr)) || (_wassert(L"f != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(454)), 0) );
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(455)), 0) );
    ;


#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTORF32 U;
    U.v = V;
    *f = U.f[i];
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline void __vectorcall XMVectorGetXPtr(float* x, FXMVECTOR V) noexcept
{
    (void)( (!!(x != nullptr)) || (_wassert(L"x != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(472)), 0) );


#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    _mm_store_ss(x, V);
#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline void __vectorcall XMVectorGetYPtr(float* y, FXMVECTOR V) noexcept
{
    (void)( (!!(y != nullptr)) || (_wassert(L"y != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(486)), 0) );


#line 490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    _mm_store_ss(y, vResult);
#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline void __vectorcall XMVectorGetZPtr(float* z, FXMVECTOR V) noexcept
{
    (void)( (!!(z != nullptr)) || (_wassert(L"z != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(503)), 0) );


#line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    _mm_store_ss(z, vResult);
#line 514 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline void __vectorcall XMVectorGetWPtr(float* w, FXMVECTOR V) noexcept
{
    (void)( (!!(w != nullptr)) || (_wassert(L"w != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(520)), 0) );


#line 524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    _mm_store_ss(w, vResult);
#line 531 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline uint32_t __vectorcall XMVectorGetIntByIndex(FXMVECTOR V, size_t i) noexcept
{
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(539)), 0) );
    ;


#line 544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTORU32 U;
    U.v = V;
    return U.u[i];
#line 548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline uint32_t __vectorcall XMVectorGetIntX(FXMVECTOR V) noexcept
{


#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 560 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return static_cast<uint32_t>(_mm_cvtsi128_si32(_mm_castps_si128(V)));
#line 562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline uint32_t __vectorcall XMVectorGetIntY(FXMVECTOR V) noexcept
{


#line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 572 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vResulti = _mm_shuffle_epi32(_mm_castps_si128(V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
    return static_cast<uint32_t>(_mm_cvtsi128_si32(vResulti));
#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline uint32_t __vectorcall XMVectorGetIntZ(FXMVECTOR V) noexcept
{


#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vResulti = _mm_shuffle_epi32(_mm_castps_si128(V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
    return static_cast<uint32_t>(_mm_cvtsi128_si32(vResulti));
#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline uint32_t __vectorcall XMVectorGetIntW(FXMVECTOR V) noexcept
{


#line 602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 607 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vResulti = _mm_shuffle_epi32(_mm_castps_si128(V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
    return static_cast<uint32_t>(_mm_cvtsi128_si32(vResulti));
#line 610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline void __vectorcall XMVectorGetIntByIndexPtr(uint32_t* x, FXMVECTOR V, size_t i) noexcept
{
    (void)( (!!(x != nullptr)) || (_wassert(L"x != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(618)), 0) );
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(619)), 0) );
    ;


#line 624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTORU32 U;
    U.v = V;
    *x = U.u[i];
#line 628 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline void __vectorcall XMVectorGetIntXPtr(uint32_t* x, FXMVECTOR V) noexcept
{
    (void)( (!!(x != nullptr)) || (_wassert(L"x != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(636)), 0) );


#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    _mm_store_ss(reinterpret_cast<float*>(x), V);
#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline void __vectorcall XMVectorGetIntYPtr(uint32_t* y, FXMVECTOR V) noexcept
{
    (void)( (!!(y != nullptr)) || (_wassert(L"y != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(650)), 0) );


#line 654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    _mm_store_ss(reinterpret_cast<float*>(y), vResult);
#line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline void __vectorcall XMVectorGetIntZPtr(uint32_t* z, FXMVECTOR V) noexcept
{
    (void)( (!!(z != nullptr)) || (_wassert(L"z != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(668)), 0) );


#line 672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    _mm_store_ss(reinterpret_cast<float*>(z), vResult);
#line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline void __vectorcall XMVectorGetIntWPtr(uint32_t* w, FXMVECTOR V) noexcept
{
    (void)( (!!(w != nullptr)) || (_wassert(L"w != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(686)), 0) );


#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 692 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    _mm_store_ss(reinterpret_cast<float*>(w), vResult);
#line 698 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorSetByIndex(FXMVECTOR V, float f, size_t i) noexcept
{
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(705)), 0) );
    ;
    XMVECTORF32 U;
    U.v = V;
    U.f[i] = f;
    return U.v;
}




inline XMVECTOR __vectorcall XMVectorSetX(FXMVECTOR V, float x) noexcept
{








#line 727 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_set_ss(x);
    vResult = _mm_move_ss(V, vResult);
    return vResult;
#line 733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline XMVECTOR __vectorcall XMVectorSetY(FXMVECTOR V, float y) noexcept
{








#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 753 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    
    XMVECTOR vTemp = _mm_set_ss(y);
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    return vResult;
#line 763 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}

inline XMVECTOR __vectorcall XMVectorSetZ(FXMVECTOR V, float z) noexcept
{








#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    
    XMVECTOR vTemp = _mm_set_ss(z);
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    return vResult;
#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline XMVECTOR __vectorcall XMVectorSetW(FXMVECTOR V, float w) noexcept
{








#line 806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    
    XMVECTOR vTemp = _mm_set_ss(w);
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    return vResult;
#line 822 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline XMVECTOR __vectorcall XMVectorSetByIndexPtr(FXMVECTOR V, const float* f, size_t i) noexcept
{
    (void)( (!!(f != nullptr)) || (_wassert(L"f != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(830)), 0) );
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(831)), 0) );
    ;
    XMVECTORF32 U;
    U.v = V;
    U.f[i] = *f;
    return U.v;
}





inline XMVECTOR __vectorcall XMVectorSetXPtr(FXMVECTOR V, const float* x) noexcept
{
    (void)( (!!(x != nullptr)) || (_wassert(L"x != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(845)), 0) );








#line 855 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 857 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_load_ss(x);
    vResult = _mm_move_ss(V, vResult);
    return vResult;
#line 861 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSetYPtr(FXMVECTOR V, const float* y) noexcept
{
    (void)( (!!(y != nullptr)) || (_wassert(L"y != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(867)), 0) );








#line 877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    
    XMVECTOR vTemp = _mm_load_ss(y);
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    return vResult;
#line 889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSetZPtr(FXMVECTOR V, const float* z) noexcept
{
    (void)( (!!(z != nullptr)) || (_wassert(L"z != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(895)), 0) );








#line 905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 907 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    
    XMVECTOR vTemp = _mm_load_ss(z);
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    return vResult;
#line 917 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSetWPtr(FXMVECTOR V, const float* w) noexcept
{
    (void)( (!!(w != nullptr)) || (_wassert(L"w != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(923)), 0) );








#line 933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    
    XMVECTOR vTemp = _mm_load_ss(w);
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    return vResult;
#line 945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorSetIntByIndex(FXMVECTOR V, uint32_t x, size_t i) noexcept
{
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(952)), 0) );
    ;
    XMVECTORU32 tmp;
    tmp.v = V;
    tmp.u[i] = x;
    return tmp;
}




inline XMVECTOR __vectorcall XMVectorSetIntX(FXMVECTOR V, uint32_t x) noexcept
{








#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cvtsi32_si128(static_cast<int>(x));
    XMVECTOR vResult = _mm_move_ss(V, _mm_castsi128_ps(vTemp));
    return vResult;
#line 980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline XMVECTOR __vectorcall XMVectorSetIntY(FXMVECTOR V, uint32_t y) noexcept
{








#line 994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 996 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    
    __m128i vTemp = _mm_cvtsi32_si128(static_cast<int>(y));
    
    vResult = _mm_move_ss(vResult, _mm_castsi128_ps(vTemp));
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    return vResult;
#line 1010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline XMVECTOR __vectorcall XMVectorSetIntZ(FXMVECTOR V, uint32_t z) noexcept
{








#line 1024 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1026 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    
    __m128i vTemp = _mm_cvtsi32_si128(static_cast<int>(z));
    
    vResult = _mm_move_ss(vResult, _mm_castsi128_ps(vTemp));
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    return vResult;
#line 1040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline XMVECTOR __vectorcall XMVectorSetIntW(FXMVECTOR V, uint32_t w) noexcept
{








#line 1054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1056 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 1060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    
    __m128i vTemp = _mm_cvtsi32_si128(static_cast<int>(w));
    
    vResult = _mm_move_ss(vResult, _mm_castsi128_ps(vTemp));
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    return vResult;
#line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline XMVECTOR __vectorcall XMVectorSetIntByIndexPtr(FXMVECTOR V, const uint32_t* x, size_t i) noexcept
{
    (void)( (!!(x != nullptr)) || (_wassert(L"x != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1078)), 0) );
    (void)( (!!(i < 4)) || (_wassert(L"i < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1079)), 0) );
    ;
    XMVECTORU32 tmp;
    tmp.v = V;
    tmp.u[i] = *x;
    return tmp;
}





inline XMVECTOR __vectorcall XMVectorSetIntXPtr(FXMVECTOR V, const uint32_t* x) noexcept
{
    (void)( (!!(x != nullptr)) || (_wassert(L"x != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1093)), 0) );








#line 1103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_load_ss(reinterpret_cast<const float*>(x));
    XMVECTOR vResult = _mm_move_ss(V, vTemp);
    return vResult;
#line 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSetIntYPtr(FXMVECTOR V, const uint32_t* y) noexcept
{
    (void)( (!!(y != nullptr)) || (_wassert(L"y != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1115)), 0) );








#line 1125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    
    XMVECTOR vTemp = _mm_load_ss(reinterpret_cast<const float*>(y));
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    return vResult;
#line 1137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSetIntZPtr(FXMVECTOR V, const uint32_t* z) noexcept
{
    (void)( (!!(z != nullptr)) || (_wassert(L"z != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1143)), 0) );








#line 1153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    
    XMVECTOR vTemp = _mm_load_ss(reinterpret_cast<const float*>(z));
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    return vResult;
#line 1165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSetIntWPtr(FXMVECTOR V, const uint32_t* w) noexcept
{
    (void)( (!!(w != nullptr)) || (_wassert(L"w != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1171)), 0) );








#line 1181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    
    XMVECTOR vTemp = _mm_load_ss(reinterpret_cast<const float*>(w));
    
    vResult = _mm_move_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((0) << 6) | ((2) << 4) | ((1) << 2) | ((3))) );
    return vResult;
#line 1193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSwizzle
(
    FXMVECTOR V,
    uint32_t E0,
    uint32_t E1,
    uint32_t E2,
    uint32_t E3
) noexcept
{
    (void)( (!!((E0 < 4) && (E1 < 4) && (E2 < 4) && (E3 < 4))) || (_wassert(L"(E0 < 4) && (E1 < 4) && (E2 < 4) && (E3 < 4)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1206)), 0) );
    ;










#line 1219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



















#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto aPtr = reinterpret_cast<const uint32_t*>(&V);

    XMVECTOR Result;
    auto pWork = reinterpret_cast<uint32_t*>(&Result);

    pWork[0] = aPtr[E0];
    pWork[1] = aPtr[E1];
    pWork[2] = aPtr[E2];
    pWork[3] = aPtr[E3];

    return Result;
#line 1255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


inline XMVECTOR __vectorcall XMVectorPermute
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    uint32_t PermuteX,
    uint32_t PermuteY,
    uint32_t PermuteZ,
    uint32_t PermuteW
) noexcept
{
    (void)( (!!(PermuteX <= 7 && PermuteY <= 7 && PermuteZ <= 7 && PermuteW <= 7)) || (_wassert(L"PermuteX <= 7 && PermuteY <= 7 && PermuteZ <= 7 && PermuteW <= 7", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1268)), 0) );
    ;



























#line 1298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 1314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

    const uint32_t* aPtr[2];
    aPtr[0] = reinterpret_cast<const uint32_t*>(&V1);
    aPtr[1] = reinterpret_cast<const uint32_t*>(&V2);

    XMVECTOR Result;
    auto pWork = reinterpret_cast<uint32_t*>(&Result);

    const uint32_t i0 = PermuteX & 3;
    const uint32_t vi0 = PermuteX >> 2;
    pWork[0] = aPtr[vi0][i0];

    const uint32_t i1 = PermuteY & 3;
    const uint32_t vi1 = PermuteY >> 2;
    pWork[1] = aPtr[vi1][i1];

    const uint32_t i2 = PermuteZ & 3;
    const uint32_t vi2 = PermuteZ >> 2;
    pWork[2] = aPtr[vi2][i2];

    const uint32_t i3 = PermuteW & 3;
    const uint32_t vi3 = PermuteW >> 2;
    pWork[3] = aPtr[vi3][i3];

    return Result;
#line 1340 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}












inline XMVECTOR __vectorcall XMVectorSelectControl
(
    uint32_t VectorIndex0,
    uint32_t VectorIndex1,
    uint32_t VectorIndex2,
    uint32_t VectorIndex3
) noexcept
{

    
    __m128i vTemp = _mm_set_epi32(static_cast<int>(VectorIndex3), static_cast<int>(VectorIndex2), static_cast<int>(VectorIndex1), static_cast<int>(VectorIndex0));
    
    vTemp = _mm_cmpgt_epi32(vTemp, g_XMZero);
    return _mm_castsi128_ps(vTemp);






























#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSelect
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR Control
) noexcept
{










#line 1420 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp1 = _mm_andnot_ps(Control, V1);
    XMVECTOR vTemp2 = _mm_and_ps(V2, Control);
    return _mm_or_ps(vTemp1, vTemp2);
#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorMergeXY
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_unpacklo_ps(V1, V2);
#line 1451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorMergeZW
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_unpackhi_ps(V1, V2);
#line 1476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorShiftLeft(FXMVECTOR V1, FXMVECTOR V2, uint32_t Elements) noexcept
{
    (void)( (!!(Elements < 4)) || (_wassert(L"Elements < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1482)), 0) );
    ;
    return XMVectorPermute(V1, V2, Elements, ((Elements)+1), ((Elements)+2), ((Elements)+3));
}



inline XMVECTOR __vectorcall XMVectorRotateLeft(FXMVECTOR V, uint32_t Elements) noexcept
{
    (void)( (!!(Elements < 4)) || (_wassert(L"Elements < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1491)), 0) );
    ;
    return XMVectorSwizzle(V, Elements & 3, (Elements + 1) & 3, (Elements + 2) & 3, (Elements + 3) & 3);
}



inline XMVECTOR __vectorcall XMVectorRotateRight(FXMVECTOR V, uint32_t Elements) noexcept
{
    (void)( (!!(Elements < 4)) || (_wassert(L"Elements < 4", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1500)), 0) );
    ;
    return XMVectorSwizzle(V, (4 - (Elements)) & 3, (5 - (Elements)) & 3, (6 - (Elements)) & 3, (7 - (Elements)) & 3);
}



inline XMVECTOR __vectorcall XMVectorInsert(
    FXMVECTOR VD, FXMVECTOR VS,
    uint32_t VSLeftRotateElements,
    uint32_t Select0, uint32_t Select1, uint32_t Select2, uint32_t Select3) noexcept
{
    XMVECTOR Control = XMVectorSelectControl(Select0 & 1, Select1 & 1, Select2 & 1, Select3 & 1);
    return XMVectorSelect(VD, XMVectorRotateLeft(VS, VSLeftRotateElements), Control);
}







inline XMVECTOR __vectorcall XMVectorEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_cmpeq_ps(V1, V2);
#line 1543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorEqualR
(
    uint32_t* pCR,
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    (void)( (!!(pCR != nullptr)) || (_wassert(L"pCR != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1555)), 0) );





















#line 1578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















#line 1596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    uint32_t CR = 0;
    int iTest = _mm_movemask_ps(vTemp);
    if (iTest == 0xf)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        
        CR = XM_CRMASK_CR6FALSE;
    }
    *pCR = CR;
    return vTemp;
#line 1611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVectorEqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return _mm_castsi128_ps(V);
#line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorEqualIntR
(
    uint32_t* pCR,
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    (void)( (!!(pCR != nullptr)) || (_wassert(L"pCR != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1653)), 0) );

















#line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















#line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    int iTemp = _mm_movemask_ps(_mm_castsi128_ps(V));
    uint32_t CR = 0;
    if (iTemp == 0x0F)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTemp)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    *pCR = CR;
    return _mm_castsi128_ps(V);
#line 1704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorNearEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR Epsilon
) noexcept
{




















#line 1736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 1743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vDelta = _mm_sub_ps(V1, V2);
    
    XMVECTOR vTemp = _mm_setzero_ps();
    vTemp = _mm_sub_ps(vTemp, vDelta);
    vTemp = _mm_max_ps(vTemp, vDelta);
    vTemp = _mm_cmple_ps(vTemp, Epsilon);
    return vTemp;
#line 1752 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorNotEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_cmpneq_ps(V1, V2);
#line 1777 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorNotEqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return _mm_xor_ps(_mm_castsi128_ps(V), g_XMNegOneMask);
#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorGreater
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1825 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1827 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_cmpgt_ps(V1, V2);
#line 1829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorGreaterR
(
    uint32_t* pCR,
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    (void)( (!!(pCR != nullptr)) || (_wassert(L"pCR != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1841)), 0) );






















#line 1865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















#line 1883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpgt_ps(V1, V2);
    uint32_t CR = 0;
    int iTest = _mm_movemask_ps(vTemp);
    if (iTest == 0xf)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        
        CR = XM_CRMASK_CR6FALSE;
    }
    *pCR = CR;
    return vTemp;
#line 1898 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorGreaterOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 1919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 1921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_cmpge_ps(V1, V2);
#line 1923 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorGreaterOrEqualR
(
    uint32_t* pCR,
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    (void)( (!!(pCR != nullptr)) || (_wassert(L"pCR != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(1935)), 0) );






















#line 1959 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpge_ps(V1, V2);
    uint32_t CR = 0;
    int iTest = _mm_movemask_ps(vTemp);
    if (iTest == 0xf)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        
        CR = XM_CRMASK_CR6FALSE;
    }
    *pCR = CR;
    return vTemp;
#line 1992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorLess
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_cmplt_ps(V1, V2);
#line 2017 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorLessOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2038 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_cmple_ps(V1, V2);
#line 2042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorInBounds
(
    FXMVECTOR V,
    FXMVECTOR Bounds
) noexcept
{










#line 2063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"









#line 2073 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTemp1 = _mm_cmple_ps(V, Bounds);
    
    XMVECTOR vTemp2 = _mm_mul_ps(Bounds, g_XMNegativeOne);
    
    vTemp2 = _mm_cmple_ps(vTemp2, V);
    
    vTemp1 = _mm_and_ps(vTemp1, vTemp2);
    return vTemp1;
#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMVECTOR __vectorcall XMVectorInBoundsR
(
    uint32_t* pCR,
    FXMVECTOR V,
    FXMVECTOR Bounds
) noexcept
{
    (void)( (!!(pCR != nullptr)) || (_wassert(L"pCR != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(2095)), 0) );


















#line 2115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



















#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTemp1 = _mm_cmple_ps(V, Bounds);
    
    XMVECTOR vTemp2 = _mm_mul_ps(Bounds, g_XMNegativeOne);
    
    vTemp2 = _mm_cmple_ps(vTemp2, V);
    
    vTemp1 = _mm_and_ps(vTemp1, vTemp2);

    uint32_t CR = 0;
    if (_mm_movemask_ps(vTemp1) == 0xf)
    {
        
        CR = XM_CRMASK_CR6BOUNDS;
    }
    *pCR = CR;
    return vTemp1;
#line 2153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




#pragma float_control(push)
#pragma float_control(precise, on)
#line 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

inline XMVECTOR __vectorcall XMVectorIsNaN(FXMVECTOR V) noexcept
{










#line 2175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 2180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    return _mm_cmpneq_ps(V, V);
#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


#pragma float_control(pop)
#line 2188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



inline XMVECTOR __vectorcall XMVectorIsInfinite(FXMVECTOR V) noexcept
{










#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 2211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    __m128 vTemp = _mm_and_ps(V, g_XMAbsMask);
    
    vTemp = _mm_cmpeq_ps(vTemp, g_XMInfinity);
    
    return vTemp;
#line 2218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVectorMin
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_min_ps(V1, V2);
#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorMax
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_max_ps(V1, V2);
#line 2272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



namespace Internal
{
    
    inline float round_to_nearest(float x) noexcept
    {
        float i = floorf(x);
        x -= i;
        if (x < 0.5f)
            return i;
        if (x > 0.5f)
            return i + 1.f;

        float int_part;
        (void)modff(i / 2.f, &int_part);
        if ((2.f * int_part) == i)
        {
            return i;
        }

        return i + 1.f;
    }
}


#pragma float_control(push)
#pragma float_control(precise, on)
#line 2303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

inline XMVECTOR __vectorcall XMVectorRound(FXMVECTOR V) noexcept
{










#line 2317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











#line 2329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128 sign = _mm_and_ps(V, g_XMNegativeZero);
    __m128 sMagic = _mm_or_ps(g_XMNoFraction, sign);
    __m128 R1 = _mm_add_ps(V, sMagic);
    R1 = _mm_sub_ps(R1, sMagic);
    __m128 R2 = _mm_and_ps(V, g_XMAbsMask);
    __m128 mask = _mm_cmple_ps(R2, g_XMNoFraction);
    R2 = _mm_andnot_ps(mask, V);
    R1 = _mm_and_ps(R1, mask);
    XMVECTOR vResult = _mm_xor_ps(R1, R2);
    return vResult;
#line 2342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


#pragma float_control(pop)
#line 2347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



inline XMVECTOR __vectorcall XMVectorTruncate(FXMVECTOR V) noexcept
{
























#line 2377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"













#line 2391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    
    __m128i vTest = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    
    vTest = _mm_cmplt_epi32(vTest, g_XMNoFraction);
    
    __m128i vInt = _mm_cvttps_epi32(V);
    
    XMVECTOR vResult = _mm_cvtepi32_ps(vInt);
    
    vResult = _mm_and_ps(vResult, _mm_castsi128_ps(vTest));
    
    vTest = _mm_andnot_si128(vTest, _mm_castps_si128(V));
    vResult = _mm_or_ps(vResult, _mm_castsi128_ps(vTest));
    return vResult;
#line 2409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorFloor(FXMVECTOR V) noexcept
{








#line 2424 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
















#line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    __m128i vTest = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    vTest = _mm_cmplt_epi32(vTest, g_XMNoFraction);
    
    __m128i vInt = _mm_cvttps_epi32(V);
    XMVECTOR vResult = _mm_cvtepi32_ps(vInt);
    __m128 vLarger = _mm_cmpgt_ps(vResult, V);
    
    vLarger = _mm_cvtepi32_ps(_mm_castps_si128(vLarger));
    vResult = _mm_add_ps(vResult, vLarger);
    
    vResult = _mm_and_ps(vResult, _mm_castsi128_ps(vTest));
    
    vTest = _mm_andnot_si128(vTest, _mm_castps_si128(V));
    vResult = _mm_or_ps(vResult, _mm_castsi128_ps(vTest));
    return vResult;
#line 2460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorCeiling(FXMVECTOR V) noexcept
{








#line 2475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
















#line 2492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    __m128i vTest = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    vTest = _mm_cmplt_epi32(vTest, g_XMNoFraction);
    
    __m128i vInt = _mm_cvttps_epi32(V);
    XMVECTOR vResult = _mm_cvtepi32_ps(vInt);
    __m128 vSmaller = _mm_cmplt_ps(vResult, V);
    
    vSmaller = _mm_cvtepi32_ps(_mm_castps_si128(vSmaller));
    vResult = _mm_sub_ps(vResult, vSmaller);
    
    vResult = _mm_and_ps(vResult, _mm_castsi128_ps(vTest));
    
    vTest = _mm_andnot_si128(vTest, _mm_castps_si128(V));
    vResult = _mm_or_ps(vResult, _mm_castsi128_ps(vTest));
    return vResult;
#line 2511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorClamp
(
    FXMVECTOR V,
    FXMVECTOR Min,
    FXMVECTOR Max
) noexcept
{
    (void)( (!!(XMVector4LessOrEqual(Min, Max))) || (_wassert(L"XMVector4LessOrEqual(Min, Max)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(2522)), 0) );








#line 2532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 2536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult;
    vResult = _mm_max_ps(Min, V);
    vResult = _mm_min_ps(Max, vResult);
    return vResult;
#line 2541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSaturate(FXMVECTOR V) noexcept
{






#line 2554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 2559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_max_ps(V, g_XMZero);
    
    return _mm_min_ps(vResult, g_XMOne);
#line 2564 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline XMVECTOR __vectorcall XMVectorAndInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_and_ps(V1, V2);
#line 2591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorAndCInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2612 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_andnot_si128(_mm_castps_si128(V2), _mm_castps_si128(V1));
    return _mm_castsi128_ps(V);
#line 2617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorOrInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_or_si128(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return _mm_castsi128_ps(V);
#line 2643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorNorInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 2667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i Result;
    Result = _mm_or_si128(_mm_castps_si128(V1), _mm_castps_si128(V2));
    Result = _mm_andnot_si128(Result, g_XMNegOneMask);
    return _mm_castsi128_ps(Result);
#line 2672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorXorInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i V = _mm_xor_si128(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return _mm_castsi128_ps(V);
#line 2698 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVectorNegate(FXMVECTOR V) noexcept
{










#line 2719 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR Z;

    Z = _mm_setzero_ps();

    return _mm_sub_ps(Z, V);
#line 2727 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorAdd
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2748 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_add_ps(V1, V2);
#line 2752 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSum(FXMVECTOR V) noexcept
{









#line 2768 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"










#line 2779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 2782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((2) << 6) | ((3) << 4) | ((0) << 2) | ((1))) );
    XMVECTOR vTemp2 = _mm_add_ps(V, vTemp);
    vTemp = _mm_shuffle_ps((vTemp2), (vTemp2), (((1) << 6) | ((0) << 4) | ((3) << 2) | ((2))) );
    return _mm_add_ps(vTemp, vTemp2);
#line 2787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorAddAngles
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{




















#line 2818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"













#line 2832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_add_ps(V1, V2);
    
    XMVECTOR vOffset = _mm_cmplt_ps(vResult, g_XMNegativePi);
    vOffset = _mm_and_ps(vOffset, g_XMTwoPi);
    
    vResult = _mm_add_ps(vResult, vOffset);
    
    vOffset = _mm_cmpge_ps(vResult, g_XMPi);
    vOffset = _mm_and_ps(vOffset, g_XMTwoPi);
    
    vResult = _mm_sub_ps(vResult, vOffset);
    return vResult;
#line 2846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSubtract
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 2867 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_sub_ps(V1, V2);
#line 2871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSubtractAngles
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{




















#line 2902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"













#line 2916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_sub_ps(V1, V2);
    
    XMVECTOR vOffset = _mm_cmplt_ps(vResult, g_XMNegativePi);
    vOffset = _mm_and_ps(vOffset, g_XMTwoPi);
    
    vResult = _mm_add_ps(vResult, vOffset);
    
    vOffset = _mm_cmpge_ps(vResult, g_XMPi);
    vOffset = _mm_and_ps(vOffset, g_XMTwoPi);
    
    vResult = _mm_sub_ps(vResult, vOffset);
    return vResult;
#line 2930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorMultiply
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{








#line 2949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 2951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_mul_ps(V1, V2);
#line 2953 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorMultiplyAdd
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR V3
) noexcept
{








#line 2973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 2979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_add_ps(_mm_mul_ps((V1), (V2)), (V3));
#line 2981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorDivide
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{








#line 3000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











#line 3012 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_div_ps(V1, V2);
#line 3014 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorNegativeMultiplySubtract
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR V3
) noexcept
{








#line 3034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 3040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_sub_ps((V3), _mm_mul_ps((V1), (V2)));
#line 3042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorScale
(
    FXMVECTOR V,
    float    ScaleFactor
) noexcept
{








#line 3061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 3063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_set_ps1(ScaleFactor);
    return _mm_mul_ps(vResult, V);
#line 3066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorReciprocalEst(FXMVECTOR V) noexcept
{








#line 3081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 3083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_rcp_ps(V);
#line 3085 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorReciprocal(FXMVECTOR V) noexcept
{








#line 3100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











#line 3112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_div_ps(g_XMOne, V);
#line 3114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSqrtEst(FXMVECTOR V) noexcept
{








#line 3129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











#line 3141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_sqrt_ps(V);
#line 3143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSqrt(FXMVECTOR V) noexcept
{








#line 3158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















#line 3176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_sqrt_ps(V);
#line 3178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorReciprocalSqrtEst(FXMVECTOR V) noexcept
{








#line 3193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 3195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    return _mm_rsqrt_ps(V);
#line 3197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorReciprocalSqrt(FXMVECTOR V) noexcept
{








#line 3212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











#line 3224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_sqrt_ps(V);
    vResult = _mm_div_ps(g_XMOne, vResult);
    return vResult;
#line 3228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorExp2(FXMVECTOR V) noexcept
{








#line 3243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





















































#line 3297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 3300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i itrunc = _mm_cvttps_epi32(V);
    __m128 ftrunc = _mm_cvtepi32_ps(itrunc);
    __m128 y = _mm_sub_ps(V, ftrunc);

    __m128 poly = _mm_add_ps(_mm_mul_ps((g_XMExpEst7), (y)), (g_XMExpEst6));
    poly = _mm_add_ps(_mm_mul_ps((poly), (y)), (g_XMExpEst5));
    poly = _mm_add_ps(_mm_mul_ps((poly), (y)), (g_XMExpEst4));
    poly = _mm_add_ps(_mm_mul_ps((poly), (y)), (g_XMExpEst3));
    poly = _mm_add_ps(_mm_mul_ps((poly), (y)), (g_XMExpEst2));
    poly = _mm_add_ps(_mm_mul_ps((poly), (y)), (g_XMExpEst1));
    poly = _mm_add_ps(_mm_mul_ps((poly), (y)), (g_XMOne));

    __m128i biased = _mm_add_epi32(itrunc, g_XMExponentBias);
    biased = _mm_slli_epi32(biased, 23);
    __m128 result0 = _mm_div_ps(_mm_castsi128_ps(biased), poly);

    biased = _mm_add_epi32(itrunc, g_XM253);
    biased = _mm_slli_epi32(biased, 23);
    __m128 result1 = _mm_div_ps(_mm_castsi128_ps(biased), poly);
    result1 = _mm_mul_ps(g_XMMinNormal.v, result1);

    
    
    
    
    
    
    
    
    
    

    __m128i comp = _mm_cmplt_epi32(_mm_castps_si128(V), g_XMBin128);
    __m128i select0 = _mm_and_si128(comp, _mm_castps_si128(result0));
    __m128i select1 = _mm_andnot_si128(comp, g_XMInfinity);
    __m128i result2 = _mm_or_si128(select0, select1);

    comp = _mm_cmplt_epi32(itrunc, g_XMSubnormalExponent);
    select1 = _mm_and_si128(comp, _mm_castps_si128(result1));
    select0 = _mm_andnot_si128(comp, _mm_castps_si128(result0));
    __m128i result3 = _mm_or_si128(select0, select1);

    comp = _mm_cmplt_epi32(_mm_castps_si128(V), g_XMBinNeg150);
    select0 = _mm_and_si128(comp, result3);
    select1 = _mm_andnot_si128(comp, g_XMZero);
    __m128i result4 = _mm_or_si128(select0, select1);

    __m128i sign = _mm_and_si128(_mm_castps_si128(V), g_XMNegativeZero);
    comp = _mm_cmpeq_epi32(sign, g_XMNegativeZero);
    select0 = _mm_and_si128(comp, result4);
    select1 = _mm_andnot_si128(comp, result2);
    __m128i result5 = _mm_or_si128(select0, select1);

    __m128i t0 = _mm_and_si128(_mm_castps_si128(V), g_XMQNaNTest);
    __m128i t1 = _mm_and_si128(_mm_castps_si128(V), g_XMInfinity);
    t0 = _mm_cmpeq_epi32(t0, g_XMZero);
    t1 = _mm_cmpeq_epi32(t1, g_XMInfinity);
    __m128i isNaN = _mm_andnot_si128(t0, t1);

    select0 = _mm_and_si128(isNaN, g_XMQNaN);
    select1 = _mm_andnot_si128(isNaN, result5);
    __m128i vResult = _mm_or_si128(select0, select1);

    return _mm_castsi128_ps(vResult);
#line 3365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorExp10(FXMVECTOR V) noexcept
{










#line 3382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 3385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR Vten = XMVectorMultiply(g_XMLg10, V);
    return XMVectorExp2(Vten);
#line 3389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorExpE(FXMVECTOR V) noexcept
{










#line 3406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 3409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR Ve = XMVectorMultiply(g_XMLgE, V);
    return XMVectorExp2(Ve);
#line 3413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorExp(FXMVECTOR V) noexcept
{
    return XMVectorExp2(V);
}





namespace Internal
{
    inline __m128i multi_sll_epi32(__m128i value, __m128i count) noexcept
    {
        __m128i v = _mm_shuffle_epi32(value, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        __m128i c = _mm_shuffle_epi32(count, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r0 = _mm_sll_epi32(v, c);

        v = _mm_shuffle_epi32(value, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
        c = _mm_shuffle_epi32(count, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r1 = _mm_sll_epi32(v, c);

        v = _mm_shuffle_epi32(value, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
        c = _mm_shuffle_epi32(count, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r2 = _mm_sll_epi32(v, c);

        v = _mm_shuffle_epi32(value, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
        c = _mm_shuffle_epi32(count, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r3 = _mm_sll_epi32(v, c);

        
        __m128 r01 = _mm_shuffle_ps(_mm_castsi128_ps(r0), _mm_castsi128_ps(r1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        
        __m128 r23 = _mm_shuffle_ps(_mm_castsi128_ps(r2), _mm_castsi128_ps(r3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        
        __m128 result = _mm_shuffle_ps(r01, r23, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
        return _mm_castps_si128(result);
    }

    inline __m128i multi_srl_epi32(__m128i value, __m128i count) noexcept
    {
        __m128i v = _mm_shuffle_epi32(value, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        __m128i c = _mm_shuffle_epi32(count, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r0 = _mm_srl_epi32(v, c);

        v = _mm_shuffle_epi32(value, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
        c = _mm_shuffle_epi32(count, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r1 = _mm_srl_epi32(v, c);

        v = _mm_shuffle_epi32(value, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
        c = _mm_shuffle_epi32(count, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r2 = _mm_srl_epi32(v, c);

        v = _mm_shuffle_epi32(value, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
        c = _mm_shuffle_epi32(count, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
        c = _mm_and_si128(c, g_XMMaskX);
        __m128i r3 = _mm_srl_epi32(v, c);

        
        __m128 r01 = _mm_shuffle_ps(_mm_castsi128_ps(r0), _mm_castsi128_ps(r1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        
        __m128 r23 = _mm_shuffle_ps(_mm_castsi128_ps(r2), _mm_castsi128_ps(r3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
        
        __m128 result = _mm_shuffle_ps(r01, r23, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
        return _mm_castps_si128(result);
    }

    inline __m128i GetLeadingBit(const __m128i value) noexcept
    {
        static const XMVECTORI32 g_XM0000FFFF = { { { 0x0000FFFF, 0x0000FFFF, 0x0000FFFF, 0x0000FFFF } } };
        static const XMVECTORI32 g_XM000000FF = { { { 0x000000FF, 0x000000FF, 0x000000FF, 0x000000FF } } };
        static const XMVECTORI32 g_XM0000000F = { { { 0x0000000F, 0x0000000F, 0x0000000F, 0x0000000F } } };
        static const XMVECTORI32 g_XM00000003 = { { { 0x00000003, 0x00000003, 0x00000003, 0x00000003 } } };

        __m128i v = value, r, c, b, s;

        c = _mm_cmpgt_epi32(v, g_XM0000FFFF);   
        b = _mm_srli_epi32(c, 31);              
        r = _mm_slli_epi32(b, 4);               
        v = multi_srl_epi32(v, r);              

        c = _mm_cmpgt_epi32(v, g_XM000000FF);   
        b = _mm_srli_epi32(c, 31);              
        s = _mm_slli_epi32(b, 3);               
        v = multi_srl_epi32(v, s);              
        r = _mm_or_si128(r, s);                 

        c = _mm_cmpgt_epi32(v, g_XM0000000F);   
        b = _mm_srli_epi32(c, 31);              
        s = _mm_slli_epi32(b, 2);               
        v = multi_srl_epi32(v, s);              
        r = _mm_or_si128(r, s);                 

        c = _mm_cmpgt_epi32(v, g_XM00000003);   
        b = _mm_srli_epi32(c, 31);              
        s = _mm_slli_epi32(b, 1);               
        v = multi_srl_epi32(v, s);              
        r = _mm_or_si128(r, s);                 

        s = _mm_srli_epi32(v, 1);
        r = _mm_or_si128(r, s);
        return r;
    }
} 

#line 3529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"














































#line 3576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



inline XMVECTOR __vectorcall XMVectorLog2(FXMVECTOR V) noexcept
{










#line 3592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




























































#line 3653 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 3656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i rawBiased = _mm_and_si128(_mm_castps_si128(V), g_XMInfinity);
    __m128i trailing = _mm_and_si128(_mm_castps_si128(V), g_XMQNaNTest);
    __m128i isExponentZero = _mm_cmpeq_epi32(g_XMZero, rawBiased);

    
    __m128i biased = _mm_srli_epi32(rawBiased, 23);
    __m128i exponentNor = _mm_sub_epi32(biased, g_XMExponentBias);
    __m128i trailingNor = trailing;

    
    __m128i leading = Internal::GetLeadingBit(trailing);
    __m128i shift = _mm_sub_epi32(g_XMNumTrailing, leading);
    __m128i exponentSub = _mm_sub_epi32(g_XMSubnormalExponent, shift);
    __m128i trailingSub = Internal::multi_sll_epi32(trailing, shift);
    trailingSub = _mm_and_si128(trailingSub, g_XMQNaNTest);

    __m128i select0 = _mm_and_si128(isExponentZero, exponentSub);
    __m128i select1 = _mm_andnot_si128(isExponentZero, exponentNor);
    __m128i e = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isExponentZero, trailingSub);
    select1 = _mm_andnot_si128(isExponentZero, trailingNor);
    __m128i t = _mm_or_si128(select0, select1);

    
    __m128i tmp = _mm_or_si128(g_XMOne, t);
    __m128 y = _mm_sub_ps(_mm_castsi128_ps(tmp), g_XMOne);

    __m128 log2 = _mm_add_ps(_mm_mul_ps((g_XMLogEst7), (y)), (g_XMLogEst6));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst5));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst4));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst3));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst2));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst1));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst0));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (_mm_cvtepi32_ps(e)));

    
    
    
    
    
    
    

    __m128i isInfinite = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    isInfinite = _mm_cmpeq_epi32(isInfinite, g_XMInfinity);

    __m128i isGreaterZero = _mm_cmpgt_epi32(_mm_castps_si128(V), g_XMZero);
    __m128i isNotFinite = _mm_cmpgt_epi32(_mm_castps_si128(V), g_XMInfinity);
    __m128i isPositive = _mm_andnot_si128(isNotFinite, isGreaterZero);

    __m128i isZero = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    isZero = _mm_cmpeq_epi32(isZero, g_XMZero);

    __m128i t0 = _mm_and_si128(_mm_castps_si128(V), g_XMQNaNTest);
    __m128i t1 = _mm_and_si128(_mm_castps_si128(V), g_XMInfinity);
    t0 = _mm_cmpeq_epi32(t0, g_XMZero);
    t1 = _mm_cmpeq_epi32(t1, g_XMInfinity);
    __m128i isNaN = _mm_andnot_si128(t0, t1);

    select0 = _mm_and_si128(isInfinite, g_XMInfinity);
    select1 = _mm_andnot_si128(isInfinite, _mm_castps_si128(log2));
    __m128i result = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isZero, g_XMNegInfinity);
    select1 = _mm_andnot_si128(isZero, g_XMNegQNaN);
    tmp = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isPositive, result);
    select1 = _mm_andnot_si128(isPositive, tmp);
    result = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isNaN, g_XMQNaN);
    select1 = _mm_andnot_si128(isNaN, result);
    result = _mm_or_si128(select0, select1);

    return _mm_castsi128_ps(result);
#line 3735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorLog10(FXMVECTOR V) noexcept
{










#line 3752 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






























































#line 3815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 3818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i rawBiased = _mm_and_si128(_mm_castps_si128(V), g_XMInfinity);
    __m128i trailing = _mm_and_si128(_mm_castps_si128(V), g_XMQNaNTest);
    __m128i isExponentZero = _mm_cmpeq_epi32(g_XMZero, rawBiased);

    
    __m128i biased = _mm_srli_epi32(rawBiased, 23);
    __m128i exponentNor = _mm_sub_epi32(biased, g_XMExponentBias);
    __m128i trailingNor = trailing;

    
    __m128i leading = Internal::GetLeadingBit(trailing);
    __m128i shift = _mm_sub_epi32(g_XMNumTrailing, leading);
    __m128i exponentSub = _mm_sub_epi32(g_XMSubnormalExponent, shift);
    __m128i trailingSub = Internal::multi_sll_epi32(trailing, shift);
    trailingSub = _mm_and_si128(trailingSub, g_XMQNaNTest);

    __m128i select0 = _mm_and_si128(isExponentZero, exponentSub);
    __m128i select1 = _mm_andnot_si128(isExponentZero, exponentNor);
    __m128i e = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isExponentZero, trailingSub);
    select1 = _mm_andnot_si128(isExponentZero, trailingNor);
    __m128i t = _mm_or_si128(select0, select1);

    
    __m128i tmp = _mm_or_si128(g_XMOne, t);
    __m128 y = _mm_sub_ps(_mm_castsi128_ps(tmp), g_XMOne);

    __m128 log2 = _mm_add_ps(_mm_mul_ps((g_XMLogEst7), (y)), (g_XMLogEst6));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst5));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst4));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst3));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst2));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst1));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst0));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (_mm_cvtepi32_ps(e)));

    log2 = _mm_mul_ps(g_XMInvLg10, log2);

    
    
    
    
    
    
    

    __m128i isInfinite = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    isInfinite = _mm_cmpeq_epi32(isInfinite, g_XMInfinity);

    __m128i isGreaterZero = _mm_cmpgt_epi32(_mm_castps_si128(V), g_XMZero);
    __m128i isNotFinite = _mm_cmpgt_epi32(_mm_castps_si128(V), g_XMInfinity);
    __m128i isPositive = _mm_andnot_si128(isNotFinite, isGreaterZero);

    __m128i isZero = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    isZero = _mm_cmpeq_epi32(isZero, g_XMZero);

    __m128i t0 = _mm_and_si128(_mm_castps_si128(V), g_XMQNaNTest);
    __m128i t1 = _mm_and_si128(_mm_castps_si128(V), g_XMInfinity);
    t0 = _mm_cmpeq_epi32(t0, g_XMZero);
    t1 = _mm_cmpeq_epi32(t1, g_XMInfinity);
    __m128i isNaN = _mm_andnot_si128(t0, t1);

    select0 = _mm_and_si128(isInfinite, g_XMInfinity);
    select1 = _mm_andnot_si128(isInfinite, _mm_castps_si128(log2));
    __m128i result = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isZero, g_XMNegInfinity);
    select1 = _mm_andnot_si128(isZero, g_XMNegQNaN);
    tmp = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isPositive, result);
    select1 = _mm_andnot_si128(isPositive, tmp);
    result = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isNaN, g_XMQNaN);
    select1 = _mm_andnot_si128(isNaN, result);
    result = _mm_or_si128(select0, select1);

    return _mm_castsi128_ps(result);
#line 3899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorLogE(FXMVECTOR V) noexcept
{










#line 3916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






























































#line 3979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 3982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i rawBiased = _mm_and_si128(_mm_castps_si128(V), g_XMInfinity);
    __m128i trailing = _mm_and_si128(_mm_castps_si128(V), g_XMQNaNTest);
    __m128i isExponentZero = _mm_cmpeq_epi32(g_XMZero, rawBiased);

    
    __m128i biased = _mm_srli_epi32(rawBiased, 23);
    __m128i exponentNor = _mm_sub_epi32(biased, g_XMExponentBias);
    __m128i trailingNor = trailing;

    
    __m128i leading = Internal::GetLeadingBit(trailing);
    __m128i shift = _mm_sub_epi32(g_XMNumTrailing, leading);
    __m128i exponentSub = _mm_sub_epi32(g_XMSubnormalExponent, shift);
    __m128i trailingSub = Internal::multi_sll_epi32(trailing, shift);
    trailingSub = _mm_and_si128(trailingSub, g_XMQNaNTest);

    __m128i select0 = _mm_and_si128(isExponentZero, exponentSub);
    __m128i select1 = _mm_andnot_si128(isExponentZero, exponentNor);
    __m128i e = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isExponentZero, trailingSub);
    select1 = _mm_andnot_si128(isExponentZero, trailingNor);
    __m128i t = _mm_or_si128(select0, select1);

    
    __m128i tmp = _mm_or_si128(g_XMOne, t);
    __m128 y = _mm_sub_ps(_mm_castsi128_ps(tmp), g_XMOne);

    __m128 log2 = _mm_add_ps(_mm_mul_ps((g_XMLogEst7), (y)), (g_XMLogEst6));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst5));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst4));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst3));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst2));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst1));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (g_XMLogEst0));
    log2 = _mm_add_ps(_mm_mul_ps((log2), (y)), (_mm_cvtepi32_ps(e)));

    log2 = _mm_mul_ps(g_XMInvLgE, log2);

    
    
    
    
    
    
    

    __m128i isInfinite = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    isInfinite = _mm_cmpeq_epi32(isInfinite, g_XMInfinity);

    __m128i isGreaterZero = _mm_cmpgt_epi32(_mm_castps_si128(V), g_XMZero);
    __m128i isNotFinite = _mm_cmpgt_epi32(_mm_castps_si128(V), g_XMInfinity);
    __m128i isPositive = _mm_andnot_si128(isNotFinite, isGreaterZero);

    __m128i isZero = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask);
    isZero = _mm_cmpeq_epi32(isZero, g_XMZero);

    __m128i t0 = _mm_and_si128(_mm_castps_si128(V), g_XMQNaNTest);
    __m128i t1 = _mm_and_si128(_mm_castps_si128(V), g_XMInfinity);
    t0 = _mm_cmpeq_epi32(t0, g_XMZero);
    t1 = _mm_cmpeq_epi32(t1, g_XMInfinity);
    __m128i isNaN = _mm_andnot_si128(t0, t1);

    select0 = _mm_and_si128(isInfinite, g_XMInfinity);
    select1 = _mm_andnot_si128(isInfinite, _mm_castps_si128(log2));
    __m128i result = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isZero, g_XMNegInfinity);
    select1 = _mm_andnot_si128(isZero, g_XMNegQNaN);
    tmp = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isPositive, result);
    select1 = _mm_andnot_si128(isPositive, tmp);
    result = _mm_or_si128(select0, select1);

    select0 = _mm_and_si128(isNaN, g_XMQNaN);
    select1 = _mm_andnot_si128(isNaN, result);
    result = _mm_or_si128(select0, select1);

    return _mm_castsi128_ps(result);
#line 4063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorLog(FXMVECTOR V) noexcept
{
    return XMVectorLog2(V);
}



inline XMVECTOR __vectorcall XMVectorPow
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{










#line 4091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 4099 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __declspec(align(16)) float a[4];
    __declspec(align(16)) float b[4];
    _mm_store_ps(a, V1);
    _mm_store_ps(b, V2);
    XMVECTOR vResult = _mm_setr_ps(
        powf(a[0], b[0]),
        powf(a[1], b[1]),
        powf(a[2], b[2]),
        powf(a[3], b[3]));
    return vResult;
#line 4113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorAbs(FXMVECTOR V) noexcept
{








#line 4128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 4130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_setzero_ps();
    vResult = _mm_sub_ps(vResult, V);
    vResult = _mm_max_ps(vResult, V);
    return vResult;
#line 4135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorMod
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    








#line 4155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 4159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_div_ps(V1, V2);
    vResult = XMVectorTruncate(vResult);
    return _mm_sub_ps((V1), _mm_mul_ps((vResult), (V2)));
#line 4163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorModAngles(FXMVECTOR Angles) noexcept
{











#line 4181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 4187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_mul_ps(Angles, g_XMReciprocalTwoPi);
    
    vResult = XMVectorRound(vResult);
    return _mm_sub_ps((Angles), _mm_mul_ps((vResult), (g_XMTwoPi)));
#line 4193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSin(FXMVECTOR V) noexcept
{
    









#line 4210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"































#line 4242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR x = XMVectorModAngles(V);

    
    __m128 sign = _mm_and_ps(x, g_XMNegativeZero);
    __m128 c = _mm_or_ps(g_XMPi, sign);  
    __m128 absx = _mm_andnot_ps(sign, x);  
    __m128 rflx = _mm_sub_ps(c, x);
    __m128 comp = _mm_cmple_ps(absx, g_XMHalfPi);
    __m128 select0 = _mm_and_ps(comp, x);
    __m128 select1 = _mm_andnot_ps(comp, rflx);
    x = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR SC1 = g_XMSinCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((SC1), (SC1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    const XMVECTOR SC0 = g_XMSinCoefficients0;
    __m128 vConstants = _mm_shuffle_ps((SC0), (SC0), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SC0), (SC0), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SC0), (SC0), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SC0), (SC0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, x);
    return Result;
#line 4280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorCos(FXMVECTOR V) noexcept
{
    









#line 4297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
































#line 4330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR x = XMVectorModAngles(V);

    
    XMVECTOR sign = _mm_and_ps(x, g_XMNegativeZero);
    __m128 c = _mm_or_ps(g_XMPi, sign);  
    __m128 absx = _mm_andnot_ps(sign, x);  
    __m128 rflx = _mm_sub_ps(c, x);
    __m128 comp = _mm_cmple_ps(absx, g_XMHalfPi);
    __m128 select0 = _mm_and_ps(comp, x);
    __m128 select1 = _mm_andnot_ps(comp, rflx);
    x = _mm_or_ps(select0, select1);
    select0 = _mm_and_ps(comp, g_XMOne);
    select1 = _mm_andnot_ps(comp, g_XMNegativeOne);
    sign = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR CC1 = g_XMCosCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((CC1), (CC1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    const XMVECTOR CC0 = g_XMCosCoefficients0;
    __m128 vConstants = _mm_shuffle_ps((CC0), (CC0), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CC0), (CC0), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CC0), (CC0), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CC0), (CC0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, sign);
    return Result;
#line 4371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline void __vectorcall XMVectorSinCos
(
    XMVECTOR* pSin,
    XMVECTOR* pCos,
    FXMVECTOR V
) noexcept
{
    (void)( (!!(pSin != nullptr)) || (_wassert(L"pSin != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(4383)), 0) );
    (void)( (!!(pCos != nullptr)) || (_wassert(L"pCos != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(4384)), 0) );

    


















#line 4406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















































#line 4456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 4458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR x = XMVectorModAngles(V);

    
    XMVECTOR sign = _mm_and_ps(x, g_XMNegativeZero);
    __m128 c = _mm_or_ps(g_XMPi, sign);  
    __m128 absx = _mm_andnot_ps(sign, x);  
    __m128 rflx = _mm_sub_ps(c, x);
    __m128 comp = _mm_cmple_ps(absx, g_XMHalfPi);
    __m128 select0 = _mm_and_ps(comp, x);
    __m128 select1 = _mm_andnot_ps(comp, rflx);
    x = _mm_or_ps(select0, select1);
    select0 = _mm_and_ps(comp, g_XMOne);
    select1 = _mm_andnot_ps(comp, g_XMNegativeOne);
    sign = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR SC1 = g_XMSinCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((SC1), (SC1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    const XMVECTOR SC0 = g_XMSinCoefficients0;
    __m128 vConstants = _mm_shuffle_ps((SC0), (SC0), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SC0), (SC0), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SC0), (SC0), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SC0), (SC0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, x);
    *pSin = Result;

    
    const XMVECTOR CC1 = g_XMCosCoefficients1;
    vConstantsB = _mm_shuffle_ps((CC1), (CC1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    const XMVECTOR CC0 = g_XMCosCoefficients0;
    vConstants = _mm_shuffle_ps((CC0), (CC0), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CC0), (CC0), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CC0), (CC0), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CC0), (CC0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, sign);
    *pCos = Result;
#line 4516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorTan(FXMVECTOR V) noexcept
{
    









#line 4533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

    static const XMVECTORF32 TanCoefficients0 = { { { 1.0f, -4.667168334e-1f, 2.566383229e-2f, -3.118153191e-4f } } };
    static const XMVECTORF32 TanCoefficients1 = { { { 4.981943399e-7f, -1.333835001e-1f, 3.424887824e-3f, -1.786170734e-5f } } };
    static const XMVECTORF32 TanConstants = { { { 1.570796371f, 6.077100628e-11f, 0.000244140625f, 0.63661977228f  } } };
    static const XMVECTORU32 Mask = { { { 0x1, 0x1, 0x1, 0x1 } } };

    XMVECTOR TwoDivPi = XMVectorSplatW(TanConstants.v);

    XMVECTOR Zero = XMVectorZero();

    XMVECTOR C0 = XMVectorSplatX(TanConstants.v);
    XMVECTOR C1 = XMVectorSplatY(TanConstants.v);
    XMVECTOR Epsilon = XMVectorSplatZ(TanConstants.v);

    XMVECTOR VA = XMVectorMultiply(V, TwoDivPi);

    VA = XMVectorRound(VA);

    XMVECTOR VC = XMVectorNegativeMultiplySubtract(VA, C0, V);

    XMVECTOR VB = XMVectorAbs(VA);

    VC = XMVectorNegativeMultiplySubtract(VA, C1, VC);



#line 4563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    reinterpret_cast<__m128i*>(&VB)[0] = _mm_cvttps_epi32(VB);





#line 4570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

    XMVECTOR VC2 = XMVectorMultiply(VC, VC);

    XMVECTOR T7 = XMVectorSplatW(TanCoefficients1.v);
    XMVECTOR T6 = XMVectorSplatZ(TanCoefficients1.v);
    XMVECTOR T4 = XMVectorSplatX(TanCoefficients1.v);
    XMVECTOR T3 = XMVectorSplatW(TanCoefficients0.v);
    XMVECTOR T5 = XMVectorSplatY(TanCoefficients1.v);
    XMVECTOR T2 = XMVectorSplatZ(TanCoefficients0.v);
    XMVECTOR T1 = XMVectorSplatY(TanCoefficients0.v);
    XMVECTOR T0 = XMVectorSplatX(TanCoefficients0.v);

    XMVECTOR VBIsEven = XMVectorAndInt(VB, Mask.v);
    VBIsEven = XMVectorEqualInt(VBIsEven, Zero);

    XMVECTOR N = XMVectorMultiplyAdd(VC2, T7, T6);
    XMVECTOR D = XMVectorMultiplyAdd(VC2, T4, T3);
    N = XMVectorMultiplyAdd(VC2, N, T5);
    D = XMVectorMultiplyAdd(VC2, D, T2);
    N = XMVectorMultiply(VC2, N);
    D = XMVectorMultiplyAdd(VC2, D, T1);
    N = XMVectorMultiplyAdd(VC, N, VC);
    XMVECTOR VCNearZero = XMVectorInBounds(VC, Epsilon);
    D = XMVectorMultiplyAdd(VC2, D, T0);

    N = XMVectorSelect(N, VC, VCNearZero);
    D = XMVectorSelect(D, g_XMOne.v, VCNearZero);

    XMVECTOR R0 = XMVectorNegate(N);
    XMVECTOR R1 = XMVectorDivide(N, D);
    R0 = XMVectorDivide(D, R0);

    XMVECTOR VIsZero = XMVectorEqual(V, Zero);

    XMVECTOR Result = XMVectorSelect(R0, R1, VBIsEven);

    Result = XMVectorSelect(Result, Zero, VIsZero);

    return Result;

#line 4611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSinH(FXMVECTOR V) noexcept
{








#line 4626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"








#line 4635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    static const XMVECTORF32 Scale = { { { 1.442695040888963f, 1.442695040888963f, 1.442695040888963f, 1.442695040888963f } } }; 

    XMVECTOR V1 = _mm_add_ps(_mm_mul_ps((V), (Scale)), (g_XMNegativeOne));
    XMVECTOR V2 = _mm_sub_ps((g_XMNegativeOne), _mm_mul_ps((V), (Scale)));
    XMVECTOR E1 = XMVectorExp(V1);
    XMVECTOR E2 = XMVectorExp(V2);

    return _mm_sub_ps(E1, E2);
#line 4647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorCosH(FXMVECTOR V) noexcept
{








#line 4662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 4670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    static const XMVECTORF32 Scale = { { { 1.442695040888963f, 1.442695040888963f, 1.442695040888963f, 1.442695040888963f } } }; 

    XMVECTOR V1 = _mm_add_ps(_mm_mul_ps((V), (Scale.v)), (g_XMNegativeOne.v));
    XMVECTOR V2 = _mm_sub_ps((g_XMNegativeOne.v), _mm_mul_ps((V), (Scale.v)));
    XMVECTOR E1 = XMVectorExp(V1);
    XMVECTOR E2 = XMVectorExp(V2);
    return _mm_add_ps(E1, E2);
#line 4681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorTanH(FXMVECTOR V) noexcept
{








#line 4696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 4704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4707 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    static const XMVECTORF32 Scale = { { { 2.8853900817779268f, 2.8853900817779268f, 2.8853900817779268f, 2.8853900817779268f } } }; 

    XMVECTOR E = _mm_mul_ps(V, Scale.v);
    E = XMVectorExp(E);
    E = _mm_add_ps(_mm_mul_ps((E), (g_XMOneHalf.v)), (g_XMOneHalf.v));
    E = _mm_div_ps(g_XMOne.v, E);
    return _mm_sub_ps(g_XMOne.v, E);
#line 4715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorASin(FXMVECTOR V) noexcept
{
    









#line 4732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





































#line 4770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128 nonnegative = _mm_cmpge_ps(V, g_XMZero);
    __m128 mvalue = _mm_sub_ps(g_XMZero, V);
    __m128 x = _mm_max_ps(V, mvalue);  

    
    __m128 oneMValue = _mm_sub_ps(g_XMOne, x);
    __m128 clampOneMValue = _mm_max_ps(g_XMZero, oneMValue);
    __m128 root = _mm_sqrt_ps(clampOneMValue);  

    
    const XMVECTOR AC1 = g_XMArcCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((AC1), (AC1), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((AC1), (AC1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 t0 = _mm_add_ps(_mm_mul_ps((vConstantsB), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC1), (AC1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC1), (AC1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    const XMVECTOR AC0 = g_XMArcCoefficients0;
    vConstants = _mm_shuffle_ps((AC0), (AC0), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC0), (AC0), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC0), (AC0), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC0), (AC0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));
    t0 = _mm_mul_ps(t0, root);

    __m128 t1 = _mm_sub_ps(g_XMPi, t0);
    t0 = _mm_and_ps(nonnegative, t0);
    t1 = _mm_andnot_ps(nonnegative, t1);
    t0 = _mm_or_ps(t0, t1);
    t0 = _mm_sub_ps(g_XMHalfPi, t0);
    return t0;
#line 4815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorACos(FXMVECTOR V) noexcept
{
    









#line 4832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




































#line 4869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128 nonnegative = _mm_cmpge_ps(V, g_XMZero);
    __m128 mvalue = _mm_sub_ps(g_XMZero, V);
    __m128 x = _mm_max_ps(V, mvalue);  

    
    __m128 oneMValue = _mm_sub_ps(g_XMOne, x);
    __m128 clampOneMValue = _mm_max_ps(g_XMZero, oneMValue);
    __m128 root = _mm_sqrt_ps(clampOneMValue);  

    
    const XMVECTOR AC1 = g_XMArcCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((AC1), (AC1), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((AC1), (AC1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 t0 = _mm_add_ps(_mm_mul_ps((vConstantsB), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC1), (AC1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC1), (AC1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    const XMVECTOR AC0 = g_XMArcCoefficients0;
    vConstants = _mm_shuffle_ps((AC0), (AC0), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC0), (AC0), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC0), (AC0), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AC0), (AC0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));
    t0 = _mm_mul_ps(t0, root);

    __m128 t1 = _mm_sub_ps(g_XMPi, t0);
    t0 = _mm_and_ps(nonnegative, t0);
    t1 = _mm_andnot_ps(nonnegative, t1);
    t0 = _mm_or_ps(t0, t1);
    return t0;
#line 4913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorATan(FXMVECTOR V) noexcept
{
    









#line 4930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











































#line 4974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 4977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128 absV = XMVectorAbs(V);
    __m128 invV = _mm_div_ps(g_XMOne, V);
    __m128 comp = _mm_cmpgt_ps(V, g_XMOne);
    __m128 select0 = _mm_and_ps(comp, g_XMOne);
    __m128 select1 = _mm_andnot_ps(comp, g_XMNegativeOne);
    __m128 sign = _mm_or_ps(select0, select1);
    comp = _mm_cmple_ps(absV, g_XMOne);
    select0 = _mm_and_ps(comp, g_XMZero);
    select1 = _mm_andnot_ps(comp, sign);
    sign = _mm_or_ps(select0, select1);
    select0 = _mm_and_ps(comp, V);
    select1 = _mm_andnot_ps(comp, invV);
    __m128 x = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR TC1 = g_XMATanCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((TC1), (TC1), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((TC1), (TC1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((TC1), (TC1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((TC1), (TC1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    const XMVECTOR TC0 = g_XMATanCoefficients0;
    vConstants = _mm_shuffle_ps((TC0), (TC0), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((TC0), (TC0), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((TC0), (TC0), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((TC0), (TC0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));

    Result = _mm_mul_ps(Result, x);
    __m128 result1 = _mm_mul_ps(sign, g_XMHalfPi);
    result1 = _mm_sub_ps(result1, Result);

    comp = _mm_cmpeq_ps(sign, g_XMZero);
    select0 = _mm_and_ps(comp, Result);
    select1 = _mm_andnot_ps(comp, result1);
    Result = _mm_or_ps(select0, select1);
    return Result;
#line 5030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorATan2
(
    FXMVECTOR Y,
    FXMVECTOR X
) noexcept
{








#line 5049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5052 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

    

    
    
    
    
    
    
    
    
    

    static const XMVECTORF32 ATan2Constants = { { { XM_PI, XM_PIDIV2, XM_PIDIV4, XM_PI * 3.0f / 4.0f } } };

    XMVECTOR Zero = XMVectorZero();
    XMVECTOR ATanResultValid = XMVectorTrueInt();

    XMVECTOR Pi = XMVectorSplatX(ATan2Constants);
    XMVECTOR PiOverTwo = XMVectorSplatY(ATan2Constants);
    XMVECTOR PiOverFour = XMVectorSplatZ(ATan2Constants);
    XMVECTOR ThreePiOverFour = XMVectorSplatW(ATan2Constants);

    XMVECTOR YEqualsZero = XMVectorEqual(Y, Zero);
    XMVECTOR XEqualsZero = XMVectorEqual(X, Zero);
    XMVECTOR XIsPositive = XMVectorAndInt(X, g_XMNegativeZero.v);
    XIsPositive = XMVectorEqualInt(XIsPositive, Zero);
    XMVECTOR YEqualsInfinity = XMVectorIsInfinite(Y);
    XMVECTOR XEqualsInfinity = XMVectorIsInfinite(X);

    XMVECTOR YSign = XMVectorAndInt(Y, g_XMNegativeZero.v);
    Pi = XMVectorOrInt(Pi, YSign);
    PiOverTwo = XMVectorOrInt(PiOverTwo, YSign);
    PiOverFour = XMVectorOrInt(PiOverFour, YSign);
    ThreePiOverFour = XMVectorOrInt(ThreePiOverFour, YSign);

    XMVECTOR R1 = XMVectorSelect(Pi, YSign, XIsPositive);
    XMVECTOR R2 = XMVectorSelect(ATanResultValid, PiOverTwo, XEqualsZero);
    XMVECTOR R3 = XMVectorSelect(R2, R1, YEqualsZero);
    XMVECTOR R4 = XMVectorSelect(ThreePiOverFour, PiOverFour, XIsPositive);
    XMVECTOR R5 = XMVectorSelect(PiOverTwo, R4, XEqualsInfinity);
    XMVECTOR Result = XMVectorSelect(R3, R5, YEqualsInfinity);
    ATanResultValid = XMVectorEqualInt(Result, ATanResultValid);

    XMVECTOR V = XMVectorDivide(Y, X);

    XMVECTOR R0 = XMVectorATan(V);

    R1 = XMVectorSelect(Pi, g_XMNegativeZero, XIsPositive);
    R2 = XMVectorAdd(R0, R1);

    return XMVectorSelect(Result, R2, ATanResultValid);

#line 5106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorSinEst(FXMVECTOR V) noexcept
{
    









#line 5123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
























#line 5148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR x = XMVectorModAngles(V);

    
    __m128 sign = _mm_and_ps(x, g_XMNegativeZero);
    __m128 c = _mm_or_ps(g_XMPi, sign);  
    __m128 absx = _mm_andnot_ps(sign, x);  
    __m128 rflx = _mm_sub_ps(c, x);
    __m128 comp = _mm_cmple_ps(absx, g_XMHalfPi);
    __m128 select0 = _mm_and_ps(comp, x);
    __m128 select1 = _mm_andnot_ps(comp, rflx);
    x = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR SEC = g_XMSinCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((SEC), (SEC), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((SEC), (SEC), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SEC), (SEC), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, x);
    return Result;
#line 5178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorCosEst(FXMVECTOR V) noexcept
{
    









#line 5195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

























#line 5221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR x = XMVectorModAngles(V);

    
    XMVECTOR sign = _mm_and_ps(x, g_XMNegativeZero);
    __m128 c = _mm_or_ps(g_XMPi, sign);  
    __m128 absx = _mm_andnot_ps(sign, x);  
    __m128 rflx = _mm_sub_ps(c, x);
    __m128 comp = _mm_cmple_ps(absx, g_XMHalfPi);
    __m128 select0 = _mm_and_ps(comp, x);
    __m128 select1 = _mm_andnot_ps(comp, rflx);
    x = _mm_or_ps(select0, select1);
    select0 = _mm_and_ps(comp, g_XMOne);
    select1 = _mm_andnot_ps(comp, g_XMNegativeOne);
    sign = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR CEC = g_XMCosCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((CEC), (CEC), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((CEC), (CEC), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CEC), (CEC), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, sign);
    return Result;
#line 5254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline void __vectorcall XMVectorSinCosEst
(
    XMVECTOR* pSin,
    XMVECTOR* pCos,
    FXMVECTOR  V
) noexcept
{
    (void)( (!!(pSin != nullptr)) || (_wassert(L"pSin != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(5266)), 0) );
    (void)( (!!(pCos != nullptr)) || (_wassert(L"pCos != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(5267)), 0) );

    


















#line 5289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



































#line 5325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR x = XMVectorModAngles(V);

    
    XMVECTOR sign = _mm_and_ps(x, g_XMNegativeZero);
    __m128 c = _mm_or_ps(g_XMPi, sign);  
    __m128 absx = _mm_andnot_ps(sign, x);  
    __m128 rflx = _mm_sub_ps(c, x);
    __m128 comp = _mm_cmple_ps(absx, g_XMHalfPi);
    __m128 select0 = _mm_and_ps(comp, x);
    __m128 select1 = _mm_andnot_ps(comp, rflx);
    x = _mm_or_ps(select0, select1);
    select0 = _mm_and_ps(comp, g_XMOne);
    select1 = _mm_andnot_ps(comp, g_XMNegativeOne);
    sign = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR SEC = g_XMSinCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((SEC), (SEC), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((SEC), (SEC), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((SEC), (SEC), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, x);
    *pSin = Result;

    
    const XMVECTOR CEC = g_XMCosCoefficients1;
    vConstantsB = _mm_shuffle_ps((CEC), (CEC), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    vConstants = _mm_shuffle_ps((CEC), (CEC), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((CEC), (CEC), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMOne));
    Result = _mm_mul_ps(Result, sign);
    *pCos = Result;
#line 5367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorTanEst(FXMVECTOR V) noexcept
{








#line 5382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

    XMVECTOR OneOverPi = XMVectorSplatW(g_XMTanEstCoefficients.v);

    XMVECTOR V1 = XMVectorMultiply(V, OneOverPi);
    V1 = XMVectorRound(V1);

    V1 = XMVectorNegativeMultiplySubtract(g_XMPi.v, V1, V);

    XMVECTOR T0 = XMVectorSplatX(g_XMTanEstCoefficients.v);
    XMVECTOR T1 = XMVectorSplatY(g_XMTanEstCoefficients.v);
    XMVECTOR T2 = XMVectorSplatZ(g_XMTanEstCoefficients.v);

    XMVECTOR V2T2 = XMVectorNegativeMultiplySubtract(V1, V1, T2);
    XMVECTOR V2 = XMVectorMultiply(V1, V1);
    XMVECTOR V1T0 = XMVectorMultiply(V1, T0);
    XMVECTOR V1T1 = XMVectorMultiply(V1, T1);

    XMVECTOR D = XMVectorReciprocalEst(V2T2);
    XMVECTOR N = XMVectorMultiplyAdd(V2, V1T1, V1T0);

    return XMVectorMultiply(N, D);

#line 5408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorASinEst(FXMVECTOR V) noexcept
{
    








#line 5424 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
























#line 5449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128 nonnegative = _mm_cmpge_ps(V, g_XMZero);
    __m128 mvalue = _mm_sub_ps(g_XMZero, V);
    __m128 x = _mm_max_ps(V, mvalue);  

    
    __m128 oneMValue = _mm_sub_ps(g_XMOne, x);
    __m128 clampOneMValue = _mm_max_ps(g_XMZero, oneMValue);
    __m128 root = _mm_sqrt_ps(clampOneMValue);  

    
    const XMVECTOR AEC = g_XMArcEstCoefficients;
    __m128 vConstantsB = _mm_shuffle_ps((AEC), (AEC), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((AEC), (AEC), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 t0 = _mm_add_ps(_mm_mul_ps((vConstantsB), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AEC), (AEC), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AEC), (AEC), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));
    t0 = _mm_mul_ps(t0, root);

    __m128 t1 = _mm_sub_ps(g_XMPi, t0);
    t0 = _mm_and_ps(nonnegative, t0);
    t1 = _mm_andnot_ps(nonnegative, t1);
    t0 = _mm_or_ps(t0, t1);
    t0 = _mm_sub_ps(g_XMHalfPi, t0);
    return t0;
#line 5481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorACosEst(FXMVECTOR V) noexcept
{
    









#line 5498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"























#line 5522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5525 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128 nonnegative = _mm_cmpge_ps(V, g_XMZero);
    __m128 mvalue = _mm_sub_ps(g_XMZero, V);
    __m128 x = _mm_max_ps(V, mvalue);  

    
    __m128 oneMValue = _mm_sub_ps(g_XMOne, x);
    __m128 clampOneMValue = _mm_max_ps(g_XMZero, oneMValue);
    __m128 root = _mm_sqrt_ps(clampOneMValue);  

    
    const XMVECTOR AEC = g_XMArcEstCoefficients;
    __m128 vConstantsB = _mm_shuffle_ps((AEC), (AEC), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((AEC), (AEC), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 t0 = _mm_add_ps(_mm_mul_ps((vConstantsB), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AEC), (AEC), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));

    vConstants = _mm_shuffle_ps((AEC), (AEC), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    t0 = _mm_add_ps(_mm_mul_ps((t0), (x)), (vConstants));
    t0 = _mm_mul_ps(t0, root);

    __m128 t1 = _mm_sub_ps(g_XMPi, t0);
    t0 = _mm_and_ps(nonnegative, t0);
    t1 = _mm_andnot_ps(nonnegative, t1);
    t0 = _mm_or_ps(t0, t1);
    return t0;
#line 5553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorATanEst(FXMVECTOR V) noexcept
{
    









#line 5570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"































#line 5602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128 absV = XMVectorAbs(V);
    __m128 invV = _mm_div_ps(g_XMOne, V);
    __m128 comp = _mm_cmpgt_ps(V, g_XMOne);
    __m128 select0 = _mm_and_ps(comp, g_XMOne);
    __m128 select1 = _mm_andnot_ps(comp, g_XMNegativeOne);
    __m128 sign = _mm_or_ps(select0, select1);
    comp = _mm_cmple_ps(absV, g_XMOne);
    select0 = _mm_and_ps(comp, g_XMZero);
    select1 = _mm_andnot_ps(comp, sign);
    sign = _mm_or_ps(select0, select1);
    select0 = _mm_and_ps(comp, V);
    select1 = _mm_andnot_ps(comp, invV);
    __m128 x = _mm_or_ps(select0, select1);

    __m128 x2 = _mm_mul_ps(x, x);

    
    const XMVECTOR AEC = g_XMATanEstCoefficients1;
    __m128 vConstantsB = _mm_shuffle_ps((AEC), (AEC), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    __m128 vConstants = _mm_shuffle_ps((AEC), (AEC), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    __m128 Result = _mm_add_ps(_mm_mul_ps((vConstantsB), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((AEC), (AEC), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));

    vConstants = _mm_shuffle_ps((AEC), (AEC), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (vConstants));
    
    Result = _mm_add_ps(_mm_mul_ps((Result), (x2)), (g_XMATanEstCoefficients0));
    Result = _mm_mul_ps(Result, x);
    __m128 result1 = _mm_mul_ps(sign, g_XMHalfPi);
    result1 = _mm_sub_ps(result1, Result);

    comp = _mm_cmpeq_ps(sign, g_XMZero);
    select0 = _mm_and_ps(comp, Result);
    select1 = _mm_andnot_ps(comp, result1);
    Result = _mm_or_ps(select0, select1);
    return Result;
#line 5644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorATan2Est
(
    FXMVECTOR Y,
    FXMVECTOR X
) noexcept
{








#line 5663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5666 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

    static const XMVECTORF32 ATan2Constants = { { { XM_PI, XM_PIDIV2, XM_PIDIV4, 2.3561944905f  } } };

    const XMVECTOR Zero = XMVectorZero();
    XMVECTOR ATanResultValid = XMVectorTrueInt();

    XMVECTOR Pi = XMVectorSplatX(ATan2Constants);
    XMVECTOR PiOverTwo = XMVectorSplatY(ATan2Constants);
    XMVECTOR PiOverFour = XMVectorSplatZ(ATan2Constants);
    XMVECTOR ThreePiOverFour = XMVectorSplatW(ATan2Constants);

    XMVECTOR YEqualsZero = XMVectorEqual(Y, Zero);
    XMVECTOR XEqualsZero = XMVectorEqual(X, Zero);
    XMVECTOR XIsPositive = XMVectorAndInt(X, g_XMNegativeZero.v);
    XIsPositive = XMVectorEqualInt(XIsPositive, Zero);
    XMVECTOR YEqualsInfinity = XMVectorIsInfinite(Y);
    XMVECTOR XEqualsInfinity = XMVectorIsInfinite(X);

    XMVECTOR YSign = XMVectorAndInt(Y, g_XMNegativeZero.v);
    Pi = XMVectorOrInt(Pi, YSign);
    PiOverTwo = XMVectorOrInt(PiOverTwo, YSign);
    PiOverFour = XMVectorOrInt(PiOverFour, YSign);
    ThreePiOverFour = XMVectorOrInt(ThreePiOverFour, YSign);

    XMVECTOR R1 = XMVectorSelect(Pi, YSign, XIsPositive);
    XMVECTOR R2 = XMVectorSelect(ATanResultValid, PiOverTwo, XEqualsZero);
    XMVECTOR R3 = XMVectorSelect(R2, R1, YEqualsZero);
    XMVECTOR R4 = XMVectorSelect(ThreePiOverFour, PiOverFour, XIsPositive);
    XMVECTOR R5 = XMVectorSelect(PiOverTwo, R4, XEqualsInfinity);
    XMVECTOR Result = XMVectorSelect(R3, R5, YEqualsInfinity);
    ATanResultValid = XMVectorEqualInt(Result, ATanResultValid);

    XMVECTOR Reciprocal = XMVectorReciprocalEst(X);
    XMVECTOR V = XMVectorMultiply(Y, Reciprocal);
    XMVECTOR R0 = XMVectorATanEst(V);

    R1 = XMVectorSelect(Pi, g_XMNegativeZero, XIsPositive);
    R2 = XMVectorAdd(R0, R1);

    Result = XMVectorSelect(Result, R2, ATanResultValid);

    return Result;

#line 5710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorLerp
(
    FXMVECTOR V0,
    FXMVECTOR V1,
    float    t
) noexcept
{
    







#line 5730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR L = _mm_sub_ps(V1, V0);
    XMVECTOR S = _mm_set_ps1(t);
    return _mm_add_ps(_mm_mul_ps((L), (S)), (V0));
#line 5737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorLerpV
(
    FXMVECTOR V0,
    FXMVECTOR V1,
    FXMVECTOR T
) noexcept
{
    






#line 5756 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 5759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR Length = _mm_sub_ps(V1, V0);
    return _mm_add_ps(_mm_mul_ps((Length), (T)), (V0));
#line 5762 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorHermite
(
    FXMVECTOR Position0,
    FXMVECTOR Tangent0,
    FXMVECTOR Position1,
    GXMVECTOR Tangent1,
    float    t
) noexcept
{
    
    
    
    


















#line 5798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"













#line 5812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    float t2 = t * t;
    float t3 = t * t2;

    XMVECTOR P0 = _mm_set_ps1(2.0f * t3 - 3.0f * t2 + 1.0f);
    XMVECTOR T0 = _mm_set_ps1(t3 - 2.0f * t2 + t);
    XMVECTOR P1 = _mm_set_ps1(-2.0f * t3 + 3.0f * t2);
    XMVECTOR T1 = _mm_set_ps1(t3 - t2);

    XMVECTOR vResult = _mm_mul_ps(P0, Position0);
    vResult = _mm_add_ps(_mm_mul_ps((Tangent0), (T0)), (vResult));
    vResult = _mm_add_ps(_mm_mul_ps((Position1), (P1)), (vResult));
    vResult = _mm_add_ps(_mm_mul_ps((Tangent1), (T1)), (vResult));
    return vResult;
#line 5826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorHermiteV
(
    FXMVECTOR Position0,
    FXMVECTOR Tangent0,
    FXMVECTOR Position1,
    GXMVECTOR Tangent1,
    HXMVECTOR T
) noexcept
{
    
    
    
    


















#line 5862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

























#line 5888 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    static const XMVECTORF32 CatMulT2 = { { { -3.0f, -2.0f, 3.0f, -1.0f } } };
    static const XMVECTORF32 CatMulT3 = { { { 2.0f, 1.0f, -2.0f, 1.0f } } };

    XMVECTOR T2 = _mm_mul_ps(T, T);
    XMVECTOR T3 = _mm_mul_ps(T, T2);
    
    T2 = _mm_mul_ps(T2, CatMulT2);
    
    T3 = _mm_add_ps(_mm_mul_ps((T3), (CatMulT3)), (T2));
    
    
    T2 = _mm_and_ps(T, g_XMMaskY);
    T3 = _mm_add_ps(T3, T2);
    
    T3 = _mm_add_ps(T3, g_XMIdentityR0);
    
    
    XMVECTOR vResult = _mm_shuffle_ps((T3), (T3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vResult = _mm_mul_ps(vResult, Position0);
    
    T2 = _mm_shuffle_ps((T3), (T3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vResult = _mm_add_ps(_mm_mul_ps((T2), (Tangent0)), (vResult));
    
    T2 = _mm_shuffle_ps((T3), (T3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vResult = _mm_add_ps(_mm_mul_ps((T2), (Position1)), (vResult));
    
    T3 = _mm_shuffle_ps((T3), (T3), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    vResult = _mm_add_ps(_mm_mul_ps((T3), (Tangent1)), (vResult));
    return vResult;
#line 5918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorCatmullRom
(
    FXMVECTOR Position0,
    FXMVECTOR Position1,
    FXMVECTOR Position2,
    GXMVECTOR Position3,
    float    t
) noexcept
{
    
    
    
    


















#line 5954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"














#line 5969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    float t2 = t * t;
    float t3 = t * t2;

    XMVECTOR P0 = _mm_set_ps1((-t3 + 2.0f * t2 - t) * 0.5f);
    XMVECTOR P1 = _mm_set_ps1((3.0f * t3 - 5.0f * t2 + 2.0f) * 0.5f);
    XMVECTOR P2 = _mm_set_ps1((-3.0f * t3 + 4.0f * t2 + t) * 0.5f);
    XMVECTOR P3 = _mm_set_ps1((t3 - t2) * 0.5f);

    P1 = _mm_mul_ps(Position1, P1);
    P0 = _mm_add_ps(_mm_mul_ps((Position0), (P0)), (P1));
    P3 = _mm_mul_ps(Position3, P3);
    P2 = _mm_add_ps(_mm_mul_ps((Position2), (P2)), (P3));
    P0 = _mm_add_ps(P0, P2);
    return P0;
#line 5984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorCatmullRomV
(
    FXMVECTOR Position0,
    FXMVECTOR Position1,
    FXMVECTOR Position2,
    GXMVECTOR Position3,
    HXMVECTOR T
) noexcept
{



























#line 6025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




























#line 6054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    static const XMVECTORF32 Catmul2 = { { { 2.0f, 2.0f, 2.0f, 2.0f } } };
    static const XMVECTORF32 Catmul3 = { { { 3.0f, 3.0f, 3.0f, 3.0f } } };
    static const XMVECTORF32 Catmul4 = { { { 4.0f, 4.0f, 4.0f, 4.0f } } };
    static const XMVECTORF32 Catmul5 = { { { 5.0f, 5.0f, 5.0f, 5.0f } } };
    
    XMVECTOR T2 = _mm_mul_ps(T, T);
    XMVECTOR T3 = _mm_mul_ps(T, T2);
    
    XMVECTOR vResult = _mm_add_ps(T2, T2);
    vResult = _mm_sub_ps(vResult, T);
    vResult = _mm_sub_ps(vResult, T3);
    vResult = _mm_mul_ps(vResult, Position0);
    
    XMVECTOR vTemp = _mm_mul_ps(T3, Catmul3);
    vTemp = _mm_sub_ps((vTemp), _mm_mul_ps((T2), (Catmul5)));
    vTemp = _mm_add_ps(vTemp, Catmul2);
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (Position1)), (vResult));
    
    vTemp = _mm_mul_ps(T2, Catmul4);
    vTemp = _mm_sub_ps((vTemp), _mm_mul_ps((T3), (Catmul3)));
    vTemp = _mm_add_ps(vTemp, T);
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (Position2)), (vResult));
    
    T3 = _mm_sub_ps(T3, T2);
    vResult = _mm_add_ps(_mm_mul_ps((T3), (Position3)), (vResult));
    
    vResult = _mm_mul_ps(vResult, g_XMOneHalf);
    return vResult;
#line 6083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorBaryCentric
(
    FXMVECTOR Position0,
    FXMVECTOR Position1,
    FXMVECTOR Position2,
    float    f,
    float    g
) noexcept
{
    














#line 6112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 6117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR R1 = _mm_sub_ps(Position1, Position0);
    XMVECTOR R2 = _mm_sub_ps(Position2, Position0);
    XMVECTOR SF = _mm_set_ps1(f);
    R1 = _mm_add_ps(_mm_mul_ps((R1), (SF)), (Position0));
    XMVECTOR SG = _mm_set_ps1(g);
    return _mm_add_ps(_mm_mul_ps((R2), (SG)), (R1));
#line 6124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVectorBaryCentricV
(
    FXMVECTOR Position0,
    FXMVECTOR Position1,
    FXMVECTOR Position2,
    GXMVECTOR F,
    HXMVECTOR G
) noexcept
{
    











#line 6150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 6155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR R1 = _mm_sub_ps(Position1, Position0);
    XMVECTOR R2 = _mm_sub_ps(Position2, Position0);
    R1 = _mm_add_ps(_mm_mul_ps((R1), (F)), (Position0));
    return _mm_add_ps(_mm_mul_ps((R2), (G)), (R1));
#line 6160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







 
 
 

 

inline bool __vectorcall XMVector2Equal
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    
    return (((_mm_movemask_ps(vTemp) & 3) == 3) != 0);
#line 6190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline uint32_t __vectorcall XMVector2EqualR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{















#line 6217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"












#line 6230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    
    int iTest = _mm_movemask_ps(vTemp) & 3;
    uint32_t CR = 0;
    if (iTest == 3)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 6244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2EqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return (((_mm_movemask_ps(_mm_castsi128_ps(vTemp)) & 3) == 3) != 0);
#line 6263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector2EqualIntR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{















#line 6289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"












#line 6302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    int iTest = _mm_movemask_ps(_mm_castsi128_ps(vTemp)) & 3;
    uint32_t CR = 0;
    if (iTest == 3)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 6315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2NearEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR Epsilon
) noexcept
{





#line 6332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"








#line 6341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vDelta = _mm_sub_ps(V1, V2);
    
    XMVECTOR vTemp = _mm_setzero_ps();
    vTemp = _mm_sub_ps(vTemp, vDelta);
    vTemp = _mm_max_ps(vTemp, vDelta);
    vTemp = _mm_cmple_ps(vTemp, Epsilon);
    
    return (((_mm_movemask_ps(vTemp) & 3) == 0x3) != 0);
#line 6351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2NotEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    
    return (((_mm_movemask_ps(vTemp) & 3) != 3) != 0);
#line 6371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2NotEqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return (((_mm_movemask_ps(_mm_castsi128_ps(vTemp)) & 3) != 3) != 0);
#line 6390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2Greater
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpgt_ps(V1, V2);
    
    return (((_mm_movemask_ps(vTemp) & 3) == 3) != 0);
#line 6410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector2GreaterR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{















#line 6436 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"












#line 6449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpgt_ps(V1, V2);
    int iTest = _mm_movemask_ps(vTemp) & 3;
    uint32_t CR = 0;
    if (iTest == 3)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 6462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2GreaterOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpge_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 3) == 3) != 0);
#line 6481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector2GreaterOrEqualR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{















#line 6507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"












#line 6520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpge_ps(V1, V2);
    int iTest = _mm_movemask_ps(vTemp) & 3;
    uint32_t CR = 0;
    if (iTest == 3)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 6533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2Less
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmplt_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 3) == 3) != 0);
#line 6552 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2LessOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 6565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmple_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 3) == 3) != 0);
#line 6571 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector2InBounds
(
    FXMVECTOR V,
    FXMVECTOR Bounds
) noexcept
{



#line 6585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"












#line 6598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTemp1 = _mm_cmple_ps(V, Bounds);
    
    XMVECTOR vTemp2 = _mm_mul_ps(Bounds, g_XMNegativeOne);
    
    vTemp2 = _mm_cmple_ps(vTemp2, V);
    
    vTemp1 = _mm_and_ps(vTemp1, vTemp2);
    
    return (((_mm_movemask_ps(vTemp1) & 0x3) == 0x3) != 0);
#line 6609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




#pragma float_control(push)
#pragma float_control(precise, on)
#line 6617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

inline bool __vectorcall XMVector2IsNaN(FXMVECTOR V) noexcept
{



#line 6624 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 6630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTempNan = _mm_cmpneq_ps(V, V);
    
    return ((_mm_movemask_ps(vTempNan) & 3) != 0);
#line 6635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


#pragma float_control(pop)
#line 6640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



inline bool __vectorcall XMVector2IsInfinite(FXMVECTOR V) noexcept
{




#line 6650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 6657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    __m128 vTemp = _mm_and_ps(V, g_XMAbsMask);
    
    vTemp = _mm_cmpeq_ps(vTemp, g_XMInfinity);
    
    return ((_mm_movemask_ps(vTemp) & 3) != 0);
#line 6664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVector2Dot
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{









#line 6688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 6693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 6695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 6700 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V1, V2);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    return vLengthSq;
#line 6709 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2Cross
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    









#line 6730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 6737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((1) << 4) | ((0) << 2) | ((1))) );
    
    vResult = _mm_mul_ps(vResult, V1);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vResult), (vResult), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vResult = _mm_sub_ss(vResult, vTemp);
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    return vResult;
#line 6749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2LengthSq(FXMVECTOR V) noexcept
{
    return XMVector2Dot(V, V);
}



inline XMVECTOR __vectorcall XMVector2ReciprocalLengthEst(FXMVECTOR V) noexcept
{







#line 6770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 6778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 6787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_rsqrt_ss(vLengthSq);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    return vLengthSq;
#line 6797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2ReciprocalLength(FXMVECTOR V) noexcept
{







#line 6811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"













#line 6825 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 6829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 6836 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_sqrt_ss(vLengthSq);
    vLengthSq = _mm_div_ss(g_XMOne, vLengthSq);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    return vLengthSq;
#line 6847 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2LengthEst(FXMVECTOR V) noexcept
{







#line 6861 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











#line 6873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6876 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 6882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_sqrt_ss(vLengthSq);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    return vLengthSq;
#line 6892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2Length(FXMVECTOR V) noexcept
{







#line 6906 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















#line 6924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 6927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 6933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vLengthSq = _mm_sqrt_ps(vLengthSq);
    return vLengthSq;
#line 6943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline XMVECTOR __vectorcall XMVector2NormalizeEst(FXMVECTOR V) noexcept
{







#line 6959 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"









#line 6969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 6973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 6980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_rsqrt_ss(vLengthSq);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vLengthSq = _mm_mul_ps(vLengthSq, V);
    return vLengthSq;
#line 6991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2Normalize(FXMVECTOR V) noexcept
{

















#line 7015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



















#line 7035 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



















#line 7055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






















#line 7078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    XMVECTOR vResult = _mm_sqrt_ps(vLengthSq);
    
    XMVECTOR vZeroMask = _mm_setzero_ps();
    
    vZeroMask = _mm_cmpneq_ps(vZeroMask, vResult);
    
    
    vLengthSq = _mm_cmpneq_ps(vLengthSq, g_XMInfinity);
    
    vResult = _mm_div_ps(V, vResult);
    
    vResult = _mm_and_ps(vResult, vZeroMask);
    
    XMVECTOR vTemp1 = _mm_andnot_ps(vLengthSq, g_XMQNaN);
    XMVECTOR vTemp2 = _mm_and_ps(vResult, vLengthSq);
    vResult = _mm_or_ps(vTemp1, vTemp2);
    return vResult;
#line 7102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2ClampLength
(
    FXMVECTOR V,
    float    LengthMin,
    float    LengthMax
) noexcept
{
    XMVECTOR ClampMax = XMVectorReplicate(LengthMax);
    XMVECTOR ClampMin = XMVectorReplicate(LengthMin);
    return XMVector2ClampLengthV(V, ClampMin, ClampMax);
}



inline XMVECTOR __vectorcall XMVector2ClampLengthV
(
    FXMVECTOR V,
    FXMVECTOR LengthMin,
    FXMVECTOR LengthMax
) noexcept
{
    (void)( (!!((XMVectorGetY(LengthMin) == XMVectorGetX(LengthMin)))) || (_wassert(L"(XMVectorGetY(LengthMin) == XMVectorGetX(LengthMin))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7127)), 0) );
    (void)( (!!((XMVectorGetY(LengthMax) == XMVectorGetX(LengthMax)))) || (_wassert(L"(XMVectorGetY(LengthMax) == XMVectorGetX(LengthMax))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7128)), 0) );
    (void)( (!!(XMVector2GreaterOrEqual(LengthMin, g_XMZero))) || (_wassert(L"XMVector2GreaterOrEqual(LengthMin, g_XMZero)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7129)), 0) );
    (void)( (!!(XMVector2GreaterOrEqual(LengthMax, g_XMZero))) || (_wassert(L"XMVector2GreaterOrEqual(LengthMax, g_XMZero)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7130)), 0) );
    (void)( (!!(XMVector2GreaterOrEqual(LengthMax, LengthMin))) || (_wassert(L"XMVector2GreaterOrEqual(LengthMax, LengthMin)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7131)), 0) );

    XMVECTOR LengthSq = XMVector2LengthSq(V);

    const XMVECTOR Zero = XMVectorZero();

    XMVECTOR RcpLength = XMVectorReciprocalSqrt(LengthSq);

    XMVECTOR InfiniteLength = XMVectorEqualInt(LengthSq, g_XMInfinity.v);
    XMVECTOR ZeroLength = XMVectorEqual(LengthSq, Zero);

    XMVECTOR Length = XMVectorMultiply(LengthSq, RcpLength);

    XMVECTOR Normal = XMVectorMultiply(V, RcpLength);

    XMVECTOR Select = XMVectorEqualInt(InfiniteLength, ZeroLength);
    Length = XMVectorSelect(LengthSq, Length, Select);
    Normal = XMVectorSelect(LengthSq, Normal, Select);

    XMVECTOR ControlMax = XMVectorGreater(Length, LengthMax);
    XMVECTOR ControlMin = XMVectorLess(Length, LengthMin);

    XMVECTOR ClampLength = XMVectorSelect(Length, LengthMax, ControlMax);
    ClampLength = XMVectorSelect(ClampLength, LengthMin, ControlMin);

    XMVECTOR Result = XMVectorMultiply(Normal, ClampLength);

    
    XMVECTOR Control = XMVectorEqualInt(ControlMax, ControlMin);
    Result = XMVectorSelect(Result, V, Control);

    return Result;
}



inline XMVECTOR __vectorcall XMVector2Reflect
(
    FXMVECTOR Incident,
    FXMVECTOR Normal
) noexcept
{
    

    XMVECTOR Result;
    Result = XMVector2Dot(Incident, Normal);
    Result = XMVectorAdd(Result, Result);
    Result = XMVectorNegativeMultiplySubtract(Result, Normal, Incident);
    return Result;
}



inline XMVECTOR __vectorcall XMVector2Refract
(
    FXMVECTOR Incident,
    FXMVECTOR Normal,
    float    RefractionIndex
) noexcept
{
    XMVECTOR Index = XMVectorReplicate(RefractionIndex);
    return XMVector2RefractV(Incident, Normal, Index);
}




inline XMVECTOR __vectorcall XMVector2RefractV
(
    FXMVECTOR Incident,
    FXMVECTOR Normal,
    FXMVECTOR RefractionIndex
) noexcept
{
    
    
































#line 7240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




























#line 7269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    
    
    XMVECTOR IDotN = XMVector2Dot(Incident, Normal);
    
    XMVECTOR vTemp = _mm_sub_ps((g_XMOne), _mm_mul_ps((IDotN), (IDotN)));
    vTemp = _mm_mul_ps(vTemp, RefractionIndex);
    vTemp = _mm_sub_ps((g_XMOne), _mm_mul_ps((vTemp), (RefractionIndex)));
    
    XMVECTOR vMask = _mm_cmpgt_ps(vTemp, g_XMZero);
    
    vTemp = _mm_sqrt_ps(vTemp);
    vTemp = _mm_add_ps(_mm_mul_ps((RefractionIndex), (IDotN)), (vTemp));
    
    XMVECTOR vResult = _mm_mul_ps(RefractionIndex, Incident);
    vResult = _mm_sub_ps((vResult), _mm_mul_ps((vTemp), (Normal)));
    vResult = _mm_and_ps(vResult, vMask);
    return vResult;
#line 7288 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2Orthogonal(FXMVECTOR V) noexcept
{










#line 7305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 7312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    vResult = _mm_mul_ps(vResult, g_XMNegateX);
    return vResult;
#line 7316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2AngleBetweenNormalsEst
(
    FXMVECTOR N1,
    FXMVECTOR N2
) noexcept
{
    XMVECTOR Result = XMVector2Dot(N1, N2);
    Result = XMVectorClamp(Result, g_XMNegativeOne.v, g_XMOne.v);
    Result = XMVectorACosEst(Result);
    return Result;
}



inline XMVECTOR __vectorcall XMVector2AngleBetweenNormals
(
    FXMVECTOR N1,
    FXMVECTOR N2
) noexcept
{
    XMVECTOR Result = XMVector2Dot(N1, N2);
    Result = XMVectorClamp(Result, g_XMNegativeOne, g_XMOne);
    Result = XMVectorACos(Result);
    return Result;
}



inline XMVECTOR __vectorcall XMVector2AngleBetweenVectors
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    XMVECTOR L1 = XMVector2ReciprocalLength(V1);
    XMVECTOR L2 = XMVector2ReciprocalLength(V2);

    XMVECTOR Dot = XMVector2Dot(V1, V2);

    L1 = XMVectorMultiply(L1, L2);

    XMVECTOR CosAngle = XMVectorMultiply(Dot, L1);
    CosAngle = XMVectorClamp(CosAngle, g_XMNegativeOne.v, g_XMOne.v);

    return XMVectorACos(CosAngle);
}



inline XMVECTOR __vectorcall XMVector2LinePointDistance
(
    FXMVECTOR LinePoint1,
    FXMVECTOR LinePoint2,
    FXMVECTOR Point
) noexcept
{
    
    
    
    
    
    

    XMVECTOR PointVector = XMVectorSubtract(Point, LinePoint1);
    XMVECTOR LineVector = XMVectorSubtract(LinePoint2, LinePoint1);

    XMVECTOR LengthSq = XMVector2LengthSq(LineVector);

    XMVECTOR PointProjectionScale = XMVector2Dot(PointVector, LineVector);
    PointProjectionScale = XMVectorDivide(PointProjectionScale, LengthSq);

    XMVECTOR DistanceVector = XMVectorMultiply(LineVector, PointProjectionScale);
    DistanceVector = XMVectorSubtract(PointVector, DistanceVector);

    return XMVector2Length(DistanceVector);
}



inline XMVECTOR __vectorcall XMVector2IntersectLine
(
    FXMVECTOR Line1Point1,
    FXMVECTOR Line1Point2,
    FXMVECTOR Line2Point1,
    GXMVECTOR Line2Point2
) noexcept
{


































#line 7442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR V1 = _mm_sub_ps(Line1Point2, Line1Point1);
    XMVECTOR V2 = _mm_sub_ps(Line2Point2, Line2Point1);
    XMVECTOR V3 = _mm_sub_ps(Line1Point1, Line2Point1);
    
    XMVECTOR C1 = XMVector2Cross(V1, V2);
    XMVECTOR C2 = XMVector2Cross(V2, V3);
    
    XMVECTOR vResultMask = _mm_setzero_ps();
    vResultMask = _mm_sub_ps(vResultMask, C1);
    vResultMask = _mm_max_ps(vResultMask, C1);
    
    vResultMask = _mm_cmpgt_ps(vResultMask, g_XMEpsilon);
    
    XMVECTOR vFailMask = _mm_setzero_ps();
    vFailMask = _mm_sub_ps(vFailMask, C2);
    vFailMask = _mm_max_ps(vFailMask, C2);
    vFailMask = _mm_cmple_ps(vFailMask, g_XMEpsilon);
    XMVECTOR vFail = _mm_and_ps(vFailMask, g_XMInfinity);
    vFailMask = _mm_andnot_ps(vFailMask, g_XMQNaN);
    
    vFail = _mm_or_ps(vFail, vFailMask);
    
    XMVECTOR vResult = _mm_div_ps(C2, C1);
    vResult = _mm_add_ps(_mm_mul_ps((vResult), (V1)), (Line1Point1));
    
    vResult = _mm_and_ps(vResult, vResultMask);
    vResultMask = _mm_andnot_ps(vResultMask, vFail);
    vResult = _mm_or_ps(vResult, vResultMask);
    return vResult;
#line 7472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2Transform
(
    FXMVECTOR V,
    FXMMATRIX M
) noexcept
{










#line 7493 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 7497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vResult), (M.r[1])), (M.r[3]));
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[0])), (vResult));
    return vResult;
#line 7503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMFLOAT4* __vectorcall XMVector2TransformStream
(
    XMFLOAT4* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT2* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7518)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7519)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT2))) || (_wassert(L"InputStride >= sizeof(XMFLOAT2)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7521)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT4))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT4)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7524)), 0) );
    ;




































#line 7563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







































































#line 7635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"














































































































































#line 7778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    const XMVECTOR row0 = M.r[0];
    const XMVECTOR row1 = M.r[1];
    const XMVECTOR row3 = M.r[3];

    size_t i = 0;
    size_t two = VectorCount >> 1;
    if (two > 0)
    {
        if (InputStride == sizeof(XMFLOAT2))
        {
            if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF) && !(OutputStride & 0xF))
            {
                
                for (size_t j = 0; j < two; ++j)
                {
                    XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    pInputVector += sizeof(XMFLOAT2) * 2;

                    XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                    XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);

                    _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                    pOutputVector += OutputStride;

                    Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                    vTemp2 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);

                    _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                    pOutputVector += OutputStride;

                    i += 2;
                }
            }
            else
            {
                
                for (size_t j = 0; j < two; ++j)
                {
                    XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    pInputVector += sizeof(XMFLOAT2) * 2;

                    XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                    XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);

                    _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                    vTemp2 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);

                    _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    i += 2;
                }
            }
        }
    }

    if (!(reinterpret_cast<uintptr_t>(pInputVector) & 0xF) && !(InputStride & 0xF))
    {
        if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF) && !(OutputStride & 0xF))
        {
            
            for (; i < VectorCount; i++)
            {
                XMVECTOR V = _mm_castsi128_ps(_mm_loadl_epi64(reinterpret_cast<const __m128i*>(pInputVector)));
                pInputVector += InputStride;

                XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
                vTemp = _mm_add_ps(vTemp, vTemp2);

                _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                pOutputVector += OutputStride;
            }
        }
        else
        {
            
            for (; i < VectorCount; i++)
            {
                XMVECTOR V = _mm_castsi128_ps(_mm_loadl_epi64(reinterpret_cast<const __m128i*>(pInputVector)));
                pInputVector += InputStride;

                XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
                vTemp = _mm_add_ps(vTemp, vTemp2);

                _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                pOutputVector += OutputStride;
            }
        }
    }
    else
    {
        
        for (; i < VectorCount; i++)
        {
            __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pInputVector)));
            pInputVector += InputStride;

            XMVECTOR Y = _mm_shuffle_ps((xy), (xy), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
            XMVECTOR X = _mm_shuffle_ps((xy), (xy), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

            XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
            XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
            vTemp = _mm_add_ps(vTemp, vTemp2);

            _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
            pOutputVector += OutputStride;
        }
    }

    _mm_sfence();

    return pOutputStream;
#line 7921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2TransformCoord
(
    FXMVECTOR V,
    FXMMATRIX M
) noexcept
{
    XMVECTOR Y = XMVectorSplatY(V);
    XMVECTOR X = XMVectorSplatX(V);

    XMVECTOR Result = XMVectorMultiplyAdd(Y, M.r[1], M.r[3]);
    Result = XMVectorMultiplyAdd(X, M.r[0], Result);

    XMVECTOR W = XMVectorSplatW(Result);
    return XMVectorDivide(Result, W);
}




inline XMFLOAT2* __vectorcall XMVector2TransformCoordStream
(
    XMFLOAT2* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT2* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7954)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7955)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT2))) || (_wassert(L"InputStride >= sizeof(XMFLOAT2)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7957)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT2))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT2)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(7960)), 0) );
    ;








































#line 8003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
































































































#line 8100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"































































































































































#line 8260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    const XMVECTOR row0 = M.r[0];
    const XMVECTOR row1 = M.r[1];
    const XMVECTOR row3 = M.r[3];

    size_t i = 0;
    size_t two = VectorCount >> 1;
    if (two > 0)
    {
        if (InputStride == sizeof(XMFLOAT2))
        {
            if (OutputStride == sizeof(XMFLOAT2))
            {
                if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF))
                {
                    
                    for (size_t j = 0; j < two; ++j)
                    {
                        XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        pInputVector += sizeof(XMFLOAT2) * 2;

                        
                        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                        XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        XMVECTOR V1 = _mm_div_ps(vTemp, W);

                        
                        Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                        vTemp2 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        XMVECTOR V2 = _mm_div_ps(vTemp, W);

                        vTemp = _mm_movelh_ps(V1, V2);

                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                        pOutputVector += sizeof(XMFLOAT2) * 2;

                        i += 2;
                    }
                }
                else
                {
                    
                    for (size_t j = 0; j < two; ++j)
                    {
                        XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        pInputVector += sizeof(XMFLOAT2) * 2;

                        
                        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                        XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        XMVECTOR V1 = _mm_div_ps(vTemp, W);

                        
                        Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                        vTemp2 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        XMVECTOR V2 = _mm_div_ps(vTemp, W);

                        vTemp = _mm_movelh_ps(V1, V2);

                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                        pOutputVector += sizeof(XMFLOAT2) * 2;

                        i += 2;
                    }
                }
            }
            else
            {
                
                for (size_t j = 0; j < two; ++j)
                {
                    XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    pInputVector += sizeof(XMFLOAT2) * 2;

                    
                    XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                    XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);

                    XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                    vTemp = _mm_div_ps(vTemp, W);

                    _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
                    pOutputVector += OutputStride;

                    
                    Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
                    vTemp2 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                    vTemp = _mm_div_ps(vTemp, W);

                    _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
                    pOutputVector += OutputStride;

                    i += 2;
                }
            }
        }
    }

    if (!(reinterpret_cast<uintptr_t>(pInputVector) & 0xF) && !(InputStride & 0xF))
    {
        
        for (; i < VectorCount; i++)
        {
            XMVECTOR V = _mm_castsi128_ps(_mm_loadl_epi64(reinterpret_cast<const __m128i*>(pInputVector)));
            pInputVector += InputStride;

            XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
            XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

            XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
            XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
            vTemp = _mm_add_ps(vTemp, vTemp2);

            XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

            vTemp = _mm_div_ps(vTemp, W);

            _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
            pOutputVector += OutputStride;
        }
    }
    else
    {
        
        for (; i < VectorCount; i++)
        {
            __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pInputVector)));
            pInputVector += InputStride;

            XMVECTOR Y = _mm_shuffle_ps((xy), (xy), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
            XMVECTOR X = _mm_shuffle_ps((xy), (xy), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

            XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Y), (row1)), (row3));
            XMVECTOR vTemp2 = _mm_mul_ps(X, row0);
            vTemp = _mm_add_ps(vTemp, vTemp2);

            XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

            vTemp = _mm_div_ps(vTemp, W);

            _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
            pOutputVector += OutputStride;
        }
    }

    _mm_sfence();

    return pOutputStream;
#line 8451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector2TransformNormal
(
    FXMVECTOR V,
    FXMMATRIX M
) noexcept
{










#line 8472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 8476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) ); 
    vResult = _mm_mul_ps(vResult, M.r[1]);
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[0])), (vResult));
    return vResult;
#line 8482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




inline XMFLOAT2* __vectorcall XMVector2TransformNormalStream
(
    XMFLOAT2* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT2* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(8497)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(8498)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT2))) || (_wassert(L"InputStride >= sizeof(XMFLOAT2)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(8500)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT2))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT2)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(8503)), 0) );
    ;



































#line 8541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
























































#line 8598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

































































































































#line 8728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    const XMVECTOR row0 = M.r[0];
    const XMVECTOR row1 = M.r[1];

    size_t i = 0;
    size_t two = VectorCount >> 1;
    if (two > 0)
    {
        if (InputStride == sizeof(XMFLOAT2))
        {
            if (OutputStride == sizeof(XMFLOAT2))
            {
                if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF))
                {
                    
                    for (size_t j = 0; j < two; ++j)
                    {
                        XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        pInputVector += sizeof(XMFLOAT2) * 2;

                        
                        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_mul_ps(Y, row1);
                        XMVECTOR V1 = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

                        
                        Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                        vTemp = _mm_mul_ps(Y, row1);
                        XMVECTOR V2 = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

                        vTemp = _mm_movelh_ps(V1, V2);

                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                        pOutputVector += sizeof(XMFLOAT2) * 2;

                        i += 2;
                    }
                }
                else
                {
                    
                    for (size_t j = 0; j < two; ++j)
                    {
                        XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        pInputVector += sizeof(XMFLOAT2) * 2;

                        
                        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_mul_ps(Y, row1);
                        XMVECTOR V1 = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

                        
                        Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                        vTemp = _mm_mul_ps(Y, row1);
                        XMVECTOR V2 = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

                        vTemp = _mm_movelh_ps(V1, V2);

                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                        pOutputVector += sizeof(XMFLOAT2) * 2;

                        i += 2;
                    }
                }
            }
            else
            {
                
                for (size_t j = 0; j < two; ++j)
                {
                    XMVECTOR V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    pInputVector += sizeof(XMFLOAT2) * 2;

                    
                    XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_mul_ps(Y, row1);
                    vTemp = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

                    _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
                    pOutputVector += OutputStride;

                    
                    Y = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    X = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

                    vTemp = _mm_mul_ps(Y, row1);
                    vTemp = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

                    _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
                    pOutputVector += OutputStride;

                    i += 2;
                }
            }
        }
    }

    if (!(reinterpret_cast<uintptr_t>(pInputVector) & 0xF) && !(InputStride & 0xF))
    {
        
        for (; i < VectorCount; i++)
        {
            XMVECTOR V = _mm_castsi128_ps(_mm_loadl_epi64(reinterpret_cast<const __m128i*>(pInputVector)));
            pInputVector += InputStride;

            XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
            XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

            XMVECTOR vTemp = _mm_mul_ps(Y, row1);
            vTemp = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

            _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
            pOutputVector += OutputStride;
        }
    }
    else
    {
        
        for (; i < VectorCount; i++)
        {
            __m128 xy = _mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(pInputVector)));
            pInputVector += InputStride;

            XMVECTOR Y = _mm_shuffle_ps((xy), (xy), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
            XMVECTOR X = _mm_shuffle_ps((xy), (xy), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

            XMVECTOR vTemp = _mm_mul_ps(Y, row1);
            vTemp = _mm_add_ps(_mm_mul_ps((X), (row0)), (vTemp));

            _mm_store_sd(reinterpret_cast<double*>(pOutputVector), _mm_castps_pd(vTemp));
            pOutputVector += OutputStride;
        }
    }

    _mm_sfence();

    return pOutputStream;
#line 8878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







 
 
 

 

inline bool __vectorcall XMVector3Equal
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 8901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 8906 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 7) == 7) != 0);
#line 8909 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector3EqualR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{















#line 8935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 8951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    int iTest = _mm_movemask_ps(vTemp) & 7;
    uint32_t CR = 0;
    if (iTest == 7)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 8964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3EqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 8977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 8982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return (((_mm_movemask_ps(_mm_castsi128_ps(vTemp)) & 7) == 7) != 0);
#line 8985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector3EqualIntR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{















#line 9011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 9027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    int iTemp = _mm_movemask_ps(_mm_castsi128_ps(vTemp)) & 7;
    uint32_t CR = 0;
    if (iTemp == 7)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTemp)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 9040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3NearEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR Epsilon
) noexcept
{









#line 9061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"









#line 9071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vDelta = _mm_sub_ps(V1, V2);
    
    XMVECTOR vTemp = _mm_setzero_ps();
    vTemp = _mm_sub_ps(vTemp, vDelta);
    vTemp = _mm_max_ps(vTemp, vDelta);
    vTemp = _mm_cmple_ps(vTemp, Epsilon);
    
    return (((_mm_movemask_ps(vTemp) & 7) == 0x7) != 0);
#line 9081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3NotEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 9094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 9099 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 7) != 7) != 0);
#line 9102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3NotEqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 9115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 9120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return (((_mm_movemask_ps(_mm_castsi128_ps(vTemp)) & 7) != 7) != 0);
#line 9123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3Greater
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 9136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 9141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpgt_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 7) == 7) != 0);
#line 9144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector3GreaterR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
















#line 9171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 9187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpgt_ps(V1, V2);
    uint32_t CR = 0;
    int iTest = _mm_movemask_ps(vTemp) & 7;
    if (iTest == 7)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 9200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3GreaterOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 9213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 9218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpge_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 7) == 7) != 0);
#line 9221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector3GreaterOrEqualR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{

















#line 9249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 9265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpge_ps(V1, V2);
    uint32_t CR = 0;
    int iTest = _mm_movemask_ps(vTemp) & 7;
    if (iTest == 7)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 9278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3Less
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 9291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 9296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmplt_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 7) == 7) != 0);
#line 9299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3LessOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 9312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 9317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmple_ps(V1, V2);
    return (((_mm_movemask_ps(vTemp) & 7) == 7) != 0);
#line 9320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector3InBounds
(
    FXMVECTOR V,
    FXMVECTOR Bounds
) noexcept
{




#line 9335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"












#line 9348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTemp1 = _mm_cmple_ps(V, Bounds);
    
    XMVECTOR vTemp2 = _mm_mul_ps(Bounds, g_XMNegativeOne);
    
    vTemp2 = _mm_cmple_ps(vTemp2, V);
    
    vTemp1 = _mm_and_ps(vTemp1, vTemp2);
    
    return (((_mm_movemask_ps(vTemp1) & 0x7) == 0x7) != 0);


#line 9361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




#pragma float_control(push)
#pragma float_control(precise, on)
#line 9369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

inline bool __vectorcall XMVector3IsNaN(FXMVECTOR V) noexcept
{






#line 9379 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 9386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTempNan = _mm_cmpneq_ps(V, V);
    
    return ((_mm_movemask_ps(vTempNan) & 7) != 0);
#line 9391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


#pragma float_control(pop)
#line 9396 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



inline bool __vectorcall XMVector3IsInfinite(FXMVECTOR V) noexcept
{




#line 9406 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"








#line 9415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    __m128 vTemp = _mm_and_ps(V, g_XMAbsMask);
    
    vTemp = _mm_cmpeq_ps(vTemp, g_XMInfinity);
    
    return ((_mm_movemask_ps(vTemp) & 7) != 0);
#line 9422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVector3Dot
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{








#line 9445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 9453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 9455 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 9460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vDot = _mm_mul_ps(V1, V2);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vDot), (vDot), (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    return _mm_shuffle_ps((vDot), (vDot), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
#line 9473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3Cross
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    









#line 9494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"













#line 9508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTemp1 = _mm_shuffle_ps((V1), (V1), (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    
    XMVECTOR vTemp2 = _mm_shuffle_ps((V2), (V2), (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );
    
    XMVECTOR vResult = _mm_mul_ps(vTemp1, vTemp2);
    
    vTemp1 = _mm_shuffle_ps((vTemp1), (vTemp1), (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    
    vTemp2 = _mm_shuffle_ps((vTemp2), (vTemp2), (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );
    
    vResult = _mm_sub_ps((vResult), _mm_mul_ps((vTemp1), (vTemp2)));
    
    return _mm_and_ps(vResult, g_XMMask3);
#line 9523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3LengthSq(FXMVECTOR V) noexcept
{
    return XMVector3Dot(V, V);
}



inline XMVECTOR __vectorcall XMVector3ReciprocalLengthEst(FXMVECTOR V) noexcept
{









#line 9546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"










#line 9557 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 9560 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 9567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((2) << 4) | ((1) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vLengthSq = _mm_rsqrt_ps(vLengthSq);
    return vLengthSq;
#line 9583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3ReciprocalLength(FXMVECTOR V) noexcept
{









#line 9599 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
















#line 9616 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 9620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 9628 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vDot = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vDot), (vDot), (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    vDot = _mm_shuffle_ps((vDot), (vDot), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vDot = _mm_sqrt_ps(vDot);
    
    vDot = _mm_div_ps(g_XMOne, vDot);
    return vDot;
#line 9646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3LengthEst(FXMVECTOR V) noexcept
{









#line 9662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"














#line 9677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 9680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 9687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((2) << 4) | ((1) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vLengthSq = _mm_sqrt_ps(vLengthSq);
    return vLengthSq;
#line 9703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3Length(FXMVECTOR V) noexcept
{









#line 9719 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




















#line 9740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 9743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 9750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((2) << 4) | ((1) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vLengthSq = _mm_sqrt_ps(vLengthSq);
    return vLengthSq;
#line 9766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline XMVECTOR __vectorcall XMVector3NormalizeEst(FXMVECTOR V) noexcept
{







#line 9782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"











#line 9794 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 9798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"







#line 9806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vDot = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vDot), (vDot), (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    vDot = _mm_shuffle_ps((vDot), (vDot), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vDot = _mm_rsqrt_ps(vDot);
    
    vDot = _mm_mul_ps(vDot, V);
    return vDot;
#line 9824 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3Normalize(FXMVECTOR V) noexcept
{



















#line 9850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





















#line 9872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



















#line 9892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"























#line 9916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))) );
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    XMVECTOR vResult = _mm_sqrt_ps(vLengthSq);
    
    XMVECTOR vZeroMask = _mm_setzero_ps();
    
    vZeroMask = _mm_cmpneq_ps(vZeroMask, vResult);
    
    
    vLengthSq = _mm_cmpneq_ps(vLengthSq, g_XMInfinity);
    
    vResult = _mm_div_ps(V, vResult);
    
    vResult = _mm_and_ps(vResult, vZeroMask);
    
    XMVECTOR vTemp1 = _mm_andnot_ps(vLengthSq, g_XMQNaN);
    XMVECTOR vTemp2 = _mm_and_ps(vResult, vLengthSq);
    vResult = _mm_or_ps(vTemp1, vTemp2);
    return vResult;
#line 9942 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3ClampLength
(
    FXMVECTOR V,
    float    LengthMin,
    float    LengthMax
) noexcept
{
    XMVECTOR ClampMax = XMVectorReplicate(LengthMax);
    XMVECTOR ClampMin = XMVectorReplicate(LengthMin);

    return XMVector3ClampLengthV(V, ClampMin, ClampMax);
}



inline XMVECTOR __vectorcall XMVector3ClampLengthV
(
    FXMVECTOR V,
    FXMVECTOR LengthMin,
    FXMVECTOR LengthMax
) noexcept
{
    (void)( (!!((XMVectorGetY(LengthMin) == XMVectorGetX(LengthMin)) && (XMVectorGetZ(LengthMin) == XMVectorGetX(LengthMin)))) || (_wassert(L"(XMVectorGetY(LengthMin) == XMVectorGetX(LengthMin)) && (XMVectorGetZ(LengthMin) == XMVectorGetX(LengthMin))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(9968)), 0) );
    (void)( (!!((XMVectorGetY(LengthMax) == XMVectorGetX(LengthMax)) && (XMVectorGetZ(LengthMax) == XMVectorGetX(LengthMax)))) || (_wassert(L"(XMVectorGetY(LengthMax) == XMVectorGetX(LengthMax)) && (XMVectorGetZ(LengthMax) == XMVectorGetX(LengthMax))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(9969)), 0) );
    (void)( (!!(XMVector3GreaterOrEqual(LengthMin, XMVectorZero()))) || (_wassert(L"XMVector3GreaterOrEqual(LengthMin, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(9970)), 0) );
    (void)( (!!(XMVector3GreaterOrEqual(LengthMax, XMVectorZero()))) || (_wassert(L"XMVector3GreaterOrEqual(LengthMax, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(9971)), 0) );
    (void)( (!!(XMVector3GreaterOrEqual(LengthMax, LengthMin))) || (_wassert(L"XMVector3GreaterOrEqual(LengthMax, LengthMin)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(9972)), 0) );

    XMVECTOR LengthSq = XMVector3LengthSq(V);

    const XMVECTOR Zero = XMVectorZero();

    XMVECTOR RcpLength = XMVectorReciprocalSqrt(LengthSq);

    XMVECTOR InfiniteLength = XMVectorEqualInt(LengthSq, g_XMInfinity.v);
    XMVECTOR ZeroLength = XMVectorEqual(LengthSq, Zero);

    XMVECTOR Normal = XMVectorMultiply(V, RcpLength);

    XMVECTOR Length = XMVectorMultiply(LengthSq, RcpLength);

    XMVECTOR Select = XMVectorEqualInt(InfiniteLength, ZeroLength);
    Length = XMVectorSelect(LengthSq, Length, Select);
    Normal = XMVectorSelect(LengthSq, Normal, Select);

    XMVECTOR ControlMax = XMVectorGreater(Length, LengthMax);
    XMVECTOR ControlMin = XMVectorLess(Length, LengthMin);

    XMVECTOR ClampLength = XMVectorSelect(Length, LengthMax, ControlMax);
    ClampLength = XMVectorSelect(ClampLength, LengthMin, ControlMin);

    XMVECTOR Result = XMVectorMultiply(Normal, ClampLength);

    
    XMVECTOR Control = XMVectorEqualInt(ControlMax, ControlMin);
    Result = XMVectorSelect(Result, V, Control);

    return Result;
}



inline XMVECTOR __vectorcall XMVector3Reflect
(
    FXMVECTOR Incident,
    FXMVECTOR Normal
) noexcept
{
    

    XMVECTOR Result = XMVector3Dot(Incident, Normal);
    Result = XMVectorAdd(Result, Result);
    Result = XMVectorNegativeMultiplySubtract(Result, Normal, Incident);

    return Result;
}



inline XMVECTOR __vectorcall XMVector3Refract
(
    FXMVECTOR Incident,
    FXMVECTOR Normal,
    float    RefractionIndex
) noexcept
{
    XMVECTOR Index = XMVectorReplicate(RefractionIndex);
    return XMVector3RefractV(Incident, Normal, Index);
}



inline XMVECTOR __vectorcall XMVector3RefractV
(
    FXMVECTOR Incident,
    FXMVECTOR Normal,
    FXMVECTOR RefractionIndex
) noexcept
{
    
    






























#line 10078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



































#line 10114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    
    XMVECTOR IDotN = XMVector3Dot(Incident, Normal);
    
    XMVECTOR R = _mm_sub_ps((g_XMOne), _mm_mul_ps((IDotN), (IDotN)));
    XMVECTOR R2 = _mm_mul_ps(RefractionIndex, RefractionIndex);
    R = _mm_sub_ps((g_XMOne), _mm_mul_ps((R), (R2)));

    XMVECTOR vResult = _mm_cmple_ps(R, g_XMZero);
    if (_mm_movemask_ps(vResult) == 0x0f)
    {
        
        vResult = g_XMZero;
    }
    else
    {
        
        R = _mm_sqrt_ps(R);
        R = _mm_add_ps(_mm_mul_ps((RefractionIndex), (IDotN)), (R));
        
        vResult = _mm_mul_ps(RefractionIndex, Incident);
        vResult = _mm_sub_ps((vResult), _mm_mul_ps((R), (Normal)));
    }
    return vResult;
#line 10139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector3Orthogonal(FXMVECTOR V) noexcept
{
    XMVECTOR Zero = XMVectorZero();
    XMVECTOR Z = XMVectorSplatZ(V);
    XMVECTOR YZYY = XMVectorSwizzle<XM_SWIZZLE_Y, XM_SWIZZLE_Z, XM_SWIZZLE_Y, XM_SWIZZLE_Y>(V);

    XMVECTOR NegativeV = XMVectorSubtract(Zero, V);

    XMVECTOR ZIsNegative = XMVectorLess(Z, Zero);
    XMVECTOR YZYYIsNegative = XMVectorLess(YZYY, Zero);

    XMVECTOR S = XMVectorAdd(YZYY, Z);
    XMVECTOR D = XMVectorSubtract(YZYY, Z);

    XMVECTOR Select = XMVectorEqualInt(ZIsNegative, YZYYIsNegative);

    XMVECTOR R0 = XMVectorPermute<XM_PERMUTE_1X, XM_PERMUTE_0X, XM_PERMUTE_0X, XM_PERMUTE_0X>(NegativeV, S);
    XMVECTOR R1 = XMVectorPermute<XM_PERMUTE_1X, XM_PERMUTE_0X, XM_PERMUTE_0X, XM_PERMUTE_0X>(V, D);

    return XMVectorSelect(R1, R0, Select);
}



inline XMVECTOR __vectorcall XMVector3AngleBetweenNormalsEst
(
    FXMVECTOR N1,
    FXMVECTOR N2
) noexcept
{
    XMVECTOR Result = XMVector3Dot(N1, N2);
    Result = XMVectorClamp(Result, g_XMNegativeOne.v, g_XMOne.v);
    Result = XMVectorACosEst(Result);
    return Result;
}



inline XMVECTOR __vectorcall XMVector3AngleBetweenNormals
(
    FXMVECTOR N1,
    FXMVECTOR N2
) noexcept
{
    XMVECTOR Result = XMVector3Dot(N1, N2);
    Result = XMVectorClamp(Result, g_XMNegativeOne.v, g_XMOne.v);
    Result = XMVectorACos(Result);
    return Result;
}



inline XMVECTOR __vectorcall XMVector3AngleBetweenVectors
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    XMVECTOR L1 = XMVector3ReciprocalLength(V1);
    XMVECTOR L2 = XMVector3ReciprocalLength(V2);

    XMVECTOR Dot = XMVector3Dot(V1, V2);

    L1 = XMVectorMultiply(L1, L2);

    XMVECTOR CosAngle = XMVectorMultiply(Dot, L1);
    CosAngle = XMVectorClamp(CosAngle, g_XMNegativeOne.v, g_XMOne.v);

    return XMVectorACos(CosAngle);
}



inline XMVECTOR __vectorcall XMVector3LinePointDistance
(
    FXMVECTOR LinePoint1,
    FXMVECTOR LinePoint2,
    FXMVECTOR Point
) noexcept
{
    
    
    
    
    
    

    XMVECTOR PointVector = XMVectorSubtract(Point, LinePoint1);
    XMVECTOR LineVector = XMVectorSubtract(LinePoint2, LinePoint1);

    XMVECTOR LengthSq = XMVector3LengthSq(LineVector);

    XMVECTOR PointProjectionScale = XMVector3Dot(PointVector, LineVector);
    PointProjectionScale = XMVectorDivide(PointProjectionScale, LengthSq);

    XMVECTOR DistanceVector = XMVectorMultiply(LineVector, PointProjectionScale);
    DistanceVector = XMVectorSubtract(PointVector, DistanceVector);

    return XMVector3Length(DistanceVector);
}




inline void __vectorcall XMVector3ComponentsFromNormal
(
    XMVECTOR* pParallel,
    XMVECTOR* pPerpendicular,
    FXMVECTOR  V,
    FXMVECTOR  Normal
) noexcept
{
    (void)( (!!(pParallel != nullptr)) || (_wassert(L"pParallel != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10255)), 0) );
    (void)( (!!(pPerpendicular != nullptr)) || (_wassert(L"pPerpendicular != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10256)), 0) );

    XMVECTOR Scale = XMVector3Dot(V, Normal);

    XMVECTOR Parallel = XMVectorMultiply(Normal, Scale);

    *pParallel = Parallel;
    *pPerpendicular = XMVectorSubtract(V, Parallel);
}




inline XMVECTOR __vectorcall XMVector3Rotate
(
    FXMVECTOR V,
    FXMVECTOR RotationQuaternion
) noexcept
{
    XMVECTOR A = XMVectorSelect(g_XMSelect1110.v, V, g_XMSelect1110.v);
    XMVECTOR Q = XMQuaternionConjugate(RotationQuaternion);
    XMVECTOR Result = XMQuaternionMultiply(Q, A);
    return XMQuaternionMultiply(Result, RotationQuaternion);
}




inline XMVECTOR __vectorcall XMVector3InverseRotate
(
    FXMVECTOR V,
    FXMVECTOR RotationQuaternion
) noexcept
{
    XMVECTOR A = XMVectorSelect(g_XMSelect1110.v, V, g_XMSelect1110.v);
    XMVECTOR Result = XMQuaternionMultiply(RotationQuaternion, A);
    XMVECTOR Q = XMQuaternionConjugate(RotationQuaternion);
    return XMQuaternionMultiply(Result, Q);
}



inline XMVECTOR __vectorcall XMVector3Transform
(
    FXMVECTOR V,
    FXMMATRIX M
) noexcept
{












#line 10317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 10322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vResult), (M.r[2])), (M.r[3]));
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[1])), (vResult));
    vTemp = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[0])), (vResult));
    return vResult;
#line 10330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}









inline XMFLOAT4* __vectorcall XMVector3TransformStream
(
    XMFLOAT4* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT3* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10350)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10351)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT3))) || (_wassert(L"InputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10353)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT4))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT4)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10356)), 0) );
    ;






























#line 10389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"























































































#line 10477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    const XMVECTOR row0 = M.r[0];
    const XMVECTOR row1 = M.r[1];
    const XMVECTOR row2 = M.r[2];
    const XMVECTOR row3 = M.r[3];

    size_t i = 0;
    size_t four = VectorCount >> 2;
    if (four > 0)
    {
        if (InputStride == sizeof(XMFLOAT3))
        {
            if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF) && !(OutputStride & 0xF))
            {
                
                for (size_t j = 0; j < four; ++j)
                {
                    __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                    __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                    pInputVector += sizeof(XMFLOAT3) * 4;

                    
                    XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                    
                    XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                    XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
                    pOutputVector += OutputStride;

                    i += 4;
                }
            }
            else
            {
                
                for (size_t j = 0; j < four; ++j)
                {
                    __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                    __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                    pInputVector += sizeof(XMFLOAT3) * 4;

                    
                    XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                    
                    XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                    XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);
                    _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    i += 4;
                }
            }
        }
    }

    if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF) && !(OutputStride & 0xF))
    {
        
        for (; i < VectorCount; ++i)
        {
            XMVECTOR V = XMLoadFloat3(reinterpret_cast<const XMFLOAT3*>(pInputVector));
            pInputVector += InputStride;

            XMVECTOR Z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
            XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
            XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

            XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
            XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
            XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
            vTemp = _mm_add_ps(vTemp, vTemp2);
            vTemp = _mm_add_ps(vTemp, vTemp3);

            _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTemp));
            pOutputVector += OutputStride;
        }
    }
    else
    {
        
        for (; i < VectorCount; ++i)
        {
            XMVECTOR V = XMLoadFloat3(reinterpret_cast<const XMFLOAT3*>(pInputVector));
            pInputVector += InputStride;

            XMVECTOR Z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
            XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
            XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

            XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
            XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
            XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
            vTemp = _mm_add_ps(vTemp, vTemp2);
            vTemp = _mm_add_ps(vTemp, vTemp3);

            _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTemp);
            pOutputVector += OutputStride;
        }
    }

    _mm_sfence();

    return pOutputStream;
#line 10679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVector3TransformCoord
(
    FXMVECTOR V,
    FXMMATRIX M
) noexcept
{
    XMVECTOR Z = XMVectorSplatZ(V);
    XMVECTOR Y = XMVectorSplatY(V);
    XMVECTOR X = XMVectorSplatX(V);

    XMVECTOR Result = XMVectorMultiplyAdd(Z, M.r[2], M.r[3]);
    Result = XMVectorMultiplyAdd(Y, M.r[1], Result);
    Result = XMVectorMultiplyAdd(X, M.r[0], Result);

    XMVECTOR W = XMVectorSplatW(Result);
    return XMVectorDivide(Result, W);
}









inline XMFLOAT3* __vectorcall XMVector3TransformCoordStream
(
    XMFLOAT3* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT3* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10723)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10724)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT3))) || (_wassert(L"InputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10726)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT3))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(10729)), 0) );
    ;


































#line 10766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




















































































































#line 10883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    const XMVECTOR row0 = M.r[0];
    const XMVECTOR row1 = M.r[1];
    const XMVECTOR row2 = M.r[2];
    const XMVECTOR row3 = M.r[3];

    size_t i = 0;
    size_t four = VectorCount >> 2;
    if (four > 0)
    {
        if (InputStride == sizeof(XMFLOAT3))
        {
            if (OutputStride == sizeof(XMFLOAT3))
            {
                if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF))
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V1 = _mm_div_ps(vTemp, W);

                        
                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V2 = _mm_div_ps(vTemp, W);

                        
                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V3 = _mm_div_ps(vTemp, W);

                        
                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V4 = _mm_div_ps(vTemp, W);

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (V1));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 16)), (vTemp));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 32)), (V3));
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
                else
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V1 = _mm_div_ps(vTemp, W);

                        
                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V2 = _mm_div_ps(vTemp, W);

                        
                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V3 = _mm_div_ps(vTemp, W);

                        
                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                        V4 = _mm_div_ps(vTemp, W);

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), V1);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 16), vTemp);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 32), V3);
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
            }
            else
            {
                
                for (size_t j = 0; j < four; ++j)
                {
                    __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                    __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                    pInputVector += sizeof(XMFLOAT3) * 4;

                    
                    XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                    
                    XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                    XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                    vTemp = _mm_div_ps(vTemp, W);
                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                    vTemp = _mm_div_ps(vTemp, W);
                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                    vTemp = _mm_div_ps(vTemp, W);
                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                    vTemp = _mm_div_ps(vTemp, W);
                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    i += 4;
                }
            }
        }
    }

    for (; i < VectorCount; i++)
    {
        XMVECTOR V = XMLoadFloat3(reinterpret_cast<const XMFLOAT3*>(pInputVector));
        pInputVector += InputStride;

        XMVECTOR Z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (row2)), (row3));
        XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
        XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
        vTemp = _mm_add_ps(vTemp, vTemp2);
        vTemp = _mm_add_ps(vTemp, vTemp3);

        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

        vTemp = _mm_div_ps(vTemp, W);

        XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
        pOutputVector += OutputStride;
    }

    _mm_sfence();

    return pOutputStream;
#line 11178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVector3TransformNormal
(
    FXMVECTOR V,
    FXMMATRIX M
) noexcept
{












#line 11205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 11210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) ); 
    vResult = _mm_mul_ps(vResult, M.r[2]);
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[1])), (vResult));
    vTemp = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[0])), (vResult));
    return vResult;
#line 11218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}









inline XMFLOAT3* __vectorcall XMVector3TransformNormalStream
(
    XMFLOAT3* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT3* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11238)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11239)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT3))) || (_wassert(L"InputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11241)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT3))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11244)), 0) );
    ;





























#line 11276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

















































































#line 11358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    const XMVECTOR row0 = M.r[0];
    const XMVECTOR row1 = M.r[1];
    const XMVECTOR row2 = M.r[2];

    size_t i = 0;
    size_t four = VectorCount >> 2;
    if (four > 0)
    {
        if (InputStride == sizeof(XMFLOAT3))
        {
            if (OutputStride == sizeof(XMFLOAT3))
            {
                if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF))
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_mul_ps(Z, row2);
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V1 = _mm_add_ps(vTemp, vTemp3);

                        
                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_mul_ps(Z, row2);
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V2 = _mm_add_ps(vTemp, vTemp3);

                        
                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_mul_ps(Z, row2);
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V3 = _mm_add_ps(vTemp, vTemp3);

                        
                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_mul_ps(Z, row2);
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V4 = _mm_add_ps(vTemp, vTemp3);

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (V1));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 16)), (vTemp));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 32)), (V3));
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
                else
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_mul_ps(Z, row2);
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V1 = _mm_add_ps(vTemp, vTemp3);

                        
                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_mul_ps(Z, row2);
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V2 = _mm_add_ps(vTemp, vTemp3);

                        
                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_mul_ps(Z, row2);
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V3 = _mm_add_ps(vTemp, vTemp3);

                        
                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_mul_ps(Z, row2);
                        vTemp2 = _mm_mul_ps(Y, row1);
                        vTemp3 = _mm_mul_ps(X, row0);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        V4 = _mm_add_ps(vTemp, vTemp3);

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), V1);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 16), vTemp);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 32), V3);
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
            }
            else
            {
                
                for (size_t j = 0; j < four; ++j)
                {
                    __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                    __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                    pInputVector += sizeof(XMFLOAT3) * 4;

                    
                    XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                    
                    XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_mul_ps(Z, row2);
                    XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
                    XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_mul_ps(Z, row2);
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_mul_ps(Z, row2);
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_mul_ps(Z, row2);
                    vTemp2 = _mm_mul_ps(Y, row1);
                    vTemp3 = _mm_mul_ps(X, row0);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    i += 4;
                }
            }
        }
    }

    for (; i < VectorCount; i++)
    {
        XMVECTOR V = XMLoadFloat3(reinterpret_cast<const XMFLOAT3*>(pInputVector));
        pInputVector += InputStride;

        XMVECTOR Z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

        XMVECTOR vTemp = _mm_mul_ps(Z, row2);
        XMVECTOR vTemp2 = _mm_mul_ps(Y, row1);
        XMVECTOR vTemp3 = _mm_mul_ps(X, row0);
        vTemp = _mm_add_ps(vTemp, vTemp2);
        vTemp = _mm_add_ps(vTemp, vTemp3);

        XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
        pOutputVector += OutputStride;
    }

    _mm_sfence();

    return pOutputStream;
#line 11604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVector3Project
(
    FXMVECTOR V,
    float    ViewportX,
    float    ViewportY,
    float    ViewportWidth,
    float    ViewportHeight,
    float    ViewportMinZ,
    float    ViewportMaxZ,
    FXMMATRIX Projection,
    CXMMATRIX View,
    CXMMATRIX World
) noexcept
{
    const float HalfViewportWidth = ViewportWidth * 0.5f;
    const float HalfViewportHeight = ViewportHeight * 0.5f;

    XMVECTOR Scale = XMVectorSet(HalfViewportWidth, -HalfViewportHeight, ViewportMaxZ - ViewportMinZ, 0.0f);
    XMVECTOR Offset = XMVectorSet(ViewportX + HalfViewportWidth, ViewportY + HalfViewportHeight, ViewportMinZ, 0.0f);

    XMMATRIX Transform = XMMatrixMultiply(World, View);
    Transform = XMMatrixMultiply(Transform, Projection);

    XMVECTOR Result = XMVector3TransformCoord(V, Transform);

    Result = XMVectorMultiplyAdd(Result, Scale, Offset);

    return Result;
}









inline XMFLOAT3* __vectorcall XMVector3ProjectStream
(
    XMFLOAT3* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT3* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    float           ViewportX,
    float           ViewportY,
    float           ViewportWidth,
    float           ViewportHeight,
    float           ViewportMinZ,
    float           ViewportMaxZ,
    FXMMATRIX     Projection,
    CXMMATRIX     View,
    CXMMATRIX     World
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11668)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11669)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT3))) || (_wassert(L"InputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11671)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT3))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(11674)), 0) );
    ;






























#line 11707 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"









































































































































#line 11845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    const float HalfViewportWidth = ViewportWidth * 0.5f;
    const float HalfViewportHeight = ViewportHeight * 0.5f;

    XMVECTOR Scale = XMVectorSet(HalfViewportWidth, -HalfViewportHeight, ViewportMaxZ - ViewportMinZ, 1.0f);
    XMVECTOR Offset = XMVectorSet(ViewportX + HalfViewportWidth, ViewportY + HalfViewportHeight, ViewportMinZ, 0.0f);

    XMMATRIX Transform = XMMatrixMultiply(World, View);
    Transform = XMMatrixMultiply(Transform, Projection);

    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    size_t i = 0;
    size_t four = VectorCount >> 2;
    if (four > 0)
    {
        if (InputStride == sizeof(XMFLOAT3))
        {
            if (OutputStride == sizeof(XMFLOAT3))
            {
                if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF))
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V1 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V2 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V3 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V4 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (V1));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 16)), (vTemp));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 32)), (V3));
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
                else
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V1 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V2 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V3 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        vTemp = _mm_div_ps(vTemp, W);
                        V4 = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), V1);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 16), vTemp);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 32), V3);
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
            }
            else
            {
                
                for (size_t j = 0; j < four; ++j)
                {
                    __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                    __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                    pInputVector += sizeof(XMFLOAT3) * 4;

                    
                    XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                    
                    XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);
                    vTemp = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);
                    vTemp = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);
                    vTemp = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);
                    vTemp = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    i += 4;
                }
            }
        }
    }

    for (; i < VectorCount; i++)
    {
        XMVECTOR V = XMLoadFloat3(reinterpret_cast<const XMFLOAT3*>(pInputVector));
        pInputVector += InputStride;

        XMVECTOR Z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
        XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
        XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
        vTemp = _mm_add_ps(vTemp, vTemp2);
        vTemp = _mm_add_ps(vTemp, vTemp3);

        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
        vTemp = _mm_div_ps(vTemp, W);
        vTemp = _mm_add_ps(_mm_mul_ps((vTemp), (Scale)), (Offset));

        XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
        pOutputVector += OutputStride;
    }

    _mm_sfence();

    return pOutputStream;
#line 12148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVector3Unproject
(
    FXMVECTOR V,
    float     ViewportX,
    float     ViewportY,
    float     ViewportWidth,
    float     ViewportHeight,
    float     ViewportMinZ,
    float     ViewportMaxZ,
    FXMMATRIX Projection,
    CXMMATRIX View,
    CXMMATRIX World
) noexcept
{
    static const XMVECTORF32 D = { { { -1.0f, 1.0f, 0.0f, 0.0f } } };

    XMVECTOR Scale = XMVectorSet(ViewportWidth * 0.5f, -ViewportHeight * 0.5f, ViewportMaxZ - ViewportMinZ, 1.0f);
    Scale = XMVectorReciprocal(Scale);

    XMVECTOR Offset = XMVectorSet(-ViewportX, -ViewportY, -ViewportMinZ, 0.0f);
    Offset = XMVectorMultiplyAdd(Scale, Offset, D.v);

    XMMATRIX Transform = XMMatrixMultiply(World, View);
    Transform = XMMatrixMultiply(Transform, Projection);
    Transform = XMMatrixInverse(nullptr, Transform);

    XMVECTOR Result = XMVectorMultiplyAdd(V, Scale, Offset);

    return XMVector3TransformCoord(Result, Transform);
}









inline XMFLOAT3* __vectorcall XMVector3UnprojectStream
(
    XMFLOAT3* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT3* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    float           ViewportX,
    float           ViewportY,
    float           ViewportWidth,
    float           ViewportHeight,
    float           ViewportMinZ,
    float           ViewportMaxZ,
    FXMMATRIX       Projection,
    CXMMATRIX       View,
    CXMMATRIX       World
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(12213)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(12214)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT3))) || (_wassert(L"InputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(12216)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT3))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT3)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(12219)), 0) );
    ;


































#line 12256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"























































































































































#line 12408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    static const XMVECTORF32 D = { { { -1.0f, 1.0f, 0.0f, 0.0f } } };

    XMVECTOR Scale = XMVectorSet(ViewportWidth * 0.5f, -ViewportHeight * 0.5f, ViewportMaxZ - ViewportMinZ, 1.0f);
    Scale = XMVectorReciprocal(Scale);

    XMVECTOR Offset = XMVectorSet(-ViewportX, -ViewportY, -ViewportMinZ, 0.0f);
    Offset = _mm_mul_ps(Scale, Offset);
    Offset = _mm_add_ps(Offset, D);

    XMMATRIX Transform = XMMatrixMultiply(World, View);
    Transform = XMMatrixMultiply(Transform, Projection);
    Transform = XMMatrixInverse(nullptr, Transform);

    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    size_t i = 0;
    size_t four = VectorCount >> 2;
    if (four > 0)
    {
        if (InputStride == sizeof(XMFLOAT3))
        {
            if (OutputStride == sizeof(XMFLOAT3))
            {
                if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF))
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        V1 = _mm_add_ps(_mm_mul_ps((V1), (Scale)), (Offset));

                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V1 = _mm_div_ps(vTemp, W);

                        
                        V2 = _mm_add_ps(_mm_mul_ps((V2), (Scale)), (Offset));

                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V2 = _mm_div_ps(vTemp, W);

                        
                        V3 = _mm_add_ps(_mm_mul_ps((V3), (Scale)), (Offset));

                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V3 = _mm_div_ps(vTemp, W);

                        
                        V4 = _mm_add_ps(_mm_mul_ps((V4), (Scale)), (Offset));

                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V4 = _mm_div_ps(vTemp, W);

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (V1));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 16)), (vTemp));
                        _mm_stream_ps((reinterpret_cast<float*>(pOutputVector + 32)), (V3));
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
                else
                {
                    
                    for (size_t j = 0; j < four; ++j)
                    {
                        __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                        __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                        __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                        pInputVector += sizeof(XMFLOAT3) * 4;

                        
                        XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                        
                        V1 = _mm_add_ps(_mm_mul_ps((V1), (Scale)), (Offset));

                        XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V1 = _mm_div_ps(vTemp, W);

                        
                        V2 = _mm_add_ps(_mm_mul_ps((V2), (Scale)), (Offset));

                        Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V2 = _mm_div_ps(vTemp, W);

                        
                        V3 = _mm_add_ps(_mm_mul_ps((V3), (Scale)), (Offset));

                        Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V3 = _mm_div_ps(vTemp, W);

                        
                        V4 = _mm_add_ps(_mm_mul_ps((V4), (Scale)), (Offset));

                        Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                        Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                        X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                        vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                        vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                        vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                        vTemp = _mm_add_ps(vTemp, vTemp2);
                        vTemp = _mm_add_ps(vTemp, vTemp3);

                        W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                        V4 = _mm_div_ps(vTemp, W);

                        
                        vTemp = _mm_shuffle_ps(V2, V3, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1)))); V2 = _mm_shuffle_ps(V2, V1, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0)))); V1 = _mm_shuffle_ps(V1, V2, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((0)))); V3 = _mm_shuffle_ps(V3, V4, (((0) << 6) | ((0) << 4) | ((2) << 2) | ((2)))); V3 = _mm_shuffle_ps(V3, V4, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), V1);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 16), vTemp);
                        _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector + 32), V3);
                        pOutputVector += sizeof(XMFLOAT3) * 4;
                        i += 4;
                    }
                }
            }
            else
            {
                
                for (size_t j = 0; j < four; ++j)
                {
                    __m128 V1 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                    __m128 L2 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 16));
                    __m128 L3 = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector + 32));
                    pInputVector += sizeof(XMFLOAT3) * 4;

                    
                    XMVECTOR V3 = _mm_shuffle_ps(L2, L3, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((2)))); XMVECTOR V2 = _mm_shuffle_ps(L2, V1, (((3) << 6) | ((3) << 4) | ((1) << 2) | ((0)))); V2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((2))) ); XMVECTOR V4 = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(L3), 32 / 8));

                    
                    V1 = _mm_add_ps(_mm_mul_ps((V1), (Scale)), (Offset));

                    XMVECTOR Z = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    XMVECTOR Y = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    XMVECTOR X = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    V2 = _mm_add_ps(_mm_mul_ps((V2), (Scale)), (Offset));

                    Z = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V2), (V2), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    V3 = _mm_add_ps(_mm_mul_ps((V3), (Scale)), (Offset));

                    Z = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    
                    V4 = _mm_add_ps(_mm_mul_ps((V4), (Scale)), (Offset));

                    Z = _mm_shuffle_ps((V4), (V4), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                    Y = _mm_shuffle_ps((V4), (V4), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                    X = _mm_shuffle_ps((V4), (V4), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

                    vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
                    vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
                    vTemp3 = _mm_mul_ps(X, Transform.r[0]);
                    vTemp = _mm_add_ps(vTemp, vTemp2);
                    vTemp = _mm_add_ps(vTemp, vTemp3);

                    W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
                    vTemp = _mm_div_ps(vTemp, W);

                    XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
                    pOutputVector += OutputStride;

                    i += 4;
                }
            }
        }
    }

    for (; i < VectorCount; i++)
    {
        XMVECTOR V = XMLoadFloat3(reinterpret_cast<const XMFLOAT3*>(pInputVector));
        pInputVector += InputStride;

        V = _mm_mul_ps(V, Scale);
        V = _mm_add_ps(V, Offset);

        XMVECTOR Z = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
        XMVECTOR Y = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
        XMVECTOR X = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );

        XMVECTOR vTemp = _mm_add_ps(_mm_mul_ps((Z), (Transform.r[2])), (Transform.r[3]));
        XMVECTOR vTemp2 = _mm_mul_ps(Y, Transform.r[1]);
        XMVECTOR vTemp3 = _mm_mul_ps(X, Transform.r[0]);
        vTemp = _mm_add_ps(vTemp, vTemp2);
        vTemp = _mm_add_ps(vTemp, vTemp3);

        XMVECTOR W = _mm_shuffle_ps((vTemp), (vTemp), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
        vTemp = _mm_div_ps(vTemp, W);

        XMStoreFloat3(reinterpret_cast<XMFLOAT3*>(pOutputVector), vTemp);
        pOutputVector += OutputStride;
    }

    _mm_sfence();

    return pOutputStream;
#line 12729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}











 
 
 

 

inline bool __vectorcall XMVector4Equal
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 12756 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 12761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    return ((_mm_movemask_ps(vTemp) == 0x0f) != 0);


#line 12766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector4EqualR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{




















#line 12797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 12813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpeq_ps(V1, V2);
    int iTest = _mm_movemask_ps(vTemp);
    uint32_t CR = 0;
    if (iTest == 0xf)     
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (iTest == 0)  
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 12826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4EqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 12839 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 12844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return ((_mm_movemask_ps(_mm_castsi128_ps(vTemp)) == 0xf) != 0);


#line 12849 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector4EqualIntR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


















#line 12878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 12894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    int iTest = _mm_movemask_ps(_mm_castsi128_ps(vTemp));
    uint32_t CR = 0;
    if (iTest == 0xf)     
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (iTest == 0)  
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 12907 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}

inline bool __vectorcall XMVector4NearEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR Epsilon
) noexcept
{











#line 12928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"









#line 12938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vDelta = _mm_sub_ps(V1, V2);
    
    XMVECTOR vTemp = _mm_setzero_ps();
    vTemp = _mm_sub_ps(vTemp, vDelta);
    vTemp = _mm_max_ps(vTemp, vDelta);
    vTemp = _mm_cmple_ps(vTemp, Epsilon);
    return ((_mm_movemask_ps(vTemp) == 0xf) != 0);
#line 12947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4NotEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 12960 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 12965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpneq_ps(V1, V2);
    return ((_mm_movemask_ps(vTemp)) != 0);


#line 12970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4NotEqualInt
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 12983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 12988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    __m128i vTemp = _mm_cmpeq_epi32(_mm_castps_si128(V1), _mm_castps_si128(V2));
    return ((_mm_movemask_ps(_mm_castsi128_ps(vTemp)) != 0xF) != 0);


#line 12993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4Greater
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 13006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 13011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpgt_ps(V1, V2);
    return ((_mm_movemask_ps(vTemp) == 0x0f) != 0);


#line 13016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector4GreaterR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


















#line 13045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 13061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    uint32_t CR = 0;
    XMVECTOR vTemp = _mm_cmpgt_ps(V1, V2);
    int iTest = _mm_movemask_ps(vTemp);
    if (iTest == 0xf)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 13074 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4GreaterOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 13087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 13092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmpge_ps(V1, V2);
    return ((_mm_movemask_ps(vTemp) == 0x0f) != 0);


#line 13097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline uint32_t __vectorcall XMVector4GreaterOrEqualR
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


















#line 13126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 13142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    uint32_t CR = 0;
    XMVECTOR vTemp = _mm_cmpge_ps(V1, V2);
    int iTest = _mm_movemask_ps(vTemp);
    if (iTest == 0x0f)
    {
        CR = XM_CRMASK_CR6TRUE;
    }
    else if (!iTest)
    {
        CR = XM_CRMASK_CR6FALSE;
    }
    return CR;
#line 13155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4Less
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 13168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 13173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmplt_ps(V1, V2);
    return ((_mm_movemask_ps(vTemp) == 0x0f) != 0);


#line 13178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4LessOrEqual
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{


#line 13191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 13196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp = _mm_cmple_ps(V1, V2);
    return ((_mm_movemask_ps(vTemp) == 0x0f) != 0);


#line 13201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline bool __vectorcall XMVector4InBounds
(
    FXMVECTOR V,
    FXMVECTOR Bounds
) noexcept
{





#line 13217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"












#line 13230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTemp1 = _mm_cmple_ps(V, Bounds);
    
    XMVECTOR vTemp2 = _mm_mul_ps(Bounds, g_XMNegativeOne);
    
    vTemp2 = _mm_cmple_ps(vTemp2, V);
    
    vTemp1 = _mm_and_ps(vTemp1, vTemp2);
    
    return ((_mm_movemask_ps(vTemp1) == 0x0f) != 0);


#line 13243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}




#pragma float_control(push)
#pragma float_control(precise, on)
#line 13251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

inline bool __vectorcall XMVector4IsNaN(FXMVECTOR V) noexcept
{





#line 13260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 13267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTempNan = _mm_cmpneq_ps(V, V);
    
    return (_mm_movemask_ps(vTempNan) != 0);
#line 13272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}


#pragma float_control(pop)
#line 13277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



inline bool __vectorcall XMVector4IsInfinite(FXMVECTOR V) noexcept
{







#line 13290 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"








#line 13299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vTemp = _mm_and_ps(V, g_XMAbsMask);
    
    vTemp = _mm_cmpeq_ps(vTemp, g_XMInfinity);
    
    return (_mm_movemask_ps(vTemp) != 0);
#line 13306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}







inline XMVECTOR __vectorcall XMVector4Dot
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{









#line 13330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 13337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#line 13339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 13343 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vTemp2 = V2;
    XMVECTOR vTemp = _mm_mul_ps(V1, vTemp2);
    vTemp2 = _mm_shuffle_ps(vTemp2, vTemp, (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0)))); 
    vTemp2 = _mm_add_ps(vTemp2, vTemp);          
    vTemp = _mm_shuffle_ps(vTemp, vTemp2, (((0) << 6) | ((3) << 4) | ((0) << 2) | ((0))));  
    vTemp = _mm_add_ps(vTemp, vTemp2);           
    return _mm_shuffle_ps((vTemp), (vTemp), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );    
#line 13351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4Cross
(
    FXMVECTOR V1,
    FXMVECTOR V2,
    FXMVECTOR V3
) noexcept
{
    
    
    
    











#line 13378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
















































































#line 13459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vResult = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((1) << 4) | ((3) << 2) | ((2))) );
    XMVECTOR vTemp3 = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((3))) );
    vResult = _mm_mul_ps(vResult, vTemp3);
    
    XMVECTOR vTemp2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((3))) );
    vTemp3 = _mm_shuffle_ps((vTemp3), (vTemp3), (((1) << 6) | ((3) << 4) | ((0) << 2) | ((1))) );
    vResult = _mm_sub_ps((vResult), _mm_mul_ps((vTemp2), (vTemp3)));
     
    XMVECTOR vTemp1 = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((1))) );
    vResult = _mm_mul_ps(vResult, vTemp1);

    
    vTemp2 = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((0) << 4) | ((3) << 2) | ((1))) );
    vTemp3 = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((3) << 4) | ((0) << 2) | ((3))) );
    vTemp3 = _mm_mul_ps(vTemp3, vTemp2);
    
    vTemp2 = _mm_shuffle_ps((vTemp2), (vTemp2), (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))) );
    vTemp1 = _mm_shuffle_ps((V3), (V3), (((2) << 6) | ((0) << 4) | ((3) << 2) | ((1))) );
    vTemp3 = _mm_sub_ps((vTemp3), _mm_mul_ps((vTemp2), (vTemp1)));
    
    vTemp1 = _mm_shuffle_ps((V1), (V1), (((1) << 6) | ((1) << 4) | ((2) << 2) | ((2))) );
    vResult = _mm_sub_ps((vResult), _mm_mul_ps((vTemp1), (vTemp3)));

    
    vTemp2 = _mm_shuffle_ps((V2), (V2), (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    vTemp3 = _mm_shuffle_ps((V3), (V3), (((0) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );
    vTemp3 = _mm_mul_ps(vTemp3, vTemp2);
    
    vTemp2 = _mm_shuffle_ps((vTemp2), (vTemp2), (((2) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    vTemp1 = _mm_shuffle_ps((V3), (V3), (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    vTemp3 = _mm_sub_ps((vTemp3), _mm_mul_ps((vTemp1), (vTemp2)));
    
    vTemp1 = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    vResult = _mm_add_ps(_mm_mul_ps((vTemp3), (vTemp1)), (vResult));
    return vResult;
#line 13496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4LengthSq(FXMVECTOR V) noexcept
{
    return XMVector4Dot(V, V);
}



inline XMVECTOR __vectorcall XMVector4ReciprocalLengthEst(FXMVECTOR V) noexcept
{









#line 13519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"









#line 13529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 13532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 13538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vTemp = _mm_shuffle_ps(vTemp, vLengthSq, (((3) << 6) | ((3) << 4) | ((0) << 2) | ((0))));
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    
    vLengthSq = _mm_rsqrt_ps(vLengthSq);
    return vLengthSq;
#line 13556 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4ReciprocalLength(FXMVECTOR V) noexcept
{









#line 13572 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"















#line 13588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 13592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 13599 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vTemp = _mm_shuffle_ps(vTemp, vLengthSq, (((3) << 6) | ((3) << 4) | ((0) << 2) | ((0))));
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    
    vLengthSq = _mm_sqrt_ps(vLengthSq);
    
    vLengthSq = _mm_div_ps(g_XMOne, vLengthSq);
    return vLengthSq;
#line 13619 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4LengthEst(FXMVECTOR V) noexcept
{









#line 13635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"













#line 13649 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 13652 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 13658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vTemp = _mm_shuffle_ps(vTemp, vLengthSq, (((3) << 6) | ((3) << 4) | ((0) << 2) | ((0))));
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    
    vLengthSq = _mm_sqrt_ps(vLengthSq);
    return vLengthSq;
#line 13676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4Length(FXMVECTOR V) noexcept
{









#line 13692 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



















#line 13712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"


#line 13715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"





#line 13721 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vTemp = _mm_shuffle_ps(vTemp, vLengthSq, (((3) << 6) | ((3) << 4) | ((0) << 2) | ((0))));
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    
    vLengthSq = _mm_sqrt_ps(vLengthSq);
    return vLengthSq;
#line 13739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}





inline XMVECTOR __vectorcall XMVector4NormalizeEst(FXMVECTOR V) noexcept
{







#line 13755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"










#line 13766 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



#line 13770 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 13777 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vTemp = _mm_shuffle_ps(vTemp, vLengthSq, (((3) << 6) | ((3) << 4) | ((0) << 2) | ((0))));
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    
    XMVECTOR vResult = _mm_rsqrt_ps(vLengthSq);
    
    vResult = _mm_mul_ps(vResult, V);
    return vResult;
#line 13797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4Normalize(FXMVECTOR V) noexcept
{



















#line 13823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




















#line 13844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



















#line 13864 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






















#line 13887 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(V, V);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vTemp = _mm_shuffle_ps(vTemp, vLengthSq, (((3) << 6) | ((3) << 4) | ((0) << 2) | ((0))));
    
    vLengthSq = _mm_add_ps(vLengthSq, vTemp);
    
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    
    XMVECTOR vResult = _mm_sqrt_ps(vLengthSq);
    
    XMVECTOR vZeroMask = _mm_setzero_ps();
    
    vZeroMask = _mm_cmpneq_ps(vZeroMask, vResult);
    
    
    vLengthSq = _mm_cmpneq_ps(vLengthSq, g_XMInfinity);
    
    vResult = _mm_div_ps(V, vResult);
    
    vResult = _mm_and_ps(vResult, vZeroMask);
    
    XMVECTOR vTemp1 = _mm_andnot_ps(vLengthSq, g_XMQNaN);
    XMVECTOR vTemp2 = _mm_and_ps(vResult, vLengthSq);
    vResult = _mm_or_ps(vTemp1, vTemp2);
    return vResult;
#line 13920 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4ClampLength
(
    FXMVECTOR V,
    float    LengthMin,
    float    LengthMax
) noexcept
{
    XMVECTOR ClampMax = XMVectorReplicate(LengthMax);
    XMVECTOR ClampMin = XMVectorReplicate(LengthMin);

    return XMVector4ClampLengthV(V, ClampMin, ClampMax);
}



inline XMVECTOR __vectorcall XMVector4ClampLengthV
(
    FXMVECTOR V,
    FXMVECTOR LengthMin,
    FXMVECTOR LengthMax
) noexcept
{
    (void)( (!!((XMVectorGetY(LengthMin) == XMVectorGetX(LengthMin)) && (XMVectorGetZ(LengthMin) == XMVectorGetX(LengthMin)) && (XMVectorGetW(LengthMin) == XMVectorGetX(LengthMin)))) || (_wassert(L"(XMVectorGetY(LengthMin) == XMVectorGetX(LengthMin)) && (XMVectorGetZ(LengthMin) == XMVectorGetX(LengthMin)) && (XMVectorGetW(LengthMin) == XMVectorGetX(LengthMin))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(13946)), 0) );
    (void)( (!!((XMVectorGetY(LengthMax) == XMVectorGetX(LengthMax)) && (XMVectorGetZ(LengthMax) == XMVectorGetX(LengthMax)) && (XMVectorGetW(LengthMax) == XMVectorGetX(LengthMax)))) || (_wassert(L"(XMVectorGetY(LengthMax) == XMVectorGetX(LengthMax)) && (XMVectorGetZ(LengthMax) == XMVectorGetX(LengthMax)) && (XMVectorGetW(LengthMax) == XMVectorGetX(LengthMax))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(13947)), 0) );
    (void)( (!!(XMVector4GreaterOrEqual(LengthMin, XMVectorZero()))) || (_wassert(L"XMVector4GreaterOrEqual(LengthMin, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(13948)), 0) );
    (void)( (!!(XMVector4GreaterOrEqual(LengthMax, XMVectorZero()))) || (_wassert(L"XMVector4GreaterOrEqual(LengthMax, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(13949)), 0) );
    (void)( (!!(XMVector4GreaterOrEqual(LengthMax, LengthMin))) || (_wassert(L"XMVector4GreaterOrEqual(LengthMax, LengthMin)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(13950)), 0) );

    XMVECTOR LengthSq = XMVector4LengthSq(V);

    const XMVECTOR Zero = XMVectorZero();

    XMVECTOR RcpLength = XMVectorReciprocalSqrt(LengthSq);

    XMVECTOR InfiniteLength = XMVectorEqualInt(LengthSq, g_XMInfinity.v);
    XMVECTOR ZeroLength = XMVectorEqual(LengthSq, Zero);

    XMVECTOR Normal = XMVectorMultiply(V, RcpLength);

    XMVECTOR Length = XMVectorMultiply(LengthSq, RcpLength);

    XMVECTOR Select = XMVectorEqualInt(InfiniteLength, ZeroLength);
    Length = XMVectorSelect(LengthSq, Length, Select);
    Normal = XMVectorSelect(LengthSq, Normal, Select);

    XMVECTOR ControlMax = XMVectorGreater(Length, LengthMax);
    XMVECTOR ControlMin = XMVectorLess(Length, LengthMin);

    XMVECTOR ClampLength = XMVectorSelect(Length, LengthMax, ControlMax);
    ClampLength = XMVectorSelect(ClampLength, LengthMin, ControlMin);

    XMVECTOR Result = XMVectorMultiply(Normal, ClampLength);

    
    XMVECTOR Control = XMVectorEqualInt(ControlMax, ControlMin);
    Result = XMVectorSelect(Result, V, Control);

    return Result;
}



inline XMVECTOR __vectorcall XMVector4Reflect
(
    FXMVECTOR Incident,
    FXMVECTOR Normal
) noexcept
{
    

    XMVECTOR Result = XMVector4Dot(Incident, Normal);
    Result = XMVectorAdd(Result, Result);
    Result = XMVectorNegativeMultiplySubtract(Result, Normal, Incident);

    return Result;
}



inline XMVECTOR __vectorcall XMVector4Refract
(
    FXMVECTOR Incident,
    FXMVECTOR Normal,
    float    RefractionIndex
) noexcept
{
    XMVECTOR Index = XMVectorReplicate(RefractionIndex);
    return XMVector4RefractV(Incident, Normal, Index);
}



inline XMVECTOR __vectorcall XMVector4RefractV
(
    FXMVECTOR Incident,
    FXMVECTOR Normal,
    FXMVECTOR RefractionIndex
) noexcept
{




































#line 14060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"



































#line 14096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR IDotN = XMVector4Dot(Incident, Normal);

    
    XMVECTOR R = _mm_sub_ps((g_XMOne), _mm_mul_ps((IDotN), (IDotN)));
    XMVECTOR R2 = _mm_mul_ps(RefractionIndex, RefractionIndex);
    R = _mm_sub_ps((g_XMOne), _mm_mul_ps((R), (R2)));

    XMVECTOR vResult = _mm_cmple_ps(R, g_XMZero);
    if (_mm_movemask_ps(vResult) == 0x0f)
    {
        
        vResult = g_XMZero;
    }
    else
    {
        
        R = _mm_sqrt_ps(R);
        R = _mm_add_ps(_mm_mul_ps((RefractionIndex), (IDotN)), (R));
        
        vResult = _mm_mul_ps(RefractionIndex, Incident);
        vResult = _mm_sub_ps((vResult), _mm_mul_ps((R), (Normal)));
    }
    return vResult;
#line 14120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4Orthogonal(FXMVECTOR V) noexcept
{










#line 14137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 14142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    static const XMVECTORF32 FlipZW = { { { 1.0f, 1.0f, -1.0f, -1.0f } } };
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((1) << 6) | ((0) << 4) | ((3) << 2) | ((2))) );
    vResult = _mm_mul_ps(vResult, FlipZW);
    return vResult;
#line 14147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMVECTOR __vectorcall XMVector4AngleBetweenNormalsEst
(
    FXMVECTOR N1,
    FXMVECTOR N2
) noexcept
{
    XMVECTOR Result = XMVector4Dot(N1, N2);
    Result = XMVectorClamp(Result, g_XMNegativeOne.v, g_XMOne.v);
    Result = XMVectorACosEst(Result);
    return Result;
}



inline XMVECTOR __vectorcall XMVector4AngleBetweenNormals
(
    FXMVECTOR N1,
    FXMVECTOR N2
) noexcept
{
    XMVECTOR Result = XMVector4Dot(N1, N2);
    Result = XMVectorClamp(Result, g_XMNegativeOne.v, g_XMOne.v);
    Result = XMVectorACos(Result);
    return Result;
}



inline XMVECTOR __vectorcall XMVector4AngleBetweenVectors
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    XMVECTOR L1 = XMVector4ReciprocalLength(V1);
    XMVECTOR L2 = XMVector4ReciprocalLength(V2);

    XMVECTOR Dot = XMVector4Dot(V1, V2);

    L1 = XMVectorMultiply(L1, L2);

    XMVECTOR CosAngle = XMVectorMultiply(Dot, L1);
    CosAngle = XMVectorClamp(CosAngle, g_XMNegativeOne.v, g_XMOne.v);

    return XMVectorACos(CosAngle);
}



inline XMVECTOR __vectorcall XMVector4Transform
(
    FXMVECTOR V,
    FXMMATRIX M
) noexcept
{









#line 14216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"






#line 14223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    XMVECTOR vResult = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) ); 
    vResult = _mm_mul_ps(vResult, M.r[3]);
    XMVECTOR vTemp = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[2])), (vResult));
    vTemp = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[1])), (vResult));
    vTemp = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) ); 
    vResult = _mm_add_ps(_mm_mul_ps((vTemp), (M.r[0])), (vResult));
    return vResult;
#line 14233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}



inline XMFLOAT4* __vectorcall XMVector4TransformStream
(
    XMFLOAT4* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT4* pInputStream,
    size_t          InputStride,
    size_t          VectorCount,
    FXMMATRIX       M
) noexcept
{
    (void)( (!!(pOutputStream != nullptr)) || (_wassert(L"pOutputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(14247)), 0) );
    (void)( (!!(pInputStream != nullptr)) || (_wassert(L"pInputStream != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(14248)), 0) );

    (void)( (!!(InputStride >= sizeof(XMFLOAT4))) || (_wassert(L"InputStride >= sizeof(XMFLOAT4)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(14250)), 0) );
    ;

    (void)( (!!(OutputStride >= sizeof(XMFLOAT4))) || (_wassert(L"OutputStride >= sizeof(XMFLOAT4)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl", (unsigned)(14253)), 0) );
    ;









































#line 14297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

































































































#line 14395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
































































































































#line 14524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
    auto pInputVector = reinterpret_cast<const uint8_t*>(pInputStream);
    auto pOutputVector = reinterpret_cast<uint8_t*>(pOutputStream);

    const XMVECTOR row0 = M.r[0];
    const XMVECTOR row1 = M.r[1];
    const XMVECTOR row2 = M.r[2];
    const XMVECTOR row3 = M.r[3];

    if (!(reinterpret_cast<uintptr_t>(pOutputStream) & 0xF) && !(OutputStride & 0xF))
    {
        if (!(reinterpret_cast<uintptr_t>(pInputStream) & 0xF) && !(InputStride & 0xF))
        {
            
            for (size_t i = 0; i < VectorCount; i++)
            {
                __m128 V = _mm_load_ps(reinterpret_cast<const float*>(pInputVector));
                pInputVector += InputStride;

                XMVECTOR vTempX = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
                XMVECTOR vTempY = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                XMVECTOR vTempZ = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                XMVECTOR vTempW = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                vTempX = _mm_mul_ps(vTempX, row0);
                vTempY = _mm_mul_ps(vTempY, row1);
                vTempZ = _mm_add_ps(_mm_mul_ps((vTempZ), (row2)), (vTempX));
                vTempW = _mm_add_ps(_mm_mul_ps((vTempW), (row3)), (vTempY));
                vTempX = _mm_add_ps(vTempZ, vTempW);

                _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTempX));
                pOutputVector += OutputStride;
            }
        }
        else
        {
            
            for (size_t i = 0; i < VectorCount; i++)
            {
                __m128 V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                pInputVector += InputStride;

                XMVECTOR vTempX = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
                XMVECTOR vTempY = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                XMVECTOR vTempZ = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                XMVECTOR vTempW = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                vTempX = _mm_mul_ps(vTempX, row0);
                vTempY = _mm_mul_ps(vTempY, row1);
                vTempZ = _mm_add_ps(_mm_mul_ps((vTempZ), (row2)), (vTempX));
                vTempW = _mm_add_ps(_mm_mul_ps((vTempW), (row3)), (vTempY));
                vTempX = _mm_add_ps(vTempZ, vTempW);

                _mm_stream_ps((reinterpret_cast<float*>(pOutputVector)), (vTempX));
                pOutputVector += OutputStride;
            }
        }
    }
    else
    {
        if (!(reinterpret_cast<uintptr_t>(pInputStream) & 0xF) && !(InputStride & 0xF))
        {
            
            for (size_t i = 0; i < VectorCount; i++)
            {
                __m128 V = _mm_load_ps(reinterpret_cast<const float*>(pInputVector));
                pInputVector += InputStride;

                XMVECTOR vTempX = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
                XMVECTOR vTempY = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                XMVECTOR vTempZ = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                XMVECTOR vTempW = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                vTempX = _mm_mul_ps(vTempX, row0);
                vTempY = _mm_mul_ps(vTempY, row1);
                vTempZ = _mm_add_ps(_mm_mul_ps((vTempZ), (row2)), (vTempX));
                vTempW = _mm_add_ps(_mm_mul_ps((vTempW), (row3)), (vTempY));
                vTempX = _mm_add_ps(vTempZ, vTempW);

                _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTempX);
                pOutputVector += OutputStride;
            }
        }
        else
        {
            
            for (size_t i = 0; i < VectorCount; i++)
            {
                __m128 V = _mm_loadu_ps(reinterpret_cast<const float*>(pInputVector));
                pInputVector += InputStride;

                XMVECTOR vTempX = _mm_shuffle_ps((V), (V), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
                XMVECTOR vTempY = _mm_shuffle_ps((V), (V), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
                XMVECTOR vTempZ = _mm_shuffle_ps((V), (V), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
                XMVECTOR vTempW = _mm_shuffle_ps((V), (V), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );

                vTempX = _mm_mul_ps(vTempX, row0);
                vTempY = _mm_mul_ps(vTempY, row1);
                vTempZ = _mm_add_ps(_mm_mul_ps((vTempZ), (row2)), (vTempX));
                vTempW = _mm_add_ps(_mm_mul_ps((vTempW), (row3)), (vTempY));
                vTempX = _mm_add_ps(vTempZ, vTempW);

                _mm_storeu_ps(reinterpret_cast<float*>(pOutputVector), vTempX);
                pOutputVector += OutputStride;
            }
        }
    }

    _mm_sfence();

    return pOutputStream;
#line 14635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"
}









 

inline XMVECTOR __vectorcall operator+ (FXMVECTOR V) noexcept
{
    return V;
}



inline XMVECTOR __vectorcall operator- (FXMVECTOR V) noexcept
{
    return XMVectorNegate(V);
}



inline XMVECTOR& __vectorcall operator+=
(
    XMVECTOR& V1,
    FXMVECTOR       V2
) noexcept
{
    V1 = XMVectorAdd(V1, V2);
    return V1;
}



inline XMVECTOR& __vectorcall operator-=
(
    XMVECTOR& V1,
    FXMVECTOR       V2
) noexcept
{
    V1 = XMVectorSubtract(V1, V2);
    return V1;
}



inline XMVECTOR& __vectorcall operator*=
(
    XMVECTOR& V1,
    FXMVECTOR       V2
) noexcept
{
    V1 = XMVectorMultiply(V1, V2);
    return V1;
}



inline XMVECTOR& __vectorcall operator/=
(
    XMVECTOR& V1,
    FXMVECTOR       V2
) noexcept
{
    V1 = XMVectorDivide(V1, V2);
    return V1;
}



inline XMVECTOR& operator*=
(
    XMVECTOR& V,
    const float S
) noexcept
{
    V = XMVectorScale(V, S);
    return V;
}



inline XMVECTOR& operator/=
(
    XMVECTOR& V,
    const float S
) noexcept
{
    XMVECTOR vS = XMVectorReplicate(S);
    V = XMVectorDivide(V, vS);
    return V;
}



inline XMVECTOR __vectorcall operator+
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    return XMVectorAdd(V1, V2);
}



inline XMVECTOR __vectorcall operator-
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    return XMVectorSubtract(V1, V2);
}



inline XMVECTOR __vectorcall operator*
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    return XMVectorMultiply(V1, V2);
}



inline XMVECTOR __vectorcall operator/
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    return XMVectorDivide(V1, V2);
}



inline XMVECTOR __vectorcall operator*
(
    FXMVECTOR      V,
    const float    S
) noexcept
{
    return XMVectorScale(V, S);
}



inline XMVECTOR __vectorcall operator/
(
    FXMVECTOR      V,
    const float    S
) noexcept
{
    XMVECTOR vS = XMVectorReplicate(S);
    return XMVectorDivide(V, vS);
}



inline XMVECTOR __vectorcall operator*
(
    float           S,
    FXMVECTOR       V
) noexcept
{
    return XMVectorScale(V, S);
}

#line 14811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 14816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"




#line 14821 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathVector.inl"

#pragma external_header(pop)
#line 2225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"









#pragma once







 
 
 

 


#pragma float_control(push)
#pragma float_control(precise, on)
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"


inline bool __vectorcall XMMatrixIsNaN(FXMMATRIX M) noexcept
{

















#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"





















#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    XMVECTOR vX = M.r[0];
    XMVECTOR vY = M.r[1];
    XMVECTOR vZ = M.r[2];
    XMVECTOR vW = M.r[3];
    
    vX = _mm_cmpneq_ps(vX, vX);
    vY = _mm_cmpneq_ps(vY, vY);
    vZ = _mm_cmpneq_ps(vZ, vZ);
    vW = _mm_cmpneq_ps(vW, vW);
    
    vX = _mm_or_ps(vX, vZ);
    vY = _mm_or_ps(vY, vW);
    vX = _mm_or_ps(vX, vY);
    
    return (_mm_movemask_ps(vX) != 0);

#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}


#pragma float_control(pop)
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"




inline bool __vectorcall XMMatrixIsInfinite(FXMMATRIX M) noexcept
{
















#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"


























#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    XMVECTOR vTemp1 = _mm_and_ps(M.r[0], g_XMAbsMask);
    XMVECTOR vTemp2 = _mm_and_ps(M.r[1], g_XMAbsMask);
    XMVECTOR vTemp3 = _mm_and_ps(M.r[2], g_XMAbsMask);
    XMVECTOR vTemp4 = _mm_and_ps(M.r[3], g_XMAbsMask);
    
    vTemp1 = _mm_cmpeq_ps(vTemp1, g_XMInfinity);
    vTemp2 = _mm_cmpeq_ps(vTemp2, g_XMInfinity);
    vTemp3 = _mm_cmpeq_ps(vTemp3, g_XMInfinity);
    vTemp4 = _mm_cmpeq_ps(vTemp4, g_XMInfinity);
    
    vTemp1 = _mm_or_ps(vTemp1, vTemp2);
    vTemp3 = _mm_or_ps(vTemp3, vTemp4);
    vTemp1 = _mm_or_ps(vTemp1, vTemp3);
    
    return (_mm_movemask_ps(vTemp1) != 0);
#line 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}




inline bool __vectorcall XMMatrixIsIdentity(FXMMATRIX M) noexcept
{





























#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"











#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMVECTOR vTemp1 = _mm_cmpeq_ps(M.r[0], g_XMIdentityR0);
    XMVECTOR vTemp2 = _mm_cmpeq_ps(M.r[1], g_XMIdentityR1);
    XMVECTOR vTemp3 = _mm_cmpeq_ps(M.r[2], g_XMIdentityR2);
    XMVECTOR vTemp4 = _mm_cmpeq_ps(M.r[3], g_XMIdentityR3);
    vTemp1 = _mm_and_ps(vTemp1, vTemp2);
    vTemp3 = _mm_and_ps(vTemp3, vTemp4);
    vTemp1 = _mm_and_ps(vTemp1, vTemp3);
    return (_mm_movemask_ps(vTemp1) == 0x0f);
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}







inline XMMATRIX __vectorcall XMMatrixMultiply
(
    FXMMATRIX M1,
    CXMMATRIX M2
) noexcept
{






































#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
































#line 306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"











































#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX mResult;
    





#line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    XMVECTOR vW = M1.r[0];
    XMVECTOR vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    XMVECTOR vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    XMVECTOR vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    mResult.r[0] = vX;
    





#line 382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vW = M1.r[1];
    vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    mResult.r[1] = vX;





#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vW = M1.r[2];
    vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    mResult.r[2] = vX;





#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vW = M1.r[3];
    vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    mResult.r[3] = vX;
    return mResult;
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixMultiplyTranspose
(
    FXMMATRIX M1,
    CXMMATRIX M2
) noexcept
{






































#line 487 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"












































#line 532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"





















































#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    





#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    XMVECTOR vW = M1.r[0];
    XMVECTOR vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    XMVECTOR vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    XMVECTOR vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    XMVECTOR r0 = vX;
    





#line 617 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vW = M1.r[1];
    vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    XMVECTOR r1 = vX;





#line 637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vW = M1.r[2];
    vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    XMVECTOR r2 = vX;





#line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vW = M1.r[3];
    vX = _mm_shuffle_ps((vW), (vW), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    vY = _mm_shuffle_ps((vW), (vW), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vZ = _mm_shuffle_ps((vW), (vW), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    vW = _mm_shuffle_ps((vW), (vW), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    vX = _mm_mul_ps(vX, M2.r[0]);
    vY = _mm_mul_ps(vY, M2.r[1]);
    vZ = _mm_mul_ps(vZ, M2.r[2]);
    vW = _mm_mul_ps(vW, M2.r[3]);
    vX = _mm_add_ps(vX, vZ);
    vY = _mm_add_ps(vY, vW);
    vX = _mm_add_ps(vX, vY);
    XMVECTOR r3 = vX;

    
    
    XMVECTOR vTemp1 = _mm_shuffle_ps(r0, r1, (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(r0, r1, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    XMVECTOR vTemp2 = _mm_shuffle_ps(r2, r3, (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp4 = _mm_shuffle_ps(r2, r3, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));

    XMMATRIX mResult;
    
    mResult.r[0] = _mm_shuffle_ps(vTemp1, vTemp2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[1] = _mm_shuffle_ps(vTemp1, vTemp2, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    
    mResult.r[2] = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[3] = _mm_shuffle_ps(vTemp3, vTemp4, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    return mResult;
#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixTranspose(FXMMATRIX M) noexcept
{






















#line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"












#line 735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"




















#line 756 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    XMVECTOR vTemp1 = _mm_shuffle_ps(M.r[0], M.r[1], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp3 = _mm_shuffle_ps(M.r[0], M.r[1], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    XMVECTOR vTemp2 = _mm_shuffle_ps(M.r[2], M.r[3], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR vTemp4 = _mm_shuffle_ps(M.r[2], M.r[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));

    XMMATRIX mResult;
    
    mResult.r[0] = _mm_shuffle_ps(vTemp1, vTemp2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[1] = _mm_shuffle_ps(vTemp1, vTemp2, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    
    mResult.r[2] = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    mResult.r[3] = _mm_shuffle_ps(vTemp3, vTemp4, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    return mResult;
#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}




inline XMMATRIX __vectorcall XMMatrixInverse
(
    XMVECTOR* pDeterminant,
    FXMMATRIX  M
) noexcept
{





























































































#line 881 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    
    XMVECTOR vTemp1 = _mm_shuffle_ps(M.r[0], M.r[1], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    XMVECTOR vTemp3 = _mm_shuffle_ps(M.r[0], M.r[1], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    XMVECTOR vTemp2 = _mm_shuffle_ps(M.r[2], M.r[3], (((1) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    XMVECTOR vTemp4 = _mm_shuffle_ps(M.r[2], M.r[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));

    XMMATRIX MT;
    MT.r[0] = _mm_shuffle_ps(vTemp1, vTemp2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    MT.r[1] = _mm_shuffle_ps(vTemp1, vTemp2, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    MT.r[2] = _mm_shuffle_ps(vTemp3, vTemp4, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    MT.r[3] = _mm_shuffle_ps(vTemp3, vTemp4, (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));

    XMVECTOR V00 = _mm_shuffle_ps((MT.r[2]), (MT.r[2]), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((0))) );
    XMVECTOR V10 = _mm_shuffle_ps((MT.r[3]), (MT.r[3]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    XMVECTOR V01 = _mm_shuffle_ps((MT.r[0]), (MT.r[0]), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((0))) );
    XMVECTOR V11 = _mm_shuffle_ps((MT.r[1]), (MT.r[1]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    XMVECTOR V02 = _mm_shuffle_ps(MT.r[2], MT.r[0], (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    XMVECTOR V12 = _mm_shuffle_ps(MT.r[3], MT.r[1], (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));

    XMVECTOR D0 = _mm_mul_ps(V00, V10);
    XMVECTOR D1 = _mm_mul_ps(V01, V11);
    XMVECTOR D2 = _mm_mul_ps(V02, V12);

    V00 = _mm_shuffle_ps((MT.r[2]), (MT.r[2]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    V10 = _mm_shuffle_ps((MT.r[3]), (MT.r[3]), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((0))) );
    V01 = _mm_shuffle_ps((MT.r[0]), (MT.r[0]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))) );
    V11 = _mm_shuffle_ps((MT.r[1]), (MT.r[1]), (((1) << 6) | ((1) << 4) | ((0) << 2) | ((0))) );
    V02 = _mm_shuffle_ps(MT.r[2], MT.r[0], (((3) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    V12 = _mm_shuffle_ps(MT.r[3], MT.r[1], (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));

    D0 = _mm_sub_ps((D0), _mm_mul_ps((V00), (V10)));
    D1 = _mm_sub_ps((D1), _mm_mul_ps((V01), (V11)));
    D2 = _mm_sub_ps((D2), _mm_mul_ps((V02), (V12)));
    
    V11 = _mm_shuffle_ps(D0, D2, (((1) << 6) | ((1) << 4) | ((3) << 2) | ((1))));
    V00 = _mm_shuffle_ps((MT.r[1]), (MT.r[1]), (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    V10 = _mm_shuffle_ps(V11, D0, (((0) << 6) | ((3) << 4) | ((0) << 2) | ((2))));
    V01 = _mm_shuffle_ps((MT.r[0]), (MT.r[0]), (((0) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );
    V11 = _mm_shuffle_ps(V11, D0, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))));
    
    XMVECTOR V13 = _mm_shuffle_ps(D1, D2, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((1))));
    V02 = _mm_shuffle_ps((MT.r[3]), (MT.r[3]), (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    V12 = _mm_shuffle_ps(V13, D1, (((0) << 6) | ((3) << 4) | ((0) << 2) | ((2))));
    XMVECTOR V03 = _mm_shuffle_ps((MT.r[2]), (MT.r[2]), (((0) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );
    V13 = _mm_shuffle_ps(V13, D1, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))));

    XMVECTOR C0 = _mm_mul_ps(V00, V10);
    XMVECTOR C2 = _mm_mul_ps(V01, V11);
    XMVECTOR C4 = _mm_mul_ps(V02, V12);
    XMVECTOR C6 = _mm_mul_ps(V03, V13);

    
    V11 = _mm_shuffle_ps(D0, D2, (((0) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    V00 = _mm_shuffle_ps((MT.r[1]), (MT.r[1]), (((2) << 6) | ((1) << 4) | ((3) << 2) | ((2))) );
    V10 = _mm_shuffle_ps(D0, V11, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((3))));
    V01 = _mm_shuffle_ps((MT.r[0]), (MT.r[0]), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((3))) );
    V11 = _mm_shuffle_ps(D0, V11, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((2))));
    
    V13 = _mm_shuffle_ps(D1, D2, (((2) << 6) | ((2) << 4) | ((1) << 2) | ((0))));
    V02 = _mm_shuffle_ps((MT.r[3]), (MT.r[3]), (((2) << 6) | ((1) << 4) | ((3) << 2) | ((2))) );
    V12 = _mm_shuffle_ps(D1, V13, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((3))));
    V03 = _mm_shuffle_ps((MT.r[2]), (MT.r[2]), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((3))) );
    V13 = _mm_shuffle_ps(D1, V13, (((0) << 6) | ((2) << 4) | ((1) << 2) | ((2))));

    C0 = _mm_sub_ps((C0), _mm_mul_ps((V00), (V10)));
    C2 = _mm_sub_ps((C2), _mm_mul_ps((V01), (V11)));
    C4 = _mm_sub_ps((C4), _mm_mul_ps((V02), (V12)));
    C6 = _mm_sub_ps((C6), _mm_mul_ps((V03), (V13)));

    V00 = _mm_shuffle_ps((MT.r[1]), (MT.r[1]), (((0) << 6) | ((3) << 4) | ((0) << 2) | ((3))) );
    
    V10 = _mm_shuffle_ps(D0, D2, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
    V10 = _mm_shuffle_ps((V10), (V10), (((0) << 6) | ((2) << 4) | ((3) << 2) | ((0))) );
    V01 = _mm_shuffle_ps((MT.r[0]), (MT.r[0]), (((2) << 6) | ((0) << 4) | ((3) << 2) | ((1))) );
    
    V11 = _mm_shuffle_ps(D0, D2, (((1) << 6) | ((0) << 4) | ((3) << 2) | ((0))));
    V11 = _mm_shuffle_ps((V11), (V11), (((2) << 6) | ((1) << 4) | ((0) << 2) | ((3))) );
    V02 = _mm_shuffle_ps((MT.r[3]), (MT.r[3]), (((0) << 6) | ((3) << 4) | ((0) << 2) | ((3))) );
    
    V12 = _mm_shuffle_ps(D1, D2, (((3) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
    V12 = _mm_shuffle_ps((V12), (V12), (((0) << 6) | ((2) << 4) | ((3) << 2) | ((0))) );
    V03 = _mm_shuffle_ps((MT.r[2]), (MT.r[2]), (((2) << 6) | ((0) << 4) | ((3) << 2) | ((1))) );
    
    V13 = _mm_shuffle_ps(D1, D2, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((0))));
    V13 = _mm_shuffle_ps((V13), (V13), (((2) << 6) | ((1) << 4) | ((0) << 2) | ((3))) );

    V00 = _mm_mul_ps(V00, V10);
    V01 = _mm_mul_ps(V01, V11);
    V02 = _mm_mul_ps(V02, V12);
    V03 = _mm_mul_ps(V03, V13);
    XMVECTOR C1 = _mm_sub_ps(C0, V00);
    C0 = _mm_add_ps(C0, V00);
    XMVECTOR C3 = _mm_add_ps(C2, V01);
    C2 = _mm_sub_ps(C2, V01);
    XMVECTOR C5 = _mm_sub_ps(C4, V02);
    C4 = _mm_add_ps(C4, V02);
    XMVECTOR C7 = _mm_add_ps(C6, V03);
    C6 = _mm_sub_ps(C6, V03);

    C0 = _mm_shuffle_ps(C0, C1, (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
    C2 = _mm_shuffle_ps(C2, C3, (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
    C4 = _mm_shuffle_ps(C4, C5, (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
    C6 = _mm_shuffle_ps(C6, C7, (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
    C0 = _mm_shuffle_ps((C0), (C0), (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))) );
    C2 = _mm_shuffle_ps((C2), (C2), (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))) );
    C4 = _mm_shuffle_ps((C4), (C4), (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))) );
    C6 = _mm_shuffle_ps((C6), (C6), (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))) );
    
    XMVECTOR vTemp = XMVector4Dot(C0, MT.r[0]);
    if (pDeterminant != nullptr)
        *pDeterminant = vTemp;
    vTemp = _mm_div_ps(g_XMOne, vTemp);
    XMMATRIX mResult;
    mResult.r[0] = _mm_mul_ps(C0, vTemp);
    mResult.r[1] = _mm_mul_ps(C2, vTemp);
    mResult.r[2] = _mm_mul_ps(C4, vTemp);
    mResult.r[3] = _mm_mul_ps(C6, vTemp);
    return mResult;
#line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixVectorTensorProduct
(
    FXMVECTOR V1,
    FXMVECTOR V2
) noexcept
{
    XMMATRIX mResult;
    mResult.r[0] = XMVectorMultiply(XMVectorSwizzle<0, 0, 0, 0>(V1), V2);
    mResult.r[1] = XMVectorMultiply(XMVectorSwizzle<1, 1, 1, 1>(V1), V2);
    mResult.r[2] = XMVectorMultiply(XMVectorSwizzle<2, 2, 2, 2>(V1), V2);
    mResult.r[3] = XMVectorMultiply(XMVectorSwizzle<3, 3, 3, 3>(V1), V2);
    return mResult;
}



inline XMVECTOR __vectorcall XMMatrixDeterminant(FXMMATRIX M) noexcept
{
    static const XMVECTORF32 Sign = { { { 1.0f, -1.0f, 1.0f, -1.0f } } };

    XMVECTOR V0 = XMVectorSwizzle<XM_SWIZZLE_Y, XM_SWIZZLE_X, XM_SWIZZLE_X, XM_SWIZZLE_X>(M.r[2]);
    XMVECTOR V1 = XMVectorSwizzle<XM_SWIZZLE_Z, XM_SWIZZLE_Z, XM_SWIZZLE_Y, XM_SWIZZLE_Y>(M.r[3]);
    XMVECTOR V2 = XMVectorSwizzle<XM_SWIZZLE_Y, XM_SWIZZLE_X, XM_SWIZZLE_X, XM_SWIZZLE_X>(M.r[2]);
    XMVECTOR V3 = XMVectorSwizzle<XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_Z>(M.r[3]);
    XMVECTOR V4 = XMVectorSwizzle<XM_SWIZZLE_Z, XM_SWIZZLE_Z, XM_SWIZZLE_Y, XM_SWIZZLE_Y>(M.r[2]);
    XMVECTOR V5 = XMVectorSwizzle<XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_Z>(M.r[3]);

    XMVECTOR P0 = XMVectorMultiply(V0, V1);
    XMVECTOR P1 = XMVectorMultiply(V2, V3);
    XMVECTOR P2 = XMVectorMultiply(V4, V5);

    V0 = XMVectorSwizzle<XM_SWIZZLE_Z, XM_SWIZZLE_Z, XM_SWIZZLE_Y, XM_SWIZZLE_Y>(M.r[2]);
    V1 = XMVectorSwizzle<XM_SWIZZLE_Y, XM_SWIZZLE_X, XM_SWIZZLE_X, XM_SWIZZLE_X>(M.r[3]);
    V2 = XMVectorSwizzle<XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_Z>(M.r[2]);
    V3 = XMVectorSwizzle<XM_SWIZZLE_Y, XM_SWIZZLE_X, XM_SWIZZLE_X, XM_SWIZZLE_X>(M.r[3]);
    V4 = XMVectorSwizzle<XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_Z>(M.r[2]);
    V5 = XMVectorSwizzle<XM_SWIZZLE_Z, XM_SWIZZLE_Z, XM_SWIZZLE_Y, XM_SWIZZLE_Y>(M.r[3]);

    P0 = XMVectorNegativeMultiplySubtract(V0, V1, P0);
    P1 = XMVectorNegativeMultiplySubtract(V2, V3, P1);
    P2 = XMVectorNegativeMultiplySubtract(V4, V5, P2);

    V0 = XMVectorSwizzle<XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_W, XM_SWIZZLE_Z>(M.r[1]);
    V1 = XMVectorSwizzle<XM_SWIZZLE_Z, XM_SWIZZLE_Z, XM_SWIZZLE_Y, XM_SWIZZLE_Y>(M.r[1]);
    V2 = XMVectorSwizzle<XM_SWIZZLE_Y, XM_SWIZZLE_X, XM_SWIZZLE_X, XM_SWIZZLE_X>(M.r[1]);

    XMVECTOR S = XMVectorMultiply(M.r[0], Sign.v);
    XMVECTOR R = XMVectorMultiply(V0, P0);
    R = XMVectorNegativeMultiplySubtract(V1, P1, R);
    R = XMVectorMultiplyAdd(V2, P2, R);

    return XMVector4Dot(S, R);
}






















































inline bool __vectorcall XMMatrixDecompose
(
    XMVECTOR* outScale,
    XMVECTOR* outRotQuat,
    XMVECTOR* outTrans,
    FXMMATRIX M
) noexcept
{
    static const XMVECTOR* pvCanonicalBasis[3] = {
        &g_XMIdentityR0.v,
        &g_XMIdentityR1.v,
        &g_XMIdentityR2.v
    };

    (void)( (!!(outScale != nullptr)) || (_wassert(L"outScale != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(1125)), 0) );
    (void)( (!!(outRotQuat != nullptr)) || (_wassert(L"outRotQuat != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(1126)), 0) );
    (void)( (!!(outTrans != nullptr)) || (_wassert(L"outTrans != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(1127)), 0) );

    
    outTrans[0] = M.r[3];

    XMVECTOR* ppvBasis[3];
    XMMATRIX matTemp;
    ppvBasis[0] = &matTemp.r[0];
    ppvBasis[1] = &matTemp.r[1];
    ppvBasis[2] = &matTemp.r[2];

    matTemp.r[0] = M.r[0];
    matTemp.r[1] = M.r[1];
    matTemp.r[2] = M.r[2];
    matTemp.r[3] = g_XMIdentityR3.v;

    auto pfScales = reinterpret_cast<float*>(outScale);

    size_t a, b, c;
    XMVectorGetXPtr(&pfScales[0], XMVector3Length(ppvBasis[0][0]));
    XMVectorGetXPtr(&pfScales[1], XMVector3Length(ppvBasis[1][0]));
    XMVectorGetXPtr(&pfScales[2], XMVector3Length(ppvBasis[2][0]));
    pfScales[3] = 0.f;

    if((pfScales[0]) < (pfScales[1])) { if((pfScales[1]) < (pfScales[2])) { (a) = 2; (b) = 1; (c) = 0; } else { (a) = 1; if((pfScales[0]) < (pfScales[2])) { (b) = 2; (c) = 0; } else { (b) = 0; (c) = 2; } } } else { if((pfScales[0]) < (pfScales[2])) { (a) = 2; (b) = 0; (c) = 1; } else { (a) = 0; if((pfScales[1]) < (pfScales[2])) { (b) = 2; (c) = 1; } else { (b) = 1; (c) = 2; } } }

        if (pfScales[a] < 0.0001f)
        {
            ppvBasis[a][0] = pvCanonicalBasis[a][0];
        }
    ppvBasis[a][0] = XMVector3Normalize(ppvBasis[a][0]);

    if (pfScales[b] < 0.0001f)
    {
        size_t aa, bb, cc;
        float fAbsX, fAbsY, fAbsZ;

        fAbsX = fabsf(XMVectorGetX(ppvBasis[a][0]));
        fAbsY = fabsf(XMVectorGetY(ppvBasis[a][0]));
        fAbsZ = fabsf(XMVectorGetZ(ppvBasis[a][0]));

        if((fAbsX) < (fAbsY)) { if((fAbsY) < (fAbsZ)) { (aa) = 2; (bb) = 1; (cc) = 0; } else { (aa) = 1; if((fAbsX) < (fAbsZ)) { (bb) = 2; (cc) = 0; } else { (bb) = 0; (cc) = 2; } } } else { if((fAbsX) < (fAbsZ)) { (aa) = 2; (bb) = 0; (cc) = 1; } else { (aa) = 0; if((fAbsY) < (fAbsZ)) { (bb) = 2; (cc) = 1; } else { (bb) = 1; (cc) = 2; } } }

            ppvBasis[b][0] = XMVector3Cross(ppvBasis[a][0], pvCanonicalBasis[cc][0]);
    }

    ppvBasis[b][0] = XMVector3Normalize(ppvBasis[b][0]);

    if (pfScales[c] < 0.0001f)
    {
        ppvBasis[c][0] = XMVector3Cross(ppvBasis[a][0], ppvBasis[b][0]);
    }

    ppvBasis[c][0] = XMVector3Normalize(ppvBasis[c][0]);

    float fDet = XMVectorGetX(XMMatrixDeterminant(matTemp));

    
    if (fDet < 0.0f)
    {
        
        pfScales[a] = -pfScales[a];
        ppvBasis[a][0] = XMVectorNegate(ppvBasis[a][0]);

        fDet = -fDet;
    }

    fDet -= 1.0f;
    fDet *= fDet;

    if (0.0001f < fDet)
    {
        
        return false;
    }

    
    outRotQuat[0] = XMQuaternionRotationMatrix(matTemp);
    return true;
}










inline XMMATRIX __vectorcall XMMatrixIdentity() noexcept
{
    XMMATRIX M;
    M.r[0] = g_XMIdentityR0.v;
    M.r[1] = g_XMIdentityR1.v;
    M.r[2] = g_XMIdentityR2.v;
    M.r[3] = g_XMIdentityR3.v;
    return M;
}



inline XMMATRIX __vectorcall XMMatrixSet
(
    float m00, float m01, float m02, float m03,
    float m10, float m11, float m12, float m13,
    float m20, float m21, float m22, float m23,
    float m30, float m31, float m32, float m33
) noexcept
{
    XMMATRIX M;





#line 1244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    M.r[0] = XMVectorSet(m00, m01, m02, m03);
    M.r[1] = XMVectorSet(m10, m11, m12, m13);
    M.r[2] = XMVectorSet(m20, m21, m22, m23);
    M.r[3] = XMVectorSet(m30, m31, m32, m33);
#line 1249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    return M;
}



inline XMMATRIX __vectorcall XMMatrixTranslation
(
    float OffsetX,
    float OffsetY,
    float OffsetZ
) noexcept
{
























#line 1286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    M.r[0] = g_XMIdentityR0.v;
    M.r[1] = g_XMIdentityR1.v;
    M.r[2] = g_XMIdentityR2.v;
    M.r[3] = XMVectorSet(OffsetX, OffsetY, OffsetZ, 1.f);
    return M;
#line 1293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}




inline XMMATRIX __vectorcall XMMatrixTranslationFromVector(FXMVECTOR Offset) noexcept
{
























#line 1325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    M.r[0] = g_XMIdentityR0.v;
    M.r[1] = g_XMIdentityR1.v;
    M.r[2] = g_XMIdentityR2.v;
    M.r[3] = XMVectorSelect(g_XMIdentityR3.v, Offset, g_XMSelect1110.v);
    return M;
#line 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixScaling
(
    float ScaleX,
    float ScaleY,
    float ScaleZ
) noexcept
{
























#line 1368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"







#line 1376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    M.r[0] = _mm_set_ps(0, 0, 0, ScaleX);
    M.r[1] = _mm_set_ps(0, 0, ScaleY, 0);
    M.r[2] = _mm_set_ps(0, ScaleZ, 0, 0);
    M.r[3] = g_XMIdentityR3.v;
    return M;
#line 1383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixScalingFromVector(FXMVECTOR Scale) noexcept
{
























#line 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"






#line 1421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    M.r[0] = _mm_and_ps(Scale, g_XMMaskX);
    M.r[1] = _mm_and_ps(Scale, g_XMMaskY);
    M.r[2] = _mm_and_ps(Scale, g_XMMaskZ);
    M.r[3] = g_XMIdentityR3.v;
    return M;
#line 1428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixRotationX(float Angle) noexcept
{




























#line 1463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"


















#line 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    float    SinAngle;
    float    CosAngle;
    XMScalarSinCos(&SinAngle, &CosAngle, Angle);

    XMVECTOR vSin = _mm_set_ss(SinAngle);
    XMVECTOR vCos = _mm_set_ss(CosAngle);
    
    vCos = _mm_shuffle_ps(vCos, vSin, (((3) << 6) | ((0) << 4) | ((0) << 2) | ((3))));
    XMMATRIX M;
    M.r[0] = g_XMIdentityR0;
    M.r[1] = vCos;
    
    vCos = _mm_shuffle_ps((vCos), (vCos), (((3) << 6) | ((1) << 4) | ((2) << 2) | ((0))) );
    
    vCos = _mm_mul_ps(vCos, g_XMNegateY);
    M.r[2] = vCos;
    M.r[3] = g_XMIdentityR3;
    return M;
#line 1501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixRotationY(float Angle) noexcept
{




























#line 1536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"


















#line 1555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    float    SinAngle;
    float    CosAngle;
    XMScalarSinCos(&SinAngle, &CosAngle, Angle);

    XMVECTOR vSin = _mm_set_ss(SinAngle);
    XMVECTOR vCos = _mm_set_ss(CosAngle);
    
    vSin = _mm_shuffle_ps(vSin, vCos, (((3) << 6) | ((0) << 4) | ((3) << 2) | ((0))));
    XMMATRIX M;
    M.r[2] = vSin;
    M.r[1] = g_XMIdentityR1;
    
    vSin = _mm_shuffle_ps((vSin), (vSin), (((3) << 6) | ((0) << 4) | ((1) << 2) | ((2))) );
    
    vSin = _mm_mul_ps(vSin, g_XMNegateZ);
    M.r[0] = vSin;
    M.r[3] = g_XMIdentityR3;
    return M;
#line 1574 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixRotationZ(float Angle) noexcept
{




























#line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"


















#line 1628 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    float    SinAngle;
    float    CosAngle;
    XMScalarSinCos(&SinAngle, &CosAngle, Angle);

    XMVECTOR vSin = _mm_set_ss(SinAngle);
    XMVECTOR vCos = _mm_set_ss(CosAngle);
    
    vCos = _mm_unpacklo_ps(vCos, vSin);
    XMMATRIX M;
    M.r[0] = vCos;
    
    vCos = _mm_shuffle_ps((vCos), (vCos), (((3) << 6) | ((2) << 4) | ((0) << 2) | ((1))) );
    
    vCos = _mm_mul_ps(vCos, g_XMNegateX);
    M.r[1] = vCos;
    M.r[2] = g_XMIdentityR2;
    M.r[3] = g_XMIdentityR3;
    return M;
#line 1647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixRotationRollPitchYaw
(
    float Pitch,
    float Yaw,
    float Roll
) noexcept
{
    XMVECTOR Angles = XMVectorSet(Pitch, Yaw, Roll, 0.0f);
    return XMMatrixRotationRollPitchYawFromVector(Angles);
}



inline XMMATRIX __vectorcall XMMatrixRotationRollPitchYawFromVector
(
    FXMVECTOR Angles 
) noexcept
{
    XMVECTOR Q = XMQuaternionRotationRollPitchYawFromVector(Angles);
    return XMMatrixRotationQuaternion(Q);
}



inline XMMATRIX __vectorcall XMMatrixRotationNormal
(
    FXMVECTOR NormalAxis,
    float     Angle
) noexcept
{



































#line 1717 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    float    fSinAngle;
    float    fCosAngle;
    XMScalarSinCos(&fSinAngle, &fCosAngle, Angle);

    XMVECTOR C2 = _mm_set_ps1(1.0f - fCosAngle);
    XMVECTOR C1 = _mm_set_ps1(fCosAngle);
    XMVECTOR C0 = _mm_set_ps1(fSinAngle);

    XMVECTOR N0 = _mm_shuffle_ps((NormalAxis), (NormalAxis), (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    XMVECTOR N1 = _mm_shuffle_ps((NormalAxis), (NormalAxis), (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))) );

    XMVECTOR V0 = _mm_mul_ps(C2, N0);
    V0 = _mm_mul_ps(V0, N1);

    XMVECTOR R0 = _mm_mul_ps(C2, NormalAxis);
    R0 = _mm_mul_ps(R0, NormalAxis);
    R0 = _mm_add_ps(R0, C1);

    XMVECTOR R1 = _mm_mul_ps(C0, NormalAxis);
    R1 = _mm_add_ps(R1, V0);
    XMVECTOR R2 = _mm_mul_ps(C0, NormalAxis);
    R2 = _mm_sub_ps(V0, R2);

    V0 = _mm_and_ps(R0, g_XMMask3);
    XMVECTOR V1 = _mm_shuffle_ps(R1, R2, (((2) << 6) | ((1) << 4) | ((2) << 2) | ((0))));
    V1 = _mm_shuffle_ps((V1), (V1), (((0) << 6) | ((3) << 4) | ((2) << 2) | ((1))) );
    XMVECTOR V2 = _mm_shuffle_ps(R1, R2, (((0) << 6) | ((0) << 4) | ((1) << 2) | ((1))));
    V2 = _mm_shuffle_ps((V2), (V2), (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))) );

    R2 = _mm_shuffle_ps(V0, V1, (((1) << 6) | ((0) << 4) | ((3) << 2) | ((0))));
    R2 = _mm_shuffle_ps((R2), (R2), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((0))) );

    XMMATRIX M;
    M.r[0] = R2;

    R2 = _mm_shuffle_ps(V0, V1, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((1))));
    R2 = _mm_shuffle_ps((R2), (R2), (((1) << 6) | ((3) << 4) | ((0) << 2) | ((2))) );
    M.r[1] = R2;

    V2 = _mm_shuffle_ps(V2, V0, (((3) << 6) | ((2) << 4) | ((1) << 2) | ((0))));
    M.r[2] = V2;
    M.r[3] = g_XMIdentityR3.v;
    return M;
#line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixRotationAxis
(
    FXMVECTOR Axis,
    float     Angle
) noexcept
{
    (void)( (!!(!XMVector3Equal(Axis, XMVectorZero()))) || (_wassert(L"!XMVector3Equal(Axis, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(1771)), 0) );
    (void)( (!!(!XMVector3IsInfinite(Axis))) || (_wassert(L"!XMVector3IsInfinite(Axis)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(1772)), 0) );

    XMVECTOR Normal = XMVector3Normalize(Axis);
    return XMMatrixRotationNormal(Normal, Angle);
}



inline XMMATRIX __vectorcall XMMatrixRotationQuaternion(FXMVECTOR Quaternion) noexcept
{

































#line 1816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    static const XMVECTORF32  Constant1110 = { { { 1.0f, 1.0f, 1.0f, 0.0f } } };

    XMVECTOR Q0 = _mm_add_ps(Quaternion, Quaternion);
    XMVECTOR Q1 = _mm_mul_ps(Quaternion, Q0);

    XMVECTOR V0 = _mm_shuffle_ps((Q1), (Q1), (((3) << 6) | ((0) << 4) | ((0) << 2) | ((1))) );
    V0 = _mm_and_ps(V0, g_XMMask3);
    XMVECTOR V1 = _mm_shuffle_ps((Q1), (Q1), (((3) << 6) | ((1) << 4) | ((2) << 2) | ((2))) );
    V1 = _mm_and_ps(V1, g_XMMask3);
    XMVECTOR R0 = _mm_sub_ps(Constant1110, V0);
    R0 = _mm_sub_ps(R0, V1);

    V0 = _mm_shuffle_ps((Quaternion), (Quaternion), (((3) << 6) | ((1) << 4) | ((0) << 2) | ((0))) );
    V1 = _mm_shuffle_ps((Q0), (Q0), (((3) << 6) | ((2) << 4) | ((1) << 2) | ((2))) );
    V0 = _mm_mul_ps(V0, V1);

    V1 = _mm_shuffle_ps((Quaternion), (Quaternion), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    XMVECTOR V2 = _mm_shuffle_ps((Q0), (Q0), (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))) );
    V1 = _mm_mul_ps(V1, V2);

    XMVECTOR R1 = _mm_add_ps(V0, V1);
    XMVECTOR R2 = _mm_sub_ps(V0, V1);

    V0 = _mm_shuffle_ps(R1, R2, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
    V0 = _mm_shuffle_ps((V0), (V0), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((0))) );
    V1 = _mm_shuffle_ps(R1, R2, (((2) << 6) | ((2) << 4) | ((0) << 2) | ((0))));
    V1 = _mm_shuffle_ps((V1), (V1), (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))) );

    Q1 = _mm_shuffle_ps(R0, V0, (((1) << 6) | ((0) << 4) | ((3) << 2) | ((0))));
    Q1 = _mm_shuffle_ps((Q1), (Q1), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((0))) );

    XMMATRIX M;
    M.r[0] = Q1;

    Q1 = _mm_shuffle_ps(R0, V0, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((1))));
    Q1 = _mm_shuffle_ps((Q1), (Q1), (((1) << 6) | ((3) << 4) | ((0) << 2) | ((2))) );
    M.r[1] = Q1;

    Q1 = _mm_shuffle_ps(V1, R0, (((3) << 6) | ((2) << 4) | ((1) << 2) | ((0))));
    M.r[2] = Q1;
    M.r[3] = g_XMIdentityR3;
    return M;
#line 1859 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixTransformation2D
(
    FXMVECTOR ScalingOrigin,
    float     ScalingOrientation,
    FXMVECTOR Scaling,
    FXMVECTOR RotationOrigin,
    float     Rotation,
    GXMVECTOR Translation
) noexcept
{
    
    

    XMVECTOR VScalingOrigin = XMVectorSelect(g_XMSelect1100.v, ScalingOrigin, g_XMSelect1100.v);
    XMVECTOR NegScalingOrigin = XMVectorNegate(VScalingOrigin);

    XMMATRIX MScalingOriginI = XMMatrixTranslationFromVector(NegScalingOrigin);
    XMMATRIX MScalingOrientation = XMMatrixRotationZ(ScalingOrientation);
    XMMATRIX MScalingOrientationT = XMMatrixTranspose(MScalingOrientation);
    XMVECTOR VScaling = XMVectorSelect(g_XMOne.v, Scaling, g_XMSelect1100.v);
    XMMATRIX MScaling = XMMatrixScalingFromVector(VScaling);
    XMVECTOR VRotationOrigin = XMVectorSelect(g_XMSelect1100.v, RotationOrigin, g_XMSelect1100.v);
    XMMATRIX MRotation = XMMatrixRotationZ(Rotation);
    XMVECTOR VTranslation = XMVectorSelect(g_XMSelect1100.v, Translation, g_XMSelect1100.v);

    XMMATRIX M = XMMatrixMultiply(MScalingOriginI, MScalingOrientationT);
    M = XMMatrixMultiply(M, MScaling);
    M = XMMatrixMultiply(M, MScalingOrientation);
    M.r[3] = XMVectorAdd(M.r[3], VScalingOrigin);
    M.r[3] = XMVectorSubtract(M.r[3], VRotationOrigin);
    M = XMMatrixMultiply(M, MRotation);
    M.r[3] = XMVectorAdd(M.r[3], VRotationOrigin);
    M.r[3] = XMVectorAdd(M.r[3], VTranslation);

    return M;
}



inline XMMATRIX __vectorcall XMMatrixTransformation
(
    FXMVECTOR ScalingOrigin,
    FXMVECTOR ScalingOrientationQuaternion,
    FXMVECTOR Scaling,
    GXMVECTOR RotationOrigin,
    HXMVECTOR RotationQuaternion,
    HXMVECTOR Translation
) noexcept
{
    
    

    XMVECTOR VScalingOrigin = XMVectorSelect(g_XMSelect1110.v, ScalingOrigin, g_XMSelect1110.v);
    XMVECTOR NegScalingOrigin = XMVectorNegate(ScalingOrigin);

    XMMATRIX MScalingOriginI = XMMatrixTranslationFromVector(NegScalingOrigin);
    XMMATRIX MScalingOrientation = XMMatrixRotationQuaternion(ScalingOrientationQuaternion);
    XMMATRIX MScalingOrientationT = XMMatrixTranspose(MScalingOrientation);
    XMMATRIX MScaling = XMMatrixScalingFromVector(Scaling);
    XMVECTOR VRotationOrigin = XMVectorSelect(g_XMSelect1110.v, RotationOrigin, g_XMSelect1110.v);
    XMMATRIX MRotation = XMMatrixRotationQuaternion(RotationQuaternion);
    XMVECTOR VTranslation = XMVectorSelect(g_XMSelect1110.v, Translation, g_XMSelect1110.v);

    XMMATRIX M;
    M = XMMatrixMultiply(MScalingOriginI, MScalingOrientationT);
    M = XMMatrixMultiply(M, MScaling);
    M = XMMatrixMultiply(M, MScalingOrientation);
    M.r[3] = XMVectorAdd(M.r[3], VScalingOrigin);
    M.r[3] = XMVectorSubtract(M.r[3], VRotationOrigin);
    M = XMMatrixMultiply(M, MRotation);
    M.r[3] = XMVectorAdd(M.r[3], VRotationOrigin);
    M.r[3] = XMVectorAdd(M.r[3], VTranslation);
    return M;
}



inline XMMATRIX __vectorcall XMMatrixAffineTransformation2D
(
    FXMVECTOR Scaling,
    FXMVECTOR RotationOrigin,
    float     Rotation,
    FXMVECTOR Translation
) noexcept
{
    

    XMVECTOR VScaling = XMVectorSelect(g_XMOne.v, Scaling, g_XMSelect1100.v);
    XMMATRIX MScaling = XMMatrixScalingFromVector(VScaling);
    XMVECTOR VRotationOrigin = XMVectorSelect(g_XMSelect1100.v, RotationOrigin, g_XMSelect1100.v);
    XMMATRIX MRotation = XMMatrixRotationZ(Rotation);
    XMVECTOR VTranslation = XMVectorSelect(g_XMSelect1100.v, Translation, g_XMSelect1100.v);

    XMMATRIX M;
    M = MScaling;
    M.r[3] = XMVectorSubtract(M.r[3], VRotationOrigin);
    M = XMMatrixMultiply(M, MRotation);
    M.r[3] = XMVectorAdd(M.r[3], VRotationOrigin);
    M.r[3] = XMVectorAdd(M.r[3], VTranslation);
    return M;
}



inline XMMATRIX __vectorcall XMMatrixAffineTransformation
(
    FXMVECTOR Scaling,
    FXMVECTOR RotationOrigin,
    FXMVECTOR RotationQuaternion,
    GXMVECTOR Translation
) noexcept
{
    

    XMMATRIX MScaling = XMMatrixScalingFromVector(Scaling);
    XMVECTOR VRotationOrigin = XMVectorSelect(g_XMSelect1110.v, RotationOrigin, g_XMSelect1110.v);
    XMMATRIX MRotation = XMMatrixRotationQuaternion(RotationQuaternion);
    XMVECTOR VTranslation = XMVectorSelect(g_XMSelect1110.v, Translation, g_XMSelect1110.v);

    XMMATRIX M;
    M = MScaling;
    M.r[3] = XMVectorSubtract(M.r[3], VRotationOrigin);
    M = XMMatrixMultiply(M, MRotation);
    M.r[3] = XMVectorAdd(M.r[3], VRotationOrigin);
    M.r[3] = XMVectorAdd(M.r[3], VTranslation);
    return M;
}



inline XMMATRIX __vectorcall XMMatrixReflect(FXMVECTOR ReflectionPlane) noexcept
{
    (void)( (!!(!XMVector3Equal(ReflectionPlane, XMVectorZero()))) || (_wassert(L"!XMVector3Equal(ReflectionPlane, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(1995)), 0) );
    (void)( (!!(!XMPlaneIsInfinite(ReflectionPlane))) || (_wassert(L"!XMPlaneIsInfinite(ReflectionPlane)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(1996)), 0) );

    static const XMVECTORF32 NegativeTwo = { { { -2.0f, -2.0f, -2.0f, 0.0f } } };

    XMVECTOR P = XMPlaneNormalize(ReflectionPlane);
    XMVECTOR S = XMVectorMultiply(P, NegativeTwo);

    XMVECTOR A = XMVectorSplatX(P);
    XMVECTOR B = XMVectorSplatY(P);
    XMVECTOR C = XMVectorSplatZ(P);
    XMVECTOR D = XMVectorSplatW(P);

    XMMATRIX M;
    M.r[0] = XMVectorMultiplyAdd(A, S, g_XMIdentityR0.v);
    M.r[1] = XMVectorMultiplyAdd(B, S, g_XMIdentityR1.v);
    M.r[2] = XMVectorMultiplyAdd(C, S, g_XMIdentityR2.v);
    M.r[3] = XMVectorMultiplyAdd(D, S, g_XMIdentityR3.v);
    return M;
}



inline XMMATRIX __vectorcall XMMatrixShadow
(
    FXMVECTOR ShadowPlane,
    FXMVECTOR LightPosition
) noexcept
{
    static const XMVECTORU32 Select0001 = { { { XM_SELECT_0, XM_SELECT_0, XM_SELECT_0, XM_SELECT_1 } } };

    (void)( (!!(!XMVector3Equal(ShadowPlane, XMVectorZero()))) || (_wassert(L"!XMVector3Equal(ShadowPlane, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2026)), 0) );
    (void)( (!!(!XMPlaneIsInfinite(ShadowPlane))) || (_wassert(L"!XMPlaneIsInfinite(ShadowPlane)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2027)), 0) );

    XMVECTOR P = XMPlaneNormalize(ShadowPlane);
    XMVECTOR Dot = XMPlaneDot(P, LightPosition);
    P = XMVectorNegate(P);
    XMVECTOR D = XMVectorSplatW(P);
    XMVECTOR C = XMVectorSplatZ(P);
    XMVECTOR B = XMVectorSplatY(P);
    XMVECTOR A = XMVectorSplatX(P);
    Dot = XMVectorSelect(Select0001.v, Dot, Select0001.v);

    XMMATRIX M;
    M.r[3] = XMVectorMultiplyAdd(D, LightPosition, Dot);
    Dot = XMVectorRotateLeft(Dot, 1);
    M.r[2] = XMVectorMultiplyAdd(C, LightPosition, Dot);
    Dot = XMVectorRotateLeft(Dot, 1);
    M.r[1] = XMVectorMultiplyAdd(B, LightPosition, Dot);
    Dot = XMVectorRotateLeft(Dot, 1);
    M.r[0] = XMVectorMultiplyAdd(A, LightPosition, Dot);
    return M;
}





inline XMMATRIX __vectorcall XMMatrixLookAtLH
(
    FXMVECTOR EyePosition,
    FXMVECTOR FocusPosition,
    FXMVECTOR UpDirection
) noexcept
{
    XMVECTOR EyeDirection = XMVectorSubtract(FocusPosition, EyePosition);
    return XMMatrixLookToLH(EyePosition, EyeDirection, UpDirection);
}



inline XMMATRIX __vectorcall XMMatrixLookAtRH
(
    FXMVECTOR EyePosition,
    FXMVECTOR FocusPosition,
    FXMVECTOR UpDirection
) noexcept
{
    XMVECTOR NegEyeDirection = XMVectorSubtract(EyePosition, FocusPosition);
    return XMMatrixLookToLH(EyePosition, NegEyeDirection, UpDirection);
}



inline XMMATRIX __vectorcall XMMatrixLookToLH
(
    FXMVECTOR EyePosition,
    FXMVECTOR EyeDirection,
    FXMVECTOR UpDirection
) noexcept
{
    (void)( (!!(!XMVector3Equal(EyeDirection, XMVectorZero()))) || (_wassert(L"!XMVector3Equal(EyeDirection, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2086)), 0) );
    (void)( (!!(!XMVector3IsInfinite(EyeDirection))) || (_wassert(L"!XMVector3IsInfinite(EyeDirection)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2087)), 0) );
    (void)( (!!(!XMVector3Equal(UpDirection, XMVectorZero()))) || (_wassert(L"!XMVector3Equal(UpDirection, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2088)), 0) );
    (void)( (!!(!XMVector3IsInfinite(UpDirection))) || (_wassert(L"!XMVector3IsInfinite(UpDirection)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2089)), 0) );

    XMVECTOR R2 = XMVector3Normalize(EyeDirection);

    XMVECTOR R0 = XMVector3Cross(UpDirection, R2);
    R0 = XMVector3Normalize(R0);

    XMVECTOR R1 = XMVector3Cross(R2, R0);

    XMVECTOR NegEyePosition = XMVectorNegate(EyePosition);

    XMVECTOR D0 = XMVector3Dot(R0, NegEyePosition);
    XMVECTOR D1 = XMVector3Dot(R1, NegEyePosition);
    XMVECTOR D2 = XMVector3Dot(R2, NegEyePosition);

    XMMATRIX M;
    M.r[0] = XMVectorSelect(D0, R0, g_XMSelect1110.v);
    M.r[1] = XMVectorSelect(D1, R1, g_XMSelect1110.v);
    M.r[2] = XMVectorSelect(D2, R2, g_XMSelect1110.v);
    M.r[3] = g_XMIdentityR3.v;

    M = XMMatrixTranspose(M);

    return M;
}



inline XMMATRIX __vectorcall XMMatrixLookToRH
(
    FXMVECTOR EyePosition,
    FXMVECTOR EyeDirection,
    FXMVECTOR UpDirection
) noexcept
{
    XMVECTOR NegEyeDirection = XMVectorNegate(EyeDirection);
    return XMMatrixLookToLH(EyePosition, NegEyeDirection, UpDirection);
}








inline XMMATRIX __vectorcall XMMatrixPerspectiveLH
(
    float ViewWidth,
    float ViewHeight,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(NearZ > 0.f && FarZ > 0.f)) || (_wassert(L"NearZ > 0.f && FarZ > 0.f", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2143)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2144)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2145)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2146)), 0) );




























#line 2176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"









#line 2186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float TwoNearZ = NearZ + NearZ;
    float fRange = FarZ / (FarZ - NearZ);
    
    XMVECTOR rMem = {
        TwoNearZ / ViewWidth,
        TwoNearZ / ViewHeight,
        fRange,
        -fRange * NearZ
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    vValues = _mm_shuffle_ps(vValues, g_XMIdentityR3, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    vTemp = _mm_setzero_ps();
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((3) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
    M.r[2] = vTemp;
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
    M.r[3] = vTemp;
    return M;
#line 2218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixPerspectiveRH
(
    float ViewWidth,
    float ViewHeight,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(NearZ > 0.f && FarZ > 0.f)) || (_wassert(L"NearZ > 0.f && FarZ > 0.f", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2230)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2231)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2232)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2233)), 0) );




























#line 2263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"










#line 2274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float TwoNearZ = NearZ + NearZ;
    float fRange = FarZ / (NearZ - FarZ);
    
    XMVECTOR rMem = {
        TwoNearZ / ViewWidth,
        TwoNearZ / ViewHeight,
        fRange,
        fRange * NearZ
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    vValues = _mm_shuffle_ps(vValues, g_XMNegIdentityR3, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    vTemp = _mm_setzero_ps();
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((3) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
    M.r[2] = vTemp;
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
    M.r[3] = vTemp;
    return M;
#line 2306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixPerspectiveFovLH
(
    float FovAngleY,
    float AspectRatio,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(NearZ > 0.f && FarZ > 0.f)) || (_wassert(L"NearZ > 0.f && FarZ > 0.f", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2318)), 0) );
    (void)( (!!(!XMScalarNearEqual(FovAngleY, 0.0f, 0.00001f * 2.0f))) || (_wassert(L"!XMScalarNearEqual(FovAngleY, 0.0f, 0.00001f * 2.0f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2319)), 0) );
    (void)( (!!(!XMScalarNearEqual(AspectRatio, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(AspectRatio, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2320)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2321)), 0) );

































#line 2356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"















#line 2372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    float    SinFov;
    float    CosFov;
    XMScalarSinCos(&SinFov, &CosFov, 0.5f * FovAngleY);

    float fRange = FarZ / (FarZ - NearZ);
    
    float Height = CosFov / SinFov;
    XMVECTOR rMem = {
        Height / AspectRatio,
        Height,
        fRange,
        -fRange * NearZ
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    XMMATRIX M;
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    vTemp = _mm_setzero_ps();
    vValues = _mm_shuffle_ps(vValues, g_XMIdentityR3, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((3) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
    M.r[2] = vTemp;
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
    M.r[3] = vTemp;
    return M;
#line 2408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixPerspectiveFovRH
(
    float FovAngleY,
    float AspectRatio,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(NearZ > 0.f && FarZ > 0.f)) || (_wassert(L"NearZ > 0.f && FarZ > 0.f", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2420)), 0) );
    (void)( (!!(!XMScalarNearEqual(FovAngleY, 0.0f, 0.00001f * 2.0f))) || (_wassert(L"!XMScalarNearEqual(FovAngleY, 0.0f, 0.00001f * 2.0f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2421)), 0) );
    (void)( (!!(!XMScalarNearEqual(AspectRatio, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(AspectRatio, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2422)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2423)), 0) );

































#line 2458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"














#line 2473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    float    SinFov;
    float    CosFov;
    XMScalarSinCos(&SinFov, &CosFov, 0.5f * FovAngleY);
    float fRange = FarZ / (NearZ - FarZ);
    
    float Height = CosFov / SinFov;
    XMVECTOR rMem = {
        Height / AspectRatio,
        Height,
        fRange,
        fRange * NearZ
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    XMMATRIX M;
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    vTemp = _mm_setzero_ps();
    vValues = _mm_shuffle_ps(vValues, g_XMNegIdentityR3, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((3) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
    M.r[2] = vTemp;
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
    M.r[3] = vTemp;
    return M;
#line 2508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixPerspectiveOffCenterLH
(
    float ViewLeft,
    float ViewRight,
    float ViewBottom,
    float ViewTop,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(NearZ > 0.f && FarZ > 0.f)) || (_wassert(L"NearZ > 0.f && FarZ > 0.f", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2522)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2523)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2524)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2525)), 0) );






























#line 2557 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"















#line 2573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float TwoNearZ = NearZ + NearZ;
    float ReciprocalWidth = 1.0f / (ViewRight - ViewLeft);
    float ReciprocalHeight = 1.0f / (ViewTop - ViewBottom);
    float fRange = FarZ / (FarZ - NearZ);
    
    XMVECTOR rMem = {
        TwoNearZ * ReciprocalWidth,
        TwoNearZ * ReciprocalHeight,
        -fRange * NearZ,
        0
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    M.r[2] = XMVectorSet(-(ViewLeft + ViewRight) * ReciprocalWidth,
        -(ViewTop + ViewBottom) * ReciprocalHeight,
        fRange,
        1.0f);
    
    vValues = _mm_and_ps(vValues, g_XMMaskZ);
    M.r[3] = vValues;
    return M;
#line 2606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixPerspectiveOffCenterRH
(
    float ViewLeft,
    float ViewRight,
    float ViewBottom,
    float ViewTop,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(NearZ > 0.f && FarZ > 0.f)) || (_wassert(L"NearZ > 0.f && FarZ > 0.f", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2620)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2621)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2622)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2623)), 0) );






























#line 2655 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"















#line 2671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float TwoNearZ = NearZ + NearZ;
    float ReciprocalWidth = 1.0f / (ViewRight - ViewLeft);
    float ReciprocalHeight = 1.0f / (ViewTop - ViewBottom);
    float fRange = FarZ / (NearZ - FarZ);
    
    XMVECTOR rMem = {
        TwoNearZ * ReciprocalWidth,
        TwoNearZ * ReciprocalHeight,
        fRange * NearZ,
        0
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    M.r[2] = XMVectorSet((ViewLeft + ViewRight) * ReciprocalWidth,
        (ViewTop + ViewBottom) * ReciprocalHeight,
        fRange,
        -1.0f);
    
    vValues = _mm_and_ps(vValues, g_XMMaskZ);
    M.r[3] = vValues;
    return M;
#line 2704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixOrthographicLH
(
    float ViewWidth,
    float ViewHeight,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2716)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2717)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2718)), 0) );



























#line 2747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"









#line 2757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float fRange = 1.0f / (FarZ - NearZ);
    
    XMVECTOR rMem = {
        2.0f / ViewWidth,
        2.0f / ViewHeight,
        fRange,
        -fRange * NearZ
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    vTemp = _mm_setzero_ps();
    vValues = _mm_shuffle_ps(vValues, g_XMIdentityR3, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
    M.r[2] = vTemp;
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
    M.r[3] = vTemp;
    return M;
#line 2788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixOrthographicRH
(
    float ViewWidth,
    float ViewHeight,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewWidth, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2800)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewHeight, 0.0f, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2801)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2802)), 0) );



























#line 2831 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"









#line 2841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float fRange = 1.0f / (NearZ - FarZ);
    
    XMVECTOR rMem = {
        2.0f / ViewWidth,
        2.0f / ViewHeight,
        fRange,
        fRange * NearZ
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    M.r[1] = vTemp;
    
    vTemp = _mm_setzero_ps();
    vValues = _mm_shuffle_ps(vValues, g_XMIdentityR3, (((3) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
    M.r[2] = vTemp;
    
    vTemp = _mm_shuffle_ps(vTemp, vValues, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
    M.r[3] = vTemp;
    return M;
#line 2872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixOrthographicOffCenterLH
(
    float ViewLeft,
    float ViewRight,
    float ViewBottom,
    float ViewTop,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2886)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2887)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2888)), 0) );





























#line 2919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"













#line 2933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float fReciprocalWidth = 1.0f / (ViewRight - ViewLeft);
    float fReciprocalHeight = 1.0f / (ViewTop - ViewBottom);
    float fRange = 1.0f / (FarZ - NearZ);
    
    XMVECTOR rMem = {
        fReciprocalWidth,
        fReciprocalHeight,
        fRange,
        1.0f
    };
    XMVECTOR rMem2 = {
        -(ViewLeft + ViewRight),
        -(ViewTop + ViewBottom),
        -NearZ,
        1.0f
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    vTemp = _mm_add_ss(vTemp, vTemp);
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    vTemp = _mm_add_ps(vTemp, vTemp);
    M.r[1] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskZ);
    M.r[2] = vTemp;
    
    vValues = _mm_mul_ps(vValues, rMem2);
    M.r[3] = vValues;
    return M;
#line 2972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMatrixOrthographicOffCenterRH
(
    float ViewLeft,
    float ViewRight,
    float ViewBottom,
    float ViewTop,
    float NearZ,
    float FarZ
) noexcept
{
    (void)( (!!(!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewRight, ViewLeft, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2986)), 0) );
    (void)( (!!(!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(ViewTop, ViewBottom, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2987)), 0) );
    (void)( (!!(!XMScalarNearEqual(FarZ, NearZ, 0.00001f))) || (_wassert(L"!XMScalarNearEqual(FarZ, NearZ, 0.00001f)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(2988)), 0) );





























#line 3019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"













#line 3033 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    XMMATRIX M;
    float fReciprocalWidth = 1.0f / (ViewRight - ViewLeft);
    float fReciprocalHeight = 1.0f / (ViewTop - ViewBottom);
    float fRange = 1.0f / (NearZ - FarZ);
    
    XMVECTOR rMem = {
        fReciprocalWidth,
        fReciprocalHeight,
        fRange,
        1.0f
    };
    XMVECTOR rMem2 = {
        -(ViewLeft + ViewRight),
        -(ViewTop + ViewBottom),
        NearZ,
        1.0f
    };
    
    XMVECTOR vValues = rMem;
    XMVECTOR vTemp = _mm_setzero_ps();
    
    vTemp = _mm_move_ss(vTemp, vValues);
    
    vTemp = _mm_add_ss(vTemp, vTemp);
    M.r[0] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskY);
    vTemp = _mm_add_ps(vTemp, vTemp);
    M.r[1] = vTemp;
    
    vTemp = vValues;
    vTemp = _mm_and_ps(vTemp, g_XMMaskZ);
    M.r[2] = vTemp;
    
    vValues = _mm_mul_ps(vValues, rMem2);
    M.r[3] = vValues;
    return M;
#line 3072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}











 

inline XMMATRIX::XMMATRIX
(
    float m00, float m01, float m02, float m03,
    float m10, float m11, float m12, float m13,
    float m20, float m21, float m22, float m23,
    float m30, float m31, float m32, float m33
) noexcept
{
    r[0] = XMVectorSet(m00, m01, m02, m03);
    r[1] = XMVectorSet(m10, m11, m12, m13);
    r[2] = XMVectorSet(m20, m21, m22, m23);
    r[3] = XMVectorSet(m30, m31, m32, m33);
}



inline XMMATRIX::XMMATRIX(const float* pArray) noexcept
{
    (void)( (!!(pArray != nullptr)) || (_wassert(L"pArray != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(3104)), 0) );
    r[0] = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(pArray));
    r[1] = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(pArray + 4));
    r[2] = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(pArray + 8));
    r[3] = XMLoadFloat4(reinterpret_cast<const XMFLOAT4*>(pArray + 12));
}



inline XMMATRIX XMMATRIX::operator- () const noexcept
{
    XMMATRIX R;
    R.r[0] = XMVectorNegate(r[0]);
    R.r[1] = XMVectorNegate(r[1]);
    R.r[2] = XMVectorNegate(r[2]);
    R.r[3] = XMVectorNegate(r[3]);
    return R;
}



inline XMMATRIX& __vectorcall XMMATRIX::operator+= (FXMMATRIX M) noexcept
{
    r[0] = XMVectorAdd(r[0], M.r[0]);
    r[1] = XMVectorAdd(r[1], M.r[1]);
    r[2] = XMVectorAdd(r[2], M.r[2]);
    r[3] = XMVectorAdd(r[3], M.r[3]);
    return *this;
}



inline XMMATRIX& __vectorcall XMMATRIX::operator-= (FXMMATRIX M) noexcept
{
    r[0] = XMVectorSubtract(r[0], M.r[0]);
    r[1] = XMVectorSubtract(r[1], M.r[1]);
    r[2] = XMVectorSubtract(r[2], M.r[2]);
    r[3] = XMVectorSubtract(r[3], M.r[3]);
    return *this;
}



inline XMMATRIX& __vectorcall XMMATRIX::operator*=(FXMMATRIX M) noexcept
{
    *this = XMMatrixMultiply(*this, M);
    return *this;
}



inline XMMATRIX& XMMATRIX::operator*= (float S) noexcept
{
    r[0] = XMVectorScale(r[0], S);
    r[1] = XMVectorScale(r[1], S);
    r[2] = XMVectorScale(r[2], S);
    r[3] = XMVectorScale(r[3], S);
    return *this;
}



inline XMMATRIX& XMMATRIX::operator/= (float S) noexcept
{







#line 3176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"





















#line 3198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    __m128 vS = _mm_set_ps1(S);
    r[0] = _mm_div_ps(r[0], vS);
    r[1] = _mm_div_ps(r[1], vS);
    r[2] = _mm_div_ps(r[2], vS);
    r[3] = _mm_div_ps(r[3], vS);
    return *this;
#line 3205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall XMMATRIX::operator+ (FXMMATRIX M) const noexcept
{
    XMMATRIX R;
    R.r[0] = XMVectorAdd(r[0], M.r[0]);
    R.r[1] = XMVectorAdd(r[1], M.r[1]);
    R.r[2] = XMVectorAdd(r[2], M.r[2]);
    R.r[3] = XMVectorAdd(r[3], M.r[3]);
    return R;
}



inline XMMATRIX __vectorcall XMMATRIX::operator- (FXMMATRIX M) const noexcept
{
    XMMATRIX R;
    R.r[0] = XMVectorSubtract(r[0], M.r[0]);
    R.r[1] = XMVectorSubtract(r[1], M.r[1]);
    R.r[2] = XMVectorSubtract(r[2], M.r[2]);
    R.r[3] = XMVectorSubtract(r[3], M.r[3]);
    return R;
}



inline XMMATRIX __vectorcall XMMATRIX::operator*(FXMMATRIX M) const noexcept
{
    return XMMatrixMultiply(*this, M);
}



inline XMMATRIX XMMATRIX::operator* (float S) const noexcept
{
    XMMATRIX R;
    R.r[0] = XMVectorScale(r[0], S);
    R.r[1] = XMVectorScale(r[1], S);
    R.r[2] = XMVectorScale(r[2], S);
    R.r[3] = XMVectorScale(r[3], S);
    return R;
}



inline XMMATRIX XMMATRIX::operator/ (float S) const noexcept
{








#line 3263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"























#line 3287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
    __m128 vS = _mm_set_ps1(S);
    XMMATRIX R;
    R.r[0] = _mm_div_ps(r[0], vS);
    R.r[1] = _mm_div_ps(r[1], vS);
    R.r[2] = _mm_div_ps(r[2], vS);
    R.r[3] = _mm_div_ps(r[3], vS);
    return R;
#line 3295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl"
}



inline XMMATRIX __vectorcall operator*
(
    float S,
    FXMMATRIX M
) noexcept
{
    XMMATRIX R;
    R.r[0] = XMVectorScale(M.r[0], S);
    R.r[1] = XMVectorScale(M.r[1], S);
    R.r[2] = XMVectorScale(M.r[2], S);
    R.r[3] = XMVectorScale(M.r[3], S);
    return R;
}







 

inline XMFLOAT3X3::XMFLOAT3X3(const float* pArray) noexcept
{
    (void)( (!!(pArray != nullptr)) || (_wassert(L"pArray != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(3323)), 0) );
    for (size_t Row = 0; Row < 3; Row++)
    {
        for (size_t Column = 0; Column < 3; Column++)
        {
            m[Row][Column] = pArray[Row * 3 + Column];
        }
    }
}







 

inline XMFLOAT4X3::XMFLOAT4X3(const float* pArray) noexcept
{
    (void)( (!!(pArray != nullptr)) || (_wassert(L"pArray != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(3343)), 0) );

    m[0][0] = pArray[0];
    m[0][1] = pArray[1];
    m[0][2] = pArray[2];

    m[1][0] = pArray[3];
    m[1][1] = pArray[4];
    m[1][2] = pArray[5];

    m[2][0] = pArray[6];
    m[2][1] = pArray[7];
    m[2][2] = pArray[8];

    m[3][0] = pArray[9];
    m[3][1] = pArray[10];
    m[3][2] = pArray[11];
}









inline XMFLOAT3X4::XMFLOAT3X4(const float* pArray) noexcept
{
    (void)( (!!(pArray != nullptr)) || (_wassert(L"pArray != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(3372)), 0) );

    m[0][0] = pArray[0];
    m[0][1] = pArray[1];
    m[0][2] = pArray[2];
    m[0][3] = pArray[3];

    m[1][0] = pArray[4];
    m[1][1] = pArray[5];
    m[1][2] = pArray[6];
    m[1][3] = pArray[7];

    m[2][0] = pArray[8];
    m[2][1] = pArray[9];
    m[2][2] = pArray[10];
    m[2][3] = pArray[11];
}







 

inline XMFLOAT4X4::XMFLOAT4X4(const float* pArray) noexcept
{
    (void)( (!!(pArray != nullptr)) || (_wassert(L"pArray != nullptr", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMatrix.inl", (unsigned)(3400)), 0) );

    m[0][0] = pArray[0];
    m[0][1] = pArray[1];
    m[0][2] = pArray[2];
    m[0][3] = pArray[3];

    m[1][0] = pArray[4];
    m[1][1] = pArray[5];
    m[1][2] = pArray[6];
    m[1][3] = pArray[7];

    m[2][0] = pArray[8];
    m[2][1] = pArray[9];
    m[2][2] = pArray[10];
    m[2][3] = pArray[11];

    m[3][0] = pArray[12];
    m[3][1] = pArray[13];
    m[3][2] = pArray[14];
    m[3][3] = pArray[15];
}

#pragma external_header(pop)
#line 2226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"









#pragma once







 
 
 

 

inline bool __vectorcall XMQuaternionEqual
(
    FXMVECTOR Q1,
    FXMVECTOR Q2
) noexcept
{
    return XMVector4Equal(Q1, Q2);
}



inline bool __vectorcall XMQuaternionNotEqual
(
    FXMVECTOR Q1,
    FXMVECTOR Q2
) noexcept
{
    return XMVector4NotEqual(Q1, Q2);
}



inline bool __vectorcall XMQuaternionIsNaN(FXMVECTOR Q) noexcept
{
    return XMVector4IsNaN(Q);
}



inline bool __vectorcall XMQuaternionIsInfinite(FXMVECTOR Q) noexcept
{
    return XMVector4IsInfinite(Q);
}



inline bool __vectorcall XMQuaternionIsIdentity(FXMVECTOR Q) noexcept
{
    return XMVector4Equal(Q, g_XMIdentityR3.v);
}







inline XMVECTOR __vectorcall XMQuaternionDot
(
    FXMVECTOR Q1,
    FXMVECTOR Q2
) noexcept
{
    return XMVector4Dot(Q1, Q2);
}



inline XMVECTOR __vectorcall XMQuaternionMultiply
(
    FXMVECTOR Q1,
    FXMVECTOR Q2
) noexcept
{
    

    
    
    
    









#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"





























#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    static const XMVECTORF32 ControlWZYX = { { { 1.0f, -1.0f, 1.0f, -1.0f } } };
    static const XMVECTORF32 ControlZWXY = { { { 1.0f, 1.0f, -1.0f, -1.0f } } };
    static const XMVECTORF32 ControlYXWZ = { { { -1.0f, 1.0f, 1.0f, -1.0f } } };
    
    XMVECTOR Q2X = Q2;
    XMVECTOR Q2Y = Q2;
    XMVECTOR Q2Z = Q2;
    XMVECTOR vResult = Q2;
    
    vResult = _mm_shuffle_ps((vResult), (vResult), (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))) );
    Q2X = _mm_shuffle_ps((Q2X), (Q2X), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    Q2Y = _mm_shuffle_ps((Q2Y), (Q2Y), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    Q2Z = _mm_shuffle_ps((Q2Z), (Q2Z), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );
    
    vResult = _mm_mul_ps(vResult, Q1);
    XMVECTOR Q1Shuffle = Q1;
    
    Q1Shuffle = _mm_shuffle_ps((Q1Shuffle), (Q1Shuffle), (((0) << 6) | ((1) << 4) | ((2) << 2) | ((3))) );
    
    Q2X = _mm_mul_ps(Q2X, Q1Shuffle);
    Q1Shuffle = _mm_shuffle_ps((Q1Shuffle), (Q1Shuffle), (((2) << 6) | ((3) << 4) | ((0) << 2) | ((1))) );
    
    vResult = _mm_add_ps(_mm_mul_ps((Q2X), (ControlWZYX)), (vResult));
    
    Q2Y = _mm_mul_ps(Q2Y, Q1Shuffle);
    Q1Shuffle = _mm_shuffle_ps((Q1Shuffle), (Q1Shuffle), (((0) << 6) | ((1) << 4) | ((2) << 2) | ((3))) );
    
    Q2Y = _mm_mul_ps(Q2Y, ControlZWXY);
    
    Q2Z = _mm_mul_ps(Q2Z, Q1Shuffle);
    
    Q2Y = _mm_add_ps(_mm_mul_ps((Q2Z), (ControlYXWZ)), (Q2Y));
    vResult = _mm_add_ps(vResult, Q2Y);
    return vResult;
#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMQuaternionLengthSq(FXMVECTOR Q) noexcept
{
    return XMVector4LengthSq(Q);
}



inline XMVECTOR __vectorcall XMQuaternionReciprocalLength(FXMVECTOR Q) noexcept
{
    return XMVector4ReciprocalLength(Q);
}



inline XMVECTOR __vectorcall XMQuaternionLength(FXMVECTOR Q) noexcept
{
    return XMVector4Length(Q);
}



inline XMVECTOR __vectorcall XMQuaternionNormalizeEst(FXMVECTOR Q) noexcept
{
    return XMVector4NormalizeEst(Q);
}



inline XMVECTOR __vectorcall XMQuaternionNormalize(FXMVECTOR Q) noexcept
{
    return XMVector4Normalize(Q);
}



inline XMVECTOR __vectorcall XMQuaternionConjugate(FXMVECTOR Q) noexcept
{








#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 222 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    static const XMVECTORF32 NegativeOne3 = { { { -1.0f, -1.0f, -1.0f, 1.0f } } };
    return _mm_mul_ps(Q, NegativeOne3);
#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMQuaternionInverse(FXMVECTOR Q) noexcept
{
    const XMVECTOR  Zero = XMVectorZero();

    XMVECTOR L = XMVector4LengthSq(Q);
    XMVECTOR Conjugate = XMQuaternionConjugate(Q);

    XMVECTOR Control = XMVectorLessOrEqual(L, g_XMEpsilon.v);

    XMVECTOR Result = XMVectorDivide(Conjugate, L);

    Result = XMVectorSelect(Result, Zero, Control);

    return Result;
}



inline XMVECTOR __vectorcall XMQuaternionLn(FXMVECTOR Q) noexcept
{
    static const XMVECTORF32 OneMinusEpsilon = { { { 1.0f - 0.00001f, 1.0f - 0.00001f, 1.0f - 0.00001f, 1.0f - 0.00001f } } };

    XMVECTOR QW = XMVectorSplatW(Q);
    XMVECTOR Q0 = XMVectorSelect(g_XMSelect1110.v, Q, g_XMSelect1110.v);

    XMVECTOR ControlW = XMVectorInBounds(QW, OneMinusEpsilon.v);

    XMVECTOR Theta = XMVectorACos(QW);
    XMVECTOR SinTheta = XMVectorSin(Theta);

    XMVECTOR S = XMVectorDivide(Theta, SinTheta);

    XMVECTOR Result = XMVectorMultiply(Q0, S);
    Result = XMVectorSelect(Q0, Result, ControlW);

    return Result;
}



inline XMVECTOR __vectorcall XMQuaternionExp(FXMVECTOR Q) noexcept
{
    XMVECTOR Theta = XMVector3Length(Q);

    XMVECTOR SinTheta, CosTheta;
    XMVectorSinCos(&SinTheta, &CosTheta, Theta);

    XMVECTOR S = XMVectorDivide(SinTheta, Theta);

    XMVECTOR Result = XMVectorMultiply(Q, S);

    const XMVECTOR Zero = XMVectorZero();
    XMVECTOR Control = XMVectorNearEqual(Theta, Zero, g_XMEpsilon.v);
    Result = XMVectorSelect(Result, Q, Control);

    Result = XMVectorSelect(CosTheta, Result, g_XMSelect1110.v);

    return Result;
}



inline XMVECTOR __vectorcall XMQuaternionSlerp
(
    FXMVECTOR Q0,
    FXMVECTOR Q1,
    float    t
) noexcept
{
    XMVECTOR T = XMVectorReplicate(t);
    return XMQuaternionSlerpV(Q0, Q1, T);
}



inline XMVECTOR __vectorcall XMQuaternionSlerpV
(
    FXMVECTOR Q0,
    FXMVECTOR Q1,
    FXMVECTOR T
) noexcept
{
    (void)( (!!((XMVectorGetY(T) == XMVectorGetX(T)) && (XMVectorGetZ(T) == XMVectorGetX(T)) && (XMVectorGetW(T) == XMVectorGetX(T)))) || (_wassert(L"(XMVectorGetY(T) == XMVectorGetX(T)) && (XMVectorGetZ(T) == XMVectorGetX(T)) && (XMVectorGetW(T) == XMVectorGetX(T))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(311)), 0) );

    












































#line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    static const XMVECTORF32 OneMinusEpsilon = { { { 1.0f - 0.00001f, 1.0f - 0.00001f, 1.0f - 0.00001f, 1.0f - 0.00001f } } };
    static const XMVECTORU32 SignMask2 = { { { 0x80000000, 0x00000000, 0x00000000, 0x00000000 } } };

    XMVECTOR CosOmega = XMQuaternionDot(Q0, Q1);

    const XMVECTOR Zero = XMVectorZero();
    XMVECTOR Control = XMVectorLess(CosOmega, Zero);
    XMVECTOR Sign = XMVectorSelect(g_XMOne, g_XMNegativeOne, Control);

    CosOmega = _mm_mul_ps(CosOmega, Sign);

    Control = XMVectorLess(CosOmega, OneMinusEpsilon);

    XMVECTOR SinOmega = _mm_mul_ps(CosOmega, CosOmega);
    SinOmega = _mm_sub_ps(g_XMOne, SinOmega);
    SinOmega = _mm_sqrt_ps(SinOmega);

    XMVECTOR Omega = XMVectorATan2(SinOmega, CosOmega);

    XMVECTOR V01 = _mm_shuffle_ps((T), (T), (((2) << 6) | ((3) << 4) | ((0) << 2) | ((1))) );
    V01 = _mm_and_ps(V01, g_XMMaskXY);
    V01 = _mm_xor_ps(V01, SignMask2);
    V01 = _mm_add_ps(g_XMIdentityR0, V01);

    XMVECTOR S0 = _mm_mul_ps(V01, Omega);
    S0 = XMVectorSin(S0);
    S0 = _mm_div_ps(S0, SinOmega);

    S0 = XMVectorSelect(V01, S0, Control);

    XMVECTOR S1 = XMVectorSplatY(S0);
    S0 = XMVectorSplatX(S0);

    S1 = _mm_mul_ps(S1, Sign);
    XMVECTOR Result = _mm_mul_ps(Q0, S0);
    S1 = _mm_mul_ps(S1, Q1);
    Result = _mm_add_ps(Result, S1);
    return Result;
#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMQuaternionSquad
(
    FXMVECTOR Q0,
    FXMVECTOR Q1,
    FXMVECTOR Q2,
    GXMVECTOR Q3,
    float    t
) noexcept
{
    XMVECTOR T = XMVectorReplicate(t);
    return XMQuaternionSquadV(Q0, Q1, Q2, Q3, T);
}



inline XMVECTOR __vectorcall XMQuaternionSquadV
(
    FXMVECTOR Q0,
    FXMVECTOR Q1,
    FXMVECTOR Q2,
    GXMVECTOR Q3,
    HXMVECTOR T
) noexcept
{
    (void)( (!!((XMVectorGetY(T) == XMVectorGetX(T)) && (XMVectorGetZ(T) == XMVectorGetX(T)) && (XMVectorGetW(T) == XMVectorGetX(T)))) || (_wassert(L"(XMVectorGetY(T) == XMVectorGetX(T)) && (XMVectorGetZ(T) == XMVectorGetX(T)) && (XMVectorGetW(T) == XMVectorGetX(T))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(426)), 0) );

    XMVECTOR TP = T;
    const XMVECTOR Two = XMVectorSplatConstant(2, 0);

    XMVECTOR Q03 = XMQuaternionSlerpV(Q0, Q3, T);
    XMVECTOR Q12 = XMQuaternionSlerpV(Q1, Q2, T);

    TP = XMVectorNegativeMultiplySubtract(TP, TP, TP);
    TP = XMVectorMultiply(TP, Two);

    XMVECTOR Result = XMQuaternionSlerpV(Q03, Q12, TP);

    return Result;
}



inline void __vectorcall XMQuaternionSquadSetup
(
    XMVECTOR* pA,
    XMVECTOR* pB,
    XMVECTOR* pC,
    FXMVECTOR  Q0,
    FXMVECTOR  Q1,
    FXMVECTOR  Q2,
    GXMVECTOR  Q3
) noexcept
{
    (void)( (!!(pA)) || (_wassert(L"pA", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(455)), 0) );
    (void)( (!!(pB)) || (_wassert(L"pB", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(456)), 0) );
    (void)( (!!(pC)) || (_wassert(L"pC", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(457)), 0) );

    XMVECTOR LS12 = XMQuaternionLengthSq(XMVectorAdd(Q1, Q2));
    XMVECTOR LD12 = XMQuaternionLengthSq(XMVectorSubtract(Q1, Q2));
    XMVECTOR SQ2 = XMVectorNegate(Q2);

    XMVECTOR Control1 = XMVectorLess(LS12, LD12);
    SQ2 = XMVectorSelect(Q2, SQ2, Control1);

    XMVECTOR LS01 = XMQuaternionLengthSq(XMVectorAdd(Q0, Q1));
    XMVECTOR LD01 = XMQuaternionLengthSq(XMVectorSubtract(Q0, Q1));
    XMVECTOR SQ0 = XMVectorNegate(Q0);

    XMVECTOR LS23 = XMQuaternionLengthSq(XMVectorAdd(SQ2, Q3));
    XMVECTOR LD23 = XMQuaternionLengthSq(XMVectorSubtract(SQ2, Q3));
    XMVECTOR SQ3 = XMVectorNegate(Q3);

    XMVECTOR Control0 = XMVectorLess(LS01, LD01);
    XMVECTOR Control2 = XMVectorLess(LS23, LD23);

    SQ0 = XMVectorSelect(Q0, SQ0, Control0);
    SQ3 = XMVectorSelect(Q3, SQ3, Control2);

    XMVECTOR InvQ1 = XMQuaternionInverse(Q1);
    XMVECTOR InvQ2 = XMQuaternionInverse(SQ2);

    XMVECTOR LnQ0 = XMQuaternionLn(XMQuaternionMultiply(InvQ1, SQ0));
    XMVECTOR LnQ2 = XMQuaternionLn(XMQuaternionMultiply(InvQ1, SQ2));
    XMVECTOR LnQ1 = XMQuaternionLn(XMQuaternionMultiply(InvQ2, Q1));
    XMVECTOR LnQ3 = XMQuaternionLn(XMQuaternionMultiply(InvQ2, SQ3));

    const XMVECTOR NegativeOneQuarter = XMVectorSplatConstant(-1, 2);

    XMVECTOR ExpQ02 = XMVectorMultiply(XMVectorAdd(LnQ0, LnQ2), NegativeOneQuarter);
    XMVECTOR ExpQ13 = XMVectorMultiply(XMVectorAdd(LnQ1, LnQ3), NegativeOneQuarter);
    ExpQ02 = XMQuaternionExp(ExpQ02);
    ExpQ13 = XMQuaternionExp(ExpQ13);

    *pA = XMQuaternionMultiply(Q1, ExpQ02);
    *pB = XMQuaternionMultiply(SQ2, ExpQ13);
    *pC = SQ2;
}



inline XMVECTOR __vectorcall XMQuaternionBaryCentric
(
    FXMVECTOR Q0,
    FXMVECTOR Q1,
    FXMVECTOR Q2,
    float    f,
    float    g
) noexcept
{
    float s = f + g;

    XMVECTOR Result;
    if ((s < 0.00001f) && (s > -0.00001f))
    {
        Result = Q0;
    }
    else
    {
        XMVECTOR Q01 = XMQuaternionSlerp(Q0, Q1, s);
        XMVECTOR Q02 = XMQuaternionSlerp(Q0, Q2, s);

        Result = XMQuaternionSlerp(Q01, Q02, g / s);
    }

    return Result;
}



inline XMVECTOR __vectorcall XMQuaternionBaryCentricV
(
    FXMVECTOR Q0,
    FXMVECTOR Q1,
    FXMVECTOR Q2,
    GXMVECTOR F,
    HXMVECTOR G
) noexcept
{
    (void)( (!!((XMVectorGetY(F) == XMVectorGetX(F)) && (XMVectorGetZ(F) == XMVectorGetX(F)) && (XMVectorGetW(F) == XMVectorGetX(F)))) || (_wassert(L"(XMVectorGetY(F) == XMVectorGetX(F)) && (XMVectorGetZ(F) == XMVectorGetX(F)) && (XMVectorGetW(F) == XMVectorGetX(F))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(540)), 0) );
    (void)( (!!((XMVectorGetY(G) == XMVectorGetX(G)) && (XMVectorGetZ(G) == XMVectorGetX(G)) && (XMVectorGetW(G) == XMVectorGetX(G)))) || (_wassert(L"(XMVectorGetY(G) == XMVectorGetX(G)) && (XMVectorGetZ(G) == XMVectorGetX(G)) && (XMVectorGetW(G) == XMVectorGetX(G))", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(541)), 0) );

    const XMVECTOR Epsilon = XMVectorSplatConstant(1, 16);

    XMVECTOR S = XMVectorAdd(F, G);

    XMVECTOR Result;
    if (XMVector4InBounds(S, Epsilon))
    {
        Result = Q0;
    }
    else
    {
        XMVECTOR Q01 = XMQuaternionSlerpV(Q0, Q1, S);
        XMVECTOR Q02 = XMQuaternionSlerpV(Q0, Q2, S);
        XMVECTOR GS = XMVectorReciprocal(S);
        GS = XMVectorMultiply(G, GS);

        Result = XMQuaternionSlerpV(Q01, Q02, GS);
    }

    return Result;
}







inline XMVECTOR __vectorcall XMQuaternionIdentity() noexcept
{
    return g_XMIdentityR3.v;
}



inline XMVECTOR __vectorcall XMQuaternionRotationRollPitchYaw
(
    float Pitch,
    float Yaw,
    float Roll
) noexcept
{
    XMVECTOR Angles = XMVectorSet(Pitch, Yaw, Roll, 0.0f);
    XMVECTOR Q = XMQuaternionRotationRollPitchYawFromVector(Angles);
    return Q;
}



inline XMVECTOR __vectorcall XMQuaternionRotationRollPitchYawFromVector
(
    FXMVECTOR Angles 
) noexcept
{
    static const XMVECTORF32  Sign = { { { 1.0f, -1.0f, -1.0f, 1.0f } } };

    XMVECTOR HalfAngles = XMVectorMultiply(Angles, g_XMOneHalf.v);

    XMVECTOR SinAngles, CosAngles;
    XMVectorSinCos(&SinAngles, &CosAngles, HalfAngles);

    XMVECTOR P0 = XMVectorPermute<XM_PERMUTE_0X, XM_PERMUTE_1X, XM_PERMUTE_1X, XM_PERMUTE_1X>(SinAngles, CosAngles);
    XMVECTOR Y0 = XMVectorPermute<XM_PERMUTE_1Y, XM_PERMUTE_0Y, XM_PERMUTE_1Y, XM_PERMUTE_1Y>(SinAngles, CosAngles);
    XMVECTOR R0 = XMVectorPermute<XM_PERMUTE_1Z, XM_PERMUTE_1Z, XM_PERMUTE_0Z, XM_PERMUTE_1Z>(SinAngles, CosAngles);
    XMVECTOR P1 = XMVectorPermute<XM_PERMUTE_0X, XM_PERMUTE_1X, XM_PERMUTE_1X, XM_PERMUTE_1X>(CosAngles, SinAngles);
    XMVECTOR Y1 = XMVectorPermute<XM_PERMUTE_1Y, XM_PERMUTE_0Y, XM_PERMUTE_1Y, XM_PERMUTE_1Y>(CosAngles, SinAngles);
    XMVECTOR R1 = XMVectorPermute<XM_PERMUTE_1Z, XM_PERMUTE_1Z, XM_PERMUTE_0Z, XM_PERMUTE_1Z>(CosAngles, SinAngles);

    XMVECTOR Q1 = XMVectorMultiply(P1, Sign.v);
    XMVECTOR Q0 = XMVectorMultiply(P0, Y0);
    Q1 = XMVectorMultiply(Q1, Y1);
    Q0 = XMVectorMultiply(Q0, R0);
    XMVECTOR Q = XMVectorMultiplyAdd(Q1, R1, Q0);

    return Q;
}



inline XMVECTOR __vectorcall XMQuaternionRotationNormal
(
    FXMVECTOR NormalAxis,
    float    Angle
) noexcept
{









#line 638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    XMVECTOR N = _mm_and_ps(NormalAxis, g_XMMask3);
    N = _mm_or_ps(N, g_XMIdentityR3);
    XMVECTOR Scale = _mm_set_ps1(0.5f * Angle);
    XMVECTOR vSine;
    XMVECTOR vCosine;
    XMVectorSinCos(&vSine, &vCosine, Scale);
    Scale = _mm_and_ps(vSine, g_XMMask3);
    vCosine = _mm_and_ps(vCosine, g_XMMaskW);
    Scale = _mm_or_ps(Scale, vCosine);
    N = _mm_mul_ps(N, Scale);
    return N;
#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMQuaternionRotationAxis
(
    FXMVECTOR Axis,
    float    Angle
) noexcept
{
    (void)( (!!(!XMVector3Equal(Axis, XMVectorZero()))) || (_wassert(L"!XMVector3Equal(Axis, XMVectorZero())", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(660)), 0) );
    (void)( (!!(!XMVector3IsInfinite(Axis))) || (_wassert(L"!XMVector3IsInfinite(Axis)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(661)), 0) );

    XMVECTOR Normal = XMVector3Normalize(Axis);
    XMVECTOR Q = XMQuaternionRotationNormal(Normal, Angle);
    return Q;
}



inline XMVECTOR __vectorcall XMQuaternionRotationMatrix(FXMMATRIX M) noexcept
{




















































#line 725 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"






















































































#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    static const XMVECTORF32 XMPMMP = { { { +1.0f, -1.0f, -1.0f, +1.0f } } };
    static const XMVECTORF32 XMMPMP = { { { -1.0f, +1.0f, -1.0f, +1.0f } } };
    static const XMVECTORF32 XMMMPP = { { { -1.0f, -1.0f, +1.0f, +1.0f } } };

    XMVECTOR r0 = M.r[0];  
    XMVECTOR r1 = M.r[1];  
    XMVECTOR r2 = M.r[2];  

    
    XMVECTOR r00 = _mm_shuffle_ps((r0), (r0), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    XMVECTOR r11 = _mm_shuffle_ps((r1), (r1), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    XMVECTOR r22 = _mm_shuffle_ps((r2), (r2), (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))) );

    
    
    XMVECTOR r11mr00 = _mm_sub_ps(r11, r00);
    XMVECTOR x2gey2 = _mm_cmple_ps(r11mr00, g_XMZero);

    
    
    XMVECTOR r11pr00 = _mm_add_ps(r11, r00);
    XMVECTOR z2gew2 = _mm_cmple_ps(r11pr00, g_XMZero);

    
    XMVECTOR x2py2gez2pw2 = _mm_cmple_ps(r22, g_XMZero);

    
    XMVECTOR t0 = _mm_add_ps(_mm_mul_ps((XMPMMP), (r00)), (g_XMOne));
    XMVECTOR t1 = _mm_mul_ps(XMMPMP, r11);
    XMVECTOR t2 = _mm_add_ps(_mm_mul_ps((XMMMPP), (r22)), (t0));
    XMVECTOR x2y2z2w2 = _mm_add_ps(t1, t2);

    
    t0 = _mm_shuffle_ps(r0, r1, (((1) << 6) | ((2) << 4) | ((2) << 2) | ((1))));
    
    t1 = _mm_shuffle_ps(r1, r2, (((1) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
    
    t1 = _mm_shuffle_ps((t1), (t1), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((0))) );
    
    XMVECTOR xyxzyz = _mm_add_ps(t0, t1);

    
    t0 = _mm_shuffle_ps(r2, r1, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((1))));
    
    t1 = _mm_shuffle_ps(r1, r0, (((1) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
    
    t1 = _mm_shuffle_ps((t1), (t1), (((1) << 6) | ((3) << 4) | ((2) << 2) | ((0))) );
    
    XMVECTOR xwywzw = _mm_sub_ps(t0, t1);
    xwywzw = _mm_mul_ps(XMMPMP, xwywzw);

    
    t0 = _mm_shuffle_ps(x2y2z2w2, xyxzyz, (((0) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    t1 = _mm_shuffle_ps(x2y2z2w2, xwywzw, (((0) << 6) | ((2) << 4) | ((3) << 2) | ((2))));
    
    t2 = _mm_shuffle_ps(xyxzyz, xwywzw, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((1))));

    
    XMVECTOR tensor0 = _mm_shuffle_ps(t0, t2, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
    
    XMVECTOR tensor1 = _mm_shuffle_ps(t0, t2, (((3) << 6) | ((1) << 4) | ((1) << 2) | ((2))));
    
    XMVECTOR tensor2 = _mm_shuffle_ps(t2, t1, (((2) << 6) | ((0) << 4) | ((1) << 2) | ((0))));
    
    XMVECTOR tensor3 = _mm_shuffle_ps(t2, t1, (((1) << 6) | ((2) << 4) | ((3) << 2) | ((2))));

    
    
    t0 = _mm_and_ps(x2gey2, tensor0);
    t1 = _mm_andnot_ps(x2gey2, tensor1);
    t0 = _mm_or_ps(t0, t1);
    t1 = _mm_and_ps(z2gew2, tensor2);
    t2 = _mm_andnot_ps(z2gew2, tensor3);
    t1 = _mm_or_ps(t1, t2);
    t0 = _mm_and_ps(x2py2gez2pw2, t0);
    t1 = _mm_andnot_ps(x2py2gez2pw2, t1);
    t2 = _mm_or_ps(t0, t1);

    
    
    
    t0 = XMVector4Length(t2);
    return _mm_div_ps(t2, t0);
#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}







inline void __vectorcall XMQuaternionToAxisAngle
(
    XMVECTOR* pAxis,
    float* pAngle,
    FXMVECTOR  Q
) noexcept
{
    (void)( (!!(pAxis)) || (_wassert(L"pAxis", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(914)), 0) );
    (void)( (!!(pAngle)) || (_wassert(L"pAngle", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(915)), 0) );

    *pAxis = Q;

    *pAngle = 2.0f * XMScalarACos(XMVectorGetW(Q));
}







 
 
 

 

inline bool __vectorcall XMPlaneEqual
(
    FXMVECTOR P1,
    FXMVECTOR P2
) noexcept
{
    return XMVector4Equal(P1, P2);
}



inline bool __vectorcall XMPlaneNearEqual
(
    FXMVECTOR P1,
    FXMVECTOR P2,
    FXMVECTOR Epsilon
) noexcept
{
    XMVECTOR NP1 = XMPlaneNormalize(P1);
    XMVECTOR NP2 = XMPlaneNormalize(P2);
    return XMVector4NearEqual(NP1, NP2, Epsilon);
}



inline bool __vectorcall XMPlaneNotEqual
(
    FXMVECTOR P1,
    FXMVECTOR P2
) noexcept
{
    return XMVector4NotEqual(P1, P2);
}



inline bool __vectorcall XMPlaneIsNaN(FXMVECTOR P) noexcept
{
    return XMVector4IsNaN(P);
}



inline bool __vectorcall XMPlaneIsInfinite(FXMVECTOR P) noexcept
{
    return XMVector4IsInfinite(P);
}







inline XMVECTOR __vectorcall XMPlaneDot
(
    FXMVECTOR P,
    FXMVECTOR V
) noexcept
{
    return XMVector4Dot(P, V);
}



inline XMVECTOR __vectorcall XMPlaneDotCoord
(
    FXMVECTOR P,
    FXMVECTOR V
) noexcept
{
    

    XMVECTOR V3 = XMVectorSelect(g_XMOne.v, V, g_XMSelect1110.v);
    XMVECTOR Result = XMVector4Dot(P, V3);
    return Result;
}



inline XMVECTOR __vectorcall XMPlaneDotNormal
(
    FXMVECTOR P,
    FXMVECTOR V
) noexcept
{
    return XMVector3Dot(P, V);
}





inline XMVECTOR __vectorcall XMPlaneNormalizeEst(FXMVECTOR P) noexcept
{





#line 1035 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"



#line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    
    XMVECTOR vDot = _mm_mul_ps(P, P);
    
    XMVECTOR vTemp = _mm_shuffle_ps((vDot), (vDot), (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    
    vDot = _mm_add_ss(vDot, vTemp);
    
    vDot = _mm_shuffle_ps((vDot), (vDot), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    vDot = _mm_rsqrt_ps(vDot);
    
    vDot = _mm_mul_ps(vDot, P);
    return vDot;
#line 1057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMPlaneNormalize(FXMVECTOR P) noexcept
{














#line 1078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1081 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"











#line 1093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    
    XMVECTOR vLengthSq = _mm_mul_ps(P, P);
    XMVECTOR vTemp = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((2) << 6) | ((1) << 4) | ((2) << 2) | ((1))) );
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vTemp = _mm_shuffle_ps((vTemp), (vTemp), (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))) );
    vLengthSq = _mm_add_ss(vLengthSq, vTemp);
    vLengthSq = _mm_shuffle_ps((vLengthSq), (vLengthSq), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))) );
    
    XMVECTOR vResult = _mm_sqrt_ps(vLengthSq);
    
    
    vLengthSq = _mm_cmpneq_ps(vLengthSq, g_XMInfinity);
    
    vResult = _mm_div_ps(P, vResult);
    
    vResult = _mm_and_ps(vResult, vLengthSq);
    return vResult;
#line 1111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMPlaneIntersectLine
(
    FXMVECTOR P,
    FXMVECTOR LinePoint1,
    FXMVECTOR LinePoint2
) noexcept
{
    XMVECTOR V1 = XMVector3Dot(P, LinePoint1);
    XMVECTOR V2 = XMVector3Dot(P, LinePoint2);
    XMVECTOR D = XMVectorSubtract(V1, V2);

    XMVECTOR VT = XMPlaneDotCoord(P, LinePoint1);
    VT = XMVectorDivide(VT, D);

    XMVECTOR Point = XMVectorSubtract(LinePoint2, LinePoint1);
    Point = XMVectorMultiplyAdd(Point, VT, LinePoint1);

    const XMVECTOR Zero = XMVectorZero();
    XMVECTOR Control = XMVectorNearEqual(D, Zero, g_XMEpsilon.v);

    return XMVectorSelect(Point, g_XMQNaN.v, Control);
}



inline void __vectorcall XMPlaneIntersectPlane
(
    XMVECTOR* pLinePoint1,
    XMVECTOR* pLinePoint2,
    FXMVECTOR  P1,
    FXMVECTOR  P2
) noexcept
{
    (void)( (!!(pLinePoint1)) || (_wassert(L"pLinePoint1", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(1148)), 0) );
    (void)( (!!(pLinePoint2)) || (_wassert(L"pLinePoint2", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(1149)), 0) );

    XMVECTOR V1 = XMVector3Cross(P2, P1);

    XMVECTOR LengthSq = XMVector3LengthSq(V1);

    XMVECTOR V2 = XMVector3Cross(P2, V1);

    XMVECTOR P1W = XMVectorSplatW(P1);
    XMVECTOR Point = XMVectorMultiply(V2, P1W);

    XMVECTOR V3 = XMVector3Cross(V1, P1);

    XMVECTOR P2W = XMVectorSplatW(P2);
    Point = XMVectorMultiplyAdd(V3, P2W, Point);

    XMVECTOR LinePoint1 = XMVectorDivide(Point, LengthSq);

    XMVECTOR LinePoint2 = XMVectorAdd(LinePoint1, V1);

    XMVECTOR Control = XMVectorLessOrEqual(LengthSq, g_XMEpsilon.v);
    *pLinePoint1 = XMVectorSelect(LinePoint1, g_XMQNaN.v, Control);
    *pLinePoint2 = XMVectorSelect(LinePoint2, g_XMQNaN.v, Control);
}



inline XMVECTOR __vectorcall XMPlaneTransform
(
    FXMVECTOR P,
    FXMMATRIX M
) noexcept
{
    XMVECTOR W = XMVectorSplatW(P);
    XMVECTOR Z = XMVectorSplatZ(P);
    XMVECTOR Y = XMVectorSplatY(P);
    XMVECTOR X = XMVectorSplatX(P);

    XMVECTOR Result = XMVectorMultiply(W, M.r[3]);
    Result = XMVectorMultiplyAdd(Z, M.r[2], Result);
    Result = XMVectorMultiplyAdd(Y, M.r[1], Result);
    Result = XMVectorMultiplyAdd(X, M.r[0], Result);
    return Result;
}



inline XMFLOAT4* __vectorcall XMPlaneTransformStream
(
    XMFLOAT4* pOutputStream,
    size_t          OutputStride,
    const XMFLOAT4* pInputStream,
    size_t          InputStride,
    size_t          PlaneCount,
    FXMMATRIX       M
) noexcept
{
    return XMVector4TransformStream(pOutputStream,
        OutputStride,
        pInputStream,
        InputStride,
        PlaneCount,
        M);
}







inline XMVECTOR __vectorcall XMPlaneFromPointNormal
(
    FXMVECTOR Point,
    FXMVECTOR Normal
) noexcept
{
    XMVECTOR W = XMVector3Dot(Point, Normal);
    W = XMVectorNegate(W);
    return XMVectorSelect(W, Normal, g_XMSelect1110.v);
}



inline XMVECTOR __vectorcall XMPlaneFromPoints
(
    FXMVECTOR Point1,
    FXMVECTOR Point2,
    FXMVECTOR Point3
) noexcept
{
    XMVECTOR V21 = XMVectorSubtract(Point1, Point2);
    XMVECTOR V31 = XMVectorSubtract(Point1, Point3);

    XMVECTOR N = XMVector3Cross(V21, V31);
    N = XMVector3Normalize(N);

    XMVECTOR D = XMPlaneDotNormal(N, Point1);
    D = XMVectorNegate(D);

    XMVECTOR Result = XMVectorSelect(D, N, g_XMSelect1110.v);

    return Result;
}







 
 
 

 

inline bool __vectorcall XMColorEqual
(
    FXMVECTOR C1,
    FXMVECTOR C2
) noexcept
{
    return XMVector4Equal(C1, C2);
}



inline bool __vectorcall XMColorNotEqual
(
    FXMVECTOR C1,
    FXMVECTOR C2
) noexcept
{
    return XMVector4NotEqual(C1, C2);
}



inline bool __vectorcall XMColorGreater
(
    FXMVECTOR C1,
    FXMVECTOR C2
) noexcept
{
    return XMVector4Greater(C1, C2);
}



inline bool __vectorcall XMColorGreaterOrEqual
(
    FXMVECTOR C1,
    FXMVECTOR C2
) noexcept
{
    return XMVector4GreaterOrEqual(C1, C2);
}



inline bool __vectorcall XMColorLess
(
    FXMVECTOR C1,
    FXMVECTOR C2
) noexcept
{
    return XMVector4Less(C1, C2);
}



inline bool __vectorcall XMColorLessOrEqual
(
    FXMVECTOR C1,
    FXMVECTOR C2
) noexcept
{
    return XMVector4LessOrEqual(C1, C2);
}



inline bool __vectorcall XMColorIsNaN(FXMVECTOR C) noexcept
{
    return XMVector4IsNaN(C);
}



inline bool __vectorcall XMColorIsInfinite(FXMVECTOR C) noexcept
{
    return XMVector4IsInfinite(C);
}







inline XMVECTOR __vectorcall XMColorNegative(FXMVECTOR vColor) noexcept
{








#line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1364 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    
    XMVECTOR vTemp = _mm_xor_ps(vColor, g_XMNegate3);
    
    return _mm_add_ps(vTemp, g_XMOne3);
#line 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMColorModulate
(
    FXMVECTOR C1,
    FXMVECTOR C2
) noexcept
{
    return XMVectorMultiply(C1, C2);
}



inline XMVECTOR __vectorcall XMColorAdjustSaturation
(
    FXMVECTOR vColor,
    float    fSaturation
) noexcept
{
    
    

    const XMVECTORF32 gvLuminance = { { { 0.2125f, 0.7154f, 0.0721f, 0.0f } } };








#line 1403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"




#line 1408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    XMVECTOR vLuminance = XMVector3Dot(vColor, gvLuminance);
    
    XMVECTOR vSaturation = _mm_set_ps1(fSaturation);
    
    XMVECTOR vResult = _mm_sub_ps(vColor, vLuminance);
    vResult = _mm_add_ps(_mm_mul_ps((vResult), (vSaturation)), (vLuminance));
    
    vLuminance = _mm_shuffle_ps(vResult, vColor, (((3) << 6) | ((2) << 4) | ((2) << 2) | ((2))));   
    vResult = _mm_shuffle_ps(vResult, vLuminance, (((3) << 6) | ((0) << 4) | ((1) << 2) | ((0))));  
    return vResult;
#line 1419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMColorAdjustContrast
(
    FXMVECTOR vColor,
    float    fContrast
) noexcept
{
    









#line 1440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"



#line 1444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    XMVECTOR vScale = _mm_set_ps1(fContrast);           
    XMVECTOR vResult = _mm_sub_ps(vColor, g_XMOneHalf);  
    vResult = _mm_add_ps(_mm_mul_ps((vResult), (vScale)), (g_XMOneHalf));

    vScale = _mm_shuffle_ps(vResult, vColor, (((3) << 6) | ((2) << 4) | ((2) << 2) | ((2))));   
    vResult = _mm_shuffle_ps(vResult, vScale, (((3) << 6) | ((0) << 4) | ((1) << 2) | ((0))));  
    return vResult;
#line 1452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMColorRGBToHSL(FXMVECTOR rgb) noexcept
{
    XMVECTOR r = XMVectorSplatX(rgb);
    XMVECTOR g = XMVectorSplatY(rgb);
    XMVECTOR b = XMVectorSplatZ(rgb);

    XMVECTOR min = XMVectorMin(r, XMVectorMin(g, b));
    XMVECTOR max = XMVectorMax(r, XMVectorMax(g, b));

    XMVECTOR l = XMVectorMultiply(XMVectorAdd(min, max), g_XMOneHalf);

    XMVECTOR d = XMVectorSubtract(max, min);

    XMVECTOR la = XMVectorSelect(rgb, l, g_XMSelect1110);

    if (XMVector3Less(d, g_XMEpsilon))
    {
        
        return XMVectorSelect(la, g_XMZero, g_XMSelect1100);
    }
    else
    {
        XMVECTOR s, h;

        XMVECTOR d2 = XMVectorAdd(min, max);

        if (XMVector3Greater(l, g_XMOneHalf))
        {
            
            s = XMVectorDivide(d, XMVectorSubtract(g_XMTwo, d2));
        }
        else
        {
            
            s = XMVectorDivide(d, d2);
        }

        if (XMVector3Equal(r, max))
        {
            
            h = XMVectorDivide(XMVectorSubtract(g, b), d);
        }
        else if (XMVector3Equal(g, max))
        {
            
            h = XMVectorDivide(XMVectorSubtract(b, r), d);
            h = XMVectorAdd(h, g_XMTwo);
        }
        else
        {
            
            h = XMVectorDivide(XMVectorSubtract(r, g), d);
            h = XMVectorAdd(h, g_XMFour);
        }

        h = XMVectorDivide(h, g_XMSix);

        if (XMVector3Less(h, g_XMZero))
            h = XMVectorAdd(h, g_XMOne);

        XMVECTOR lha = XMVectorSelect(la, h, g_XMSelect1100);
        return XMVectorSelect(s, lha, g_XMSelect1011);
    }
}



namespace Internal
{

    inline XMVECTOR __vectorcall XMColorHue2Clr(FXMVECTOR p, FXMVECTOR q, FXMVECTOR h) noexcept
    {
        static const XMVECTORF32 oneSixth = { { { 1.0f / 6.0f, 1.0f / 6.0f, 1.0f / 6.0f, 1.0f / 6.0f } } };
        static const XMVECTORF32 twoThirds = { { { 2.0f / 3.0f, 2.0f / 3.0f, 2.0f / 3.0f, 2.0f / 3.0f } } };

        XMVECTOR t = h;

        if (XMVector3Less(t, g_XMZero))
            t = XMVectorAdd(t, g_XMOne);

        if (XMVector3Greater(t, g_XMOne))
            t = XMVectorSubtract(t, g_XMOne);

        if (XMVector3Less(t, oneSixth))
        {
            
            XMVECTOR t1 = XMVectorSubtract(q, p);
            XMVECTOR t2 = XMVectorMultiply(g_XMSix, t);
            return XMVectorMultiplyAdd(t1, t2, p);
        }

        if (XMVector3Less(t, g_XMOneHalf))
            return q;

        if (XMVector3Less(t, twoThirds))
        {
            
            XMVECTOR t1 = XMVectorSubtract(q, p);
            XMVECTOR t2 = XMVectorMultiply(g_XMSix, XMVectorSubtract(twoThirds, t));
            return XMVectorMultiplyAdd(t1, t2, p);
        }

        return p;
    }

} 

inline XMVECTOR __vectorcall XMColorHSLToRGB(FXMVECTOR hsl) noexcept
{
    static const XMVECTORF32 oneThird = { { { 1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f } } };

    XMVECTOR s = XMVectorSplatY(hsl);
    XMVECTOR l = XMVectorSplatZ(hsl);

    if (XMVector3NearEqual(s, g_XMZero, g_XMEpsilon))
    {
        
        return XMVectorSelect(hsl, l, g_XMSelect1110);
    }
    else
    {
        XMVECTOR h = XMVectorSplatX(hsl);

        XMVECTOR q;
        if (XMVector3Less(l, g_XMOneHalf))
        {
            q = XMVectorMultiply(l, XMVectorAdd(g_XMOne, s));
        }
        else
        {
            q = XMVectorSubtract(XMVectorAdd(l, s), XMVectorMultiply(l, s));
        }

        XMVECTOR p = XMVectorSubtract(XMVectorMultiply(g_XMTwo, l), q);

        XMVECTOR r = DirectX::Internal::XMColorHue2Clr(p, q, XMVectorAdd(h, oneThird));
        XMVECTOR g = DirectX::Internal::XMColorHue2Clr(p, q, h);
        XMVECTOR b = DirectX::Internal::XMColorHue2Clr(p, q, XMVectorSubtract(h, oneThird));

        XMVECTOR rg = XMVectorSelect(g, r, g_XMSelect1000);
        XMVECTOR ba = XMVectorSelect(hsl, b, g_XMSelect1110);

        return XMVectorSelect(ba, rg, g_XMSelect1100);
    }
}



inline XMVECTOR __vectorcall XMColorRGBToHSV(FXMVECTOR rgb) noexcept
{
    XMVECTOR r = XMVectorSplatX(rgb);
    XMVECTOR g = XMVectorSplatY(rgb);
    XMVECTOR b = XMVectorSplatZ(rgb);

    XMVECTOR min = XMVectorMin(r, XMVectorMin(g, b));
    XMVECTOR v = XMVectorMax(r, XMVectorMax(g, b));

    XMVECTOR d = XMVectorSubtract(v, min);

    XMVECTOR s = (XMVector3NearEqual(v, g_XMZero, g_XMEpsilon)) ? g_XMZero : XMVectorDivide(d, v);

    if (XMVector3Less(d, g_XMEpsilon))
    {
        
        XMVECTOR hv = XMVectorSelect(v, g_XMZero, g_XMSelect1000);
        XMVECTOR hva = XMVectorSelect(rgb, hv, g_XMSelect1110);
        return XMVectorSelect(s, hva, g_XMSelect1011);
    }
    else
    {
        XMVECTOR h;

        if (XMVector3Equal(r, v))
        {
            
            h = XMVectorDivide(XMVectorSubtract(g, b), d);

            if (XMVector3Less(g, b))
                h = XMVectorAdd(h, g_XMSix);
        }
        else if (XMVector3Equal(g, v))
        {
            
            h = XMVectorDivide(XMVectorSubtract(b, r), d);
            h = XMVectorAdd(h, g_XMTwo);
        }
        else
        {
            
            h = XMVectorDivide(XMVectorSubtract(r, g), d);
            h = XMVectorAdd(h, g_XMFour);
        }

        h = XMVectorDivide(h, g_XMSix);

        XMVECTOR hv = XMVectorSelect(v, h, g_XMSelect1000);
        XMVECTOR hva = XMVectorSelect(rgb, hv, g_XMSelect1110);
        return XMVectorSelect(s, hva, g_XMSelect1011);
    }
}



inline XMVECTOR __vectorcall XMColorHSVToRGB(FXMVECTOR hsv) noexcept
{
    XMVECTOR h = XMVectorSplatX(hsv);
    XMVECTOR s = XMVectorSplatY(hsv);
    XMVECTOR v = XMVectorSplatZ(hsv);

    XMVECTOR h6 = XMVectorMultiply(h, g_XMSix);

    XMVECTOR i = XMVectorFloor(h6);
    XMVECTOR f = XMVectorSubtract(h6, i);

    
    XMVECTOR p = XMVectorMultiply(v, XMVectorSubtract(g_XMOne, s));

    
    XMVECTOR q = XMVectorMultiply(v, XMVectorSubtract(g_XMOne, XMVectorMultiply(f, s)));

    
    XMVECTOR t = XMVectorMultiply(v, XMVectorSubtract(g_XMOne, XMVectorMultiply(XMVectorSubtract(g_XMOne, f), s)));

    auto ii = static_cast<int>(XMVectorGetX(XMVectorMod(i, g_XMSix)));

    XMVECTOR _rgb;

    switch (ii)
    {
    case 0: 
    {
        XMVECTOR vt = XMVectorSelect(t, v, g_XMSelect1000);
        _rgb = XMVectorSelect(p, vt, g_XMSelect1100);
    }
    break;
    case 1: 
    {
        XMVECTOR qv = XMVectorSelect(v, q, g_XMSelect1000);
        _rgb = XMVectorSelect(p, qv, g_XMSelect1100);
    }
    break;
    case 2: 
    {
        XMVECTOR pv = XMVectorSelect(v, p, g_XMSelect1000);
        _rgb = XMVectorSelect(t, pv, g_XMSelect1100);
    }
    break;
    case 3: 
    {
        XMVECTOR pq = XMVectorSelect(q, p, g_XMSelect1000);
        _rgb = XMVectorSelect(v, pq, g_XMSelect1100);
    }
    break;
    case 4: 
    {
        XMVECTOR tp = XMVectorSelect(p, t, g_XMSelect1000);
        _rgb = XMVectorSelect(v, tp, g_XMSelect1100);
    }
    break;
    default: 
    {
        XMVECTOR vp = XMVectorSelect(p, v, g_XMSelect1000);
        _rgb = XMVectorSelect(q, vp, g_XMSelect1100);
    }
    break;
    }

    return XMVectorSelect(hsv, _rgb, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorRGBToYUV(FXMVECTOR rgb) noexcept
{
    static const XMVECTORF32 Scale0 = { { { 0.299f, -0.147f, 0.615f, 0.0f } } };
    static const XMVECTORF32 Scale1 = { { { 0.587f, -0.289f, -0.515f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 0.114f, 0.436f, -0.100f, 0.0f } } };

    XMMATRIX M(Scale0, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(rgb, M);

    return XMVectorSelect(rgb, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorYUVToRGB(FXMVECTOR yuv) noexcept
{
    static const XMVECTORF32 Scale1 = { { { 0.0f, -0.395f, 2.032f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 1.140f, -0.581f, 0.0f, 0.0f } } };

    XMMATRIX M(g_XMOne, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(yuv, M);

    return XMVectorSelect(yuv, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorRGBToYUV_HD(FXMVECTOR rgb) noexcept
{
    static const XMVECTORF32 Scale0 = { { { 0.2126f, -0.0997f, 0.6150f, 0.0f } } };
    static const XMVECTORF32 Scale1 = { { { 0.7152f, -0.3354f, -0.5586f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 0.0722f, 0.4351f, -0.0564f, 0.0f } } };

    XMMATRIX M(Scale0, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(rgb, M);

    return XMVectorSelect(rgb, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorYUVToRGB_HD(FXMVECTOR yuv) noexcept
{
    static const XMVECTORF32 Scale1 = { { { 0.0f, -0.2153f, 2.1324f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 1.2803f, -0.3806f, 0.0f, 0.0f } } };

    XMMATRIX M(g_XMOne, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(yuv, M);

    return XMVectorSelect(yuv, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorRGBToYUV_UHD(FXMVECTOR rgb) noexcept
{
    static const XMVECTORF32 Scale0 = { { { 0.2627f, -0.1215f,  0.6150f, 0.0f } } };
    static const XMVECTORF32 Scale1 = { { { 0.6780f, -0.3136f, -0.5655f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 0.0593f,  0.4351f, -0.0495f, 0.0f } } };

    XMMATRIX M(Scale0, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(rgb, M);

    return XMVectorSelect(rgb, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorYUVToRGB_UHD(FXMVECTOR yuv) noexcept
{
    static const XMVECTORF32 Scale1 = { { {    0.0f, -0.1891f, 2.1620f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 1.1989f, -0.4645f,    0.0f, 0.0f } } };

    XMMATRIX M(g_XMOne, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(yuv, M);

    return XMVectorSelect(yuv, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorRGBToXYZ(FXMVECTOR rgb) noexcept
{
    static const XMVECTORF32 Scale0 = { { { 0.4887180f, 0.1762044f, 0.0000000f, 0.0f } } };
    static const XMVECTORF32 Scale1 = { { { 0.3106803f, 0.8129847f, 0.0102048f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 0.2006017f, 0.0108109f, 0.9897952f, 0.0f } } };
    static const XMVECTORF32 Scale = { { { 1.f / 0.17697f, 1.f / 0.17697f, 1.f / 0.17697f, 0.0f } } };

    XMMATRIX M(Scale0, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVectorMultiply(XMVector3Transform(rgb, M), Scale);

    return XMVectorSelect(rgb, clr, g_XMSelect1110);
}

inline XMVECTOR __vectorcall XMColorXYZToRGB(FXMVECTOR xyz) noexcept
{
    static const XMVECTORF32 Scale0 = { { { 2.3706743f, -0.5138850f, 0.0052982f, 0.0f } } };
    static const XMVECTORF32 Scale1 = { { { -0.9000405f, 1.4253036f, -0.0146949f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { -0.4706338f, 0.0885814f, 1.0093968f, 0.0f } } };
    static const XMVECTORF32 Scale = { { { 0.17697f, 0.17697f, 0.17697f, 0.0f } } };

    XMMATRIX M(Scale0, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(XMVectorMultiply(xyz, Scale), M);

    return XMVectorSelect(xyz, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorXYZToSRGB(FXMVECTOR xyz) noexcept
{
    static const XMVECTORF32 Scale0 = { { { 3.2406f, -0.9689f, 0.0557f, 0.0f } } };
    static const XMVECTORF32 Scale1 = { { { -1.5372f, 1.8758f, -0.2040f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { -0.4986f, 0.0415f, 1.0570f, 0.0f } } };
    static const XMVECTORF32 Cutoff = { { { 0.0031308f, 0.0031308f, 0.0031308f, 0.0f } } };
    static const XMVECTORF32 Exp = { { { 1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f, 1.0f } } };

    XMMATRIX M(Scale0, Scale1, Scale2, g_XMZero);
    XMVECTOR lclr = XMVector3Transform(xyz, M);

    XMVECTOR sel = XMVectorGreater(lclr, Cutoff);

    
    XMVECTOR smallC = XMVectorMultiply(lclr, g_XMsrgbScale);

    
    XMVECTOR largeC = XMVectorSubtract(XMVectorMultiply(g_XMsrgbA1, XMVectorPow(lclr, Exp)), g_XMsrgbA);

    XMVECTOR clr = XMVectorSelect(smallC, largeC, sel);

    return XMVectorSelect(xyz, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorSRGBToXYZ(FXMVECTOR srgb) noexcept
{
    static const XMVECTORF32 Scale0 = { { { 0.4124f, 0.2126f, 0.0193f, 0.0f } } };
    static const XMVECTORF32 Scale1 = { { { 0.3576f, 0.7152f, 0.1192f, 0.0f } } };
    static const XMVECTORF32 Scale2 = { { { 0.1805f, 0.0722f, 0.9505f, 0.0f } } };
    static const XMVECTORF32 Cutoff = { { { 0.04045f, 0.04045f, 0.04045f, 0.0f } } };
    static const XMVECTORF32 Exp = { { { 2.4f, 2.4f, 2.4f, 1.0f } } };

    XMVECTOR sel = XMVectorGreater(srgb, Cutoff);

    
    XMVECTOR smallC = XMVectorDivide(srgb, g_XMsrgbScale);

    
    XMVECTOR largeC = XMVectorPow(XMVectorDivide(XMVectorAdd(srgb, g_XMsrgbA), g_XMsrgbA1), Exp);

    XMVECTOR lclr = XMVectorSelect(smallC, largeC, sel);

    XMMATRIX M(Scale0, Scale1, Scale2, g_XMZero);
    XMVECTOR clr = XMVector3Transform(lclr, M);

    return XMVectorSelect(srgb, clr, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorRGBToSRGB(FXMVECTOR rgb) noexcept
{
    static const XMVECTORF32 Cutoff = { { { 0.0031308f, 0.0031308f, 0.0031308f, 1.f } } };
    static const XMVECTORF32 Linear = { { { 12.92f, 12.92f, 12.92f, 1.f } } };
    static const XMVECTORF32 Scale = { { { 1.055f, 1.055f, 1.055f, 1.f } } };
    static const XMVECTORF32 Bias = { { { 0.055f, 0.055f, 0.055f, 0.f } } };
    static const XMVECTORF32 InvGamma = { { { 1.0f / 2.4f, 1.0f / 2.4f, 1.0f / 2.4f, 1.f } } };

    XMVECTOR V = XMVectorSaturate(rgb);
    XMVECTOR V0 = XMVectorMultiply(V, Linear);
    XMVECTOR V1 = XMVectorSubtract(XMVectorMultiply(Scale, XMVectorPow(V, InvGamma)), Bias);
    XMVECTOR select = XMVectorLess(V, Cutoff);
    V = XMVectorSelect(V1, V0, select);
    return XMVectorSelect(rgb, V, g_XMSelect1110);
}



inline XMVECTOR __vectorcall XMColorSRGBToRGB(FXMVECTOR srgb) noexcept
{
    static const XMVECTORF32 Cutoff = { { { 0.04045f, 0.04045f, 0.04045f, 1.f } } };
    static const XMVECTORF32 ILinear = { { { 1.f / 12.92f, 1.f / 12.92f, 1.f / 12.92f, 1.f } } };
    static const XMVECTORF32 Scale = { { { 1.f / 1.055f, 1.f / 1.055f, 1.f / 1.055f, 1.f } } };
    static const XMVECTORF32 Bias = { { { 0.055f, 0.055f, 0.055f, 0.f } } };
    static const XMVECTORF32 Gamma = { { { 2.4f, 2.4f, 2.4f, 1.f } } };

    XMVECTOR V = XMVectorSaturate(srgb);
    XMVECTOR V0 = XMVectorMultiply(V, ILinear);
    XMVECTOR V1 = XMVectorPow(XMVectorMultiply(XMVectorAdd(V, Bias), Scale), Gamma);
    XMVECTOR select = XMVectorGreater(V, Cutoff);
    V = XMVectorSelect(V0, V1, select);
    return XMVectorSelect(srgb, V, g_XMSelect1110);
}







 

inline bool XMVerifyCPUSupport() noexcept
{

    int CPUInfo[4] = { -1 };


#line 1938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    __cpuid(CPUInfo, 0);
#line 1940 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"





    if (CPUInfo[0] < 1)
        return false;
#line 1948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"



#line 1952 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    __cpuid(CPUInfo, 1);
#line 1954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"





#line 1960 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1975 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"


#line 1978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"

    
    if ((CPUInfo[3] & 0x6000000) != 0x6000000)
        return false; 









#line 1992 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"

    return true;






#line 2001 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline XMVECTOR __vectorcall XMFresnelTerm
(
    FXMVECTOR CosIncidentAngle,
    FXMVECTOR RefractionIndex
) noexcept
{
    (void)( (!!(!XMVector4IsInfinite(CosIncidentAngle))) || (_wassert(L"!XMVector4IsInfinite(CosIncidentAngle)", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(2011)), 0) );

    
    
    






























#line 2047 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
    
    XMVECTOR G = _mm_mul_ps(RefractionIndex, RefractionIndex);
    XMVECTOR vTemp = _mm_mul_ps(CosIncidentAngle, CosIncidentAngle);
    G = _mm_sub_ps(G, g_XMOne);
    vTemp = _mm_add_ps(vTemp, G);
    
    
    G = _mm_setzero_ps();
    G = _mm_sub_ps(G, vTemp);
    G = _mm_max_ps(G, vTemp);
    
    G = _mm_sqrt_ps(G);

    
    XMVECTOR GAddC = _mm_add_ps(G, CosIncidentAngle);
    XMVECTOR GSubC = _mm_sub_ps(G, CosIncidentAngle);
    
    XMVECTOR vResult = _mm_mul_ps(GSubC, GSubC);
    vTemp = _mm_mul_ps(GAddC, GAddC);
    vResult = _mm_mul_ps(vResult, g_XMOneHalf);
    vResult = _mm_div_ps(vResult, vTemp);
    
    GAddC = _mm_mul_ps(GAddC, CosIncidentAngle);
    GSubC = _mm_mul_ps(GSubC, CosIncidentAngle);
    GAddC = _mm_sub_ps(GAddC, g_XMOne);
    GSubC = _mm_add_ps(GSubC, g_XMOne);
    GAddC = _mm_mul_ps(GAddC, GAddC);
    GSubC = _mm_mul_ps(GSubC, GSubC);
    GAddC = _mm_div_ps(GAddC, GSubC);
    GAddC = _mm_add_ps(GAddC, g_XMOne);
    
    vResult = _mm_mul_ps(vResult, GAddC);
    
    vResult = _mm_max_ps(vResult, g_XMZero);
    vResult = _mm_min_ps(vResult, g_XMOne);
    return vResult;
#line 2084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl"
}



inline bool XMScalarNearEqual
(
    float S1,
    float S2,
    float Epsilon
) noexcept
{
    float Delta = S1 - S2;
    return (fabsf(Delta) <= Epsilon);
}



inline float XMScalarModAngle(float Angle) noexcept
{
    
    

    
    Angle = Angle + XM_PI;
    
    float fTemp = fabsf(Angle);
    fTemp = fTemp - (XM_2PI * static_cast<float>(static_cast<int32_t>(fTemp / XM_2PI)));
    
    fTemp = fTemp - XM_PI;
    
    if (Angle < 0.0f)
    {
        fTemp = -fTemp;
    }
    return fTemp;
}



inline float XMScalarSin(float Value) noexcept
{
    
    float quotient = XM_1DIV2PI * Value;
    if (Value >= 0.0f)
    {
        quotient = static_cast<float>(static_cast<int>(quotient + 0.5f));
    }
    else
    {
        quotient = static_cast<float>(static_cast<int>(quotient - 0.5f));
    }
    float y = Value - XM_2PI * quotient;

    
    if (y > XM_PIDIV2)
    {
        y = XM_PI - y;
    }
    else if (y < -XM_PIDIV2)
    {
        y = -XM_PI - y;
    }

    
    float y2 = y * y;
    return (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;
}



inline float XMScalarSinEst(float Value) noexcept
{
    
    float quotient = XM_1DIV2PI * Value;
    if (Value >= 0.0f)
    {
        quotient = static_cast<float>(static_cast<int>(quotient + 0.5f));
    }
    else
    {
        quotient = static_cast<float>(static_cast<int>(quotient - 0.5f));
    }
    float y = Value - XM_2PI * quotient;

    
    if (y > XM_PIDIV2)
    {
        y = XM_PI - y;
    }
    else if (y < -XM_PIDIV2)
    {
        y = -XM_PI - y;
    }

    
    float y2 = y * y;
    return (((-0.00018524670f * y2 + 0.0083139502f) * y2 - 0.16665852f) * y2 + 1.0f) * y;
}



inline float XMScalarCos(float Value) noexcept
{
    
    float quotient = XM_1DIV2PI * Value;
    if (Value >= 0.0f)
    {
        quotient = static_cast<float>(static_cast<int>(quotient + 0.5f));
    }
    else
    {
        quotient = static_cast<float>(static_cast<int>(quotient - 0.5f));
    }
    float y = Value - XM_2PI * quotient;

    
    float sign;
    if (y > XM_PIDIV2)
    {
        y = XM_PI - y;
        sign = -1.0f;
    }
    else if (y < -XM_PIDIV2)
    {
        y = -XM_PI - y;
        sign = -1.0f;
    }
    else
    {
        sign = +1.0f;
    }

    
    float y2 = y * y;
    float p = ((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f;
    return sign * p;
}



inline float XMScalarCosEst(float Value) noexcept
{
    
    float quotient = XM_1DIV2PI * Value;
    if (Value >= 0.0f)
    {
        quotient = static_cast<float>(static_cast<int>(quotient + 0.5f));
    }
    else
    {
        quotient = static_cast<float>(static_cast<int>(quotient - 0.5f));
    }
    float y = Value - XM_2PI * quotient;

    
    float sign;
    if (y > XM_PIDIV2)
    {
        y = XM_PI - y;
        sign = -1.0f;
    }
    else if (y < -XM_PIDIV2)
    {
        y = -XM_PI - y;
        sign = -1.0f;
    }
    else
    {
        sign = +1.0f;
    }

    
    float y2 = y * y;
    float p = ((-0.0012712436f * y2 + 0.041493919f) * y2 - 0.49992746f) * y2 + 1.0f;
    return sign * p;
}




inline void XMScalarSinCos
(
    float* pSin,
    float* pCos,
    float  Value
) noexcept
{
    (void)( (!!(pSin)) || (_wassert(L"pSin", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(2271)), 0) );
    (void)( (!!(pCos)) || (_wassert(L"pCos", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(2272)), 0) );

    
    float quotient = XM_1DIV2PI * Value;
    if (Value >= 0.0f)
    {
        quotient = static_cast<float>(static_cast<int>(quotient + 0.5f));
    }
    else
    {
        quotient = static_cast<float>(static_cast<int>(quotient - 0.5f));
    }
    float y = Value - XM_2PI * quotient;

    
    float sign;
    if (y > XM_PIDIV2)
    {
        y = XM_PI - y;
        sign = -1.0f;
    }
    else if (y < -XM_PIDIV2)
    {
        y = -XM_PI - y;
        sign = -1.0f;
    }
    else
    {
        sign = +1.0f;
    }

    float y2 = y * y;

    
    *pSin = (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;

    
    float p = ((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f;
    *pCos = sign * p;
}




inline void XMScalarSinCosEst
(
    float* pSin,
    float* pCos,
    float  Value
) noexcept
{
    (void)( (!!(pSin)) || (_wassert(L"pSin", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(2323)), 0) );
    (void)( (!!(pCos)) || (_wassert(L"pCos", L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMathMisc.inl", (unsigned)(2324)), 0) );

    
    float quotient = XM_1DIV2PI * Value;
    if (Value >= 0.0f)
    {
        quotient = static_cast<float>(static_cast<int>(quotient + 0.5f));
    }
    else
    {
        quotient = static_cast<float>(static_cast<int>(quotient - 0.5f));
    }
    float y = Value - XM_2PI * quotient;

    
    float sign;
    if (y > XM_PIDIV2)
    {
        y = XM_PI - y;
        sign = -1.0f;
    }
    else if (y < -XM_PIDIV2)
    {
        y = -XM_PI - y;
        sign = -1.0f;
    }
    else
    {
        sign = +1.0f;
    }

    float y2 = y * y;

    
    *pSin = (((-0.00018524670f * y2 + 0.0083139502f) * y2 - 0.16665852f) * y2 + 1.0f) * y;

    
    float p = ((-0.0012712436f * y2 + 0.041493919f) * y2 - 0.49992746f) * y2 + 1.0f;
    *pCos = sign * p;
}



inline float XMScalarASin(float Value) noexcept
{
    
    bool nonnegative = (Value >= 0.0f);
    float x = fabsf(Value);
    float omx = 1.0f - x;
    if (omx < 0.0f)
    {
        omx = 0.0f;
    }
    float root = sqrtf(omx);

    
    float result = ((((((-0.0012624911f * x + 0.0066700901f) * x - 0.0170881256f) * x + 0.0308918810f) * x - 0.0501743046f) * x + 0.0889789874f) * x - 0.2145988016f) * x + 1.5707963050f;
    result *= root;  

    
    return (nonnegative ? XM_PIDIV2 - result : result - XM_PIDIV2);
}



inline float XMScalarASinEst(float Value) noexcept
{
    
    bool nonnegative = (Value >= 0.0f);
    float x = fabsf(Value);
    float omx = 1.0f - x;
    if (omx < 0.0f)
    {
        omx = 0.0f;
    }
    float root = sqrtf(omx);

    
    float result = ((-0.0187293f * x + 0.0742610f) * x - 0.2121144f) * x + 1.5707288f;
    result *= root;  

    
    return (nonnegative ? XM_PIDIV2 - result : result - XM_PIDIV2);
}



inline float XMScalarACos(float Value) noexcept
{
    
    bool nonnegative = (Value >= 0.0f);
    float x = fabsf(Value);
    float omx = 1.0f - x;
    if (omx < 0.0f)
    {
        omx = 0.0f;
    }
    float root = sqrtf(omx);

    
    float result = ((((((-0.0012624911f * x + 0.0066700901f) * x - 0.0170881256f) * x + 0.0308918810f) * x - 0.0501743046f) * x + 0.0889789874f) * x - 0.2145988016f) * x + 1.5707963050f;
    result *= root;

    
    return (nonnegative ? result : XM_PI - result);
}



inline float XMScalarACosEst(float Value) noexcept
{
    
    bool nonnegative = (Value >= 0.0f);
    float x = fabsf(Value);
    float omx = 1.0f - x;
    if (omx < 0.0f)
    {
        omx = 0.0f;
    }
    float root = sqrtf(omx);

    
    float result = ((-0.0187293f * x + 0.0742610f) * x - 0.2121144f) * x + 1.5707288f;
    result *= root;

    
    return (nonnegative ? result : XM_PI - result);
}

#pragma external_header(pop)
#line 2227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\DirectXMath.h"









#pragma warning(pop)

} 

#pragma external_header(pop)
#line 5 "C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.h"

class Waves
{
public:
	Waves(int m, int n, float dx, float dt, float speed, float damping);
	Waves(const Waves& rhs) = delete;
	Waves& operator=(const Waves& rhs) = delete;
	~Waves();

	int RowCount() const;
	int ColumnCount() const;
	int VertexCount() const;
	int TriangleCount() const;
	float Width() const;
	float Depth() const;

	
	const DirectX::XMFLOAT3& Position(int i)const { return mCurrSolution[i]; }

	
	const DirectX::XMFLOAT3& Normal(int i)const { return mNormals[i]; }

	
	const DirectX::XMFLOAT3& TangentX(int i)const { return mTangentX[i]; }

	void Update(float dt);
	void Disturb(int i, int j, float magnitude);

private:
	
	int mNumRows = 0;
	int mNumCols = 0;

	int mVertexCount = 0;
	int mTriangleCount = 0;

	
	float mK1 = 0.0f;
	float mK2 = 0.0f;
	float mK3 = 0.0f;

	float mTimeStep = 0.0f;
	float mSpatialStep = 0.0f;

	std::vector<DirectX::XMFLOAT3> mPrevSolution;
	std::vector<DirectX::XMFLOAT3> mCurrSolution;
	std::vector<DirectX::XMFLOAT3> mNormals;
	std::vector<DirectX::XMFLOAT3> mTangentX;
};

#line 2 "C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.cpp"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"















#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"
















#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"


















































































#pragma external_header(pop)
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"



#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"



#line 28 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"



#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"











#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"




















#line 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"






#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"






#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"






#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"












#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"








typedef GUID *LPGUID;
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"



typedef const GUID *LPCGUID;
#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"




typedef GUID IID;
typedef IID *LPIID;


typedef GUID CLSID;
typedef CLSID *LPCLSID;


typedef GUID FMTID;
typedef FMTID *LPFMTID;







#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"







#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"







#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"







#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"







#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"

#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"








__inline int InlineIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}











#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"

















__inline bool operator==(const GUID & guidOne, const GUID & guidOther)
{
    return !!IsEqualGUID(guidOne,guidOther);
}

__inline bool operator!=(const GUID & guidOne, const GUID & guidOther)
{
    return !(guidOne == guidOther);
}
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\shared\\guiddef.h"
#pragma external_header(pop)
#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"



#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplinterface.h"















#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"





#pragma once










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {



















#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"


using streamoff  = long long;
using streamsize = long long;

template <class _Statetype>
class fpos { 
public:
     fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

    fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

    [[nodiscard]] _Statetype state() const {
        return _Mystate;
    }

    void state(_Statetype _State) {
        _Mystate = _State;
    }

    operator streamoff() const {
        
        
        return _Myoff + _Fpos;
    }


    [[deprecated("warning STL4019: " "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with " "workarounds for old versions of Visual C++. It will be removed in a future release, and in this " "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as " "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use " "standards-conforming mechanisms, as it does for other compilers. You can define " "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have received this warning, " "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t seekpos() const noexcept {
        return {};
    }
#line 76 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"

    [[nodiscard]] streamoff operator-(const fpos& _Right) const {
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }

    fpos& operator+=(streamoff _Off) { 
        _Myoff += _Off;
        return *this;
    }

    fpos& operator-=(streamoff _Off) { 
        _Myoff -= _Off;
        return *this;
    }

    [[nodiscard]] fpos operator+(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] fpos operator-(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] bool operator==(const fpos& _Right) const {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) == _Right;
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const _Int _Left, const fpos& _Right) {
        return _Left == static_cast<streamoff>(_Right);
    }

    [[nodiscard]] bool operator!=(const fpos& _Right) const {
        return static_cast<streamoff>(*this) != static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator!=(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) != _Right;
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator!=(const _Int _Left, const fpos& _Right) {
        return _Left != static_cast<streamoff>(_Right);
    }

private:
    streamoff _Myoff; 
    fpos_t _Fpos; 
    _Statetype _Mystate; 
};

using streampos  = fpos<_Mbstatet>;
using wstreampos = streampos;

class locale;
template <class _Facet>
const _Facet& __cdecl use_facet(const locale&);

template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;




template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;

template <>
struct char_traits<unsigned short>;
#line 162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"

template <class _Ty>
class allocator;
class ios_base;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;

#pragma vtordisp(push, 2) 
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop) 

template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;







#line 208 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"


template <class _Elem, class _InIt>
class num_get;
template <class _Elem, class _OutIt>
class num_put;
template <class _Elem>
class collate;
#line 217 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"

using ios           = basic_ios<char, char_traits<char>>;
using streambuf     = basic_streambuf<char, char_traits<char>>;
using istream       = basic_istream<char, char_traits<char>>;
using ostream       = basic_ostream<char, char_traits<char>>;
using iostream      = basic_iostream<char, char_traits<char>>;
using stringbuf     = basic_stringbuf<char, char_traits<char>, allocator<char>>;
using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
using stringstream  = basic_stringstream<char, char_traits<char>, allocator<char>>;
using filebuf       = basic_filebuf<char, char_traits<char>>;
using ifstream      = basic_ifstream<char, char_traits<char>>;
using ofstream      = basic_ofstream<char, char_traits<char>>;
using fstream       = basic_fstream<char, char_traits<char>>;



#line 235 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"

using wios           = basic_ios<wchar_t, char_traits<wchar_t>>;
using wstreambuf     = basic_streambuf<wchar_t, char_traits<wchar_t>>;
using wistream       = basic_istream<wchar_t, char_traits<wchar_t>>;
using wostream       = basic_ostream<wchar_t, char_traits<wchar_t>>;
using wiostream      = basic_iostream<wchar_t, char_traits<wchar_t>>;
using wstringbuf     = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wstringstream  = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wfilebuf       = basic_filebuf<wchar_t, char_traits<wchar_t>>;
using wifstream      = basic_ifstream<wchar_t, char_traits<wchar_t>>;
using wofstream      = basic_ofstream<wchar_t, char_traits<wchar_t>>;
using wfstream       = basic_fstream<wchar_t, char_traits<wchar_t>>;



#line 253 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"





#line 259 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"
}



#pragma warning(pop)
#pragma pack(pop)
#line 266 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"
#line 267 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iosfwd"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\typeinfo"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




#pragma warning(disable : 4275) 

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"







#pragma once






#pragma warning(push)
#pragma warning(disable:   4514 4820 )

#pragma pack(push, 8)





#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"



__pragma(pack(push, 8)) extern "C" {

struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

 int __cdecl __std_type_info_compare(
      const __std_type_info_data* _Lhs,
      const __std_type_info_data* _Rhs
    );

 size_t __cdecl __std_type_info_hash(
      const __std_type_info_data* _Data
    );

 const char* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))


#pragma warning(push)
#pragma warning(disable: 4577) 
class type_info
{
public:

    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }


    bool operator!=(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }
#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"

    bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    const char* name() const noexcept
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"
    }

    const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() noexcept;

private:

    mutable __std_type_info_data _Data;
};
#pragma warning(pop)

namespace std {
    using ::type_info;
}



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class bad_cast
    : public exception
{
public:

    bad_cast() noexcept
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() noexcept
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(const char* const _Message, int) noexcept
        : bad_typeid(_Message, 1)
    {
    }
};

#pragma warning(pop)
} 

#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#pragma warning(pop) 
#line 203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_typeinfo.h"
#pragma external_header(pop)
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\typeinfo"

namespace std {


constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);































#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\typeinfo"

[[noreturn]] inline void _Throw_bad_cast() {
    throw bad_cast{};
}

}



#pragma pack(pop)
#pragma warning(pop)
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\typeinfo"
#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\typeinfo"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"




#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
















































































template <class _InIt, class _Diff, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _Dest;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
        _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }

        _UDest = _Backout._Release();
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}








































































































































#line 271 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"


















































































































template <class _NoThrowFwdIt, class _Diff, class _Tval>
_NoThrowFwdIt uninitialized_fill_n(_NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
        _UFirst += _Count;
    } else {
        if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                _Seek_wrapped(_First, _UFirst + _Count);
                return _First;
            }
        }

        _Uninitialized_backout<decltype(_UFirst)> _Backout{_UFirst};

        for (; _Count > 0; --_Count) {
            _Backout._Emplace_back(_Val);
        }

        _UFirst = _Backout._Release();
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}





































































































































































































































































































































































































































































#line 872 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"



template <class _OutIt, class _Ty>
class  raw_storage_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;

    explicit raw_storage_iterator(_OutIt _First) : _Next(_First) {}

    [[nodiscard]] raw_storage_iterator& operator*() { 
        return *this;
    }

    raw_storage_iterator& operator=(const _Ty& _Val) { 
        _Construct_in_place(*_Next, _Val);
        return *this;
    }

    raw_storage_iterator& operator=(_Ty&& _Val) { 
        _Construct_in_place(*_Next, ::std:: move(_Val));
        return *this;
    }

    raw_storage_iterator& operator++() {
        ++_Next;
        return *this;
    }

    raw_storage_iterator operator++(int) {
        raw_storage_iterator _Ans = *this;
        ++_Next;
        return _Ans;
    }

    [[nodiscard]] _OutIt base() const {
        return _Next;
    }

private:
    _OutIt _Next;
};
#line 919 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"



template <class _Ty>
class auto_ptr;

template <class _Ty>
struct auto_ptr_ref { 
    explicit auto_ptr_ref(_Ty* _Right) : _Ref(_Right) {}

    _Ty* _Ref; 
};

template <class _Ty>
class auto_ptr { 
public:
    using element_type = _Ty;

    explicit auto_ptr(_Ty* _Ptr = nullptr) noexcept : _Myptr(_Ptr) {}

    auto_ptr(auto_ptr& _Right) noexcept : _Myptr(_Right.release()) {}

    auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept {
        _Ty* _Ptr   = _Right._Ref;
        _Right._Ref = nullptr; 
        _Myptr      = _Ptr; 
    }

    template <class _Other>
    operator auto_ptr<_Other>() noexcept { 
        return auto_ptr<_Other>(*this);
    }

    template <class _Other>
    operator auto_ptr_ref<_Other>() noexcept { 
        _Other* _Cvtptr = _Myptr; 
        auto_ptr_ref<_Other> _Ans(_Cvtptr);
        _Myptr = nullptr; 
        return _Ans;
    }

    template <class _Other>
    auto_ptr& operator=(auto_ptr<_Other>& _Right) noexcept {
        reset(_Right.release());
        return *this;
    }

    template <class _Other>
    auto_ptr(auto_ptr<_Other>& _Right) noexcept : _Myptr(_Right.release()) {}

    auto_ptr& operator=(auto_ptr& _Right) noexcept {
        reset(_Right.release());
        return *this;
    }

    auto_ptr& operator=(auto_ptr_ref<_Ty> _Right) noexcept {
        _Ty* _Ptr   = _Right._Ref;
        _Right._Ref = 0; 
        reset(_Ptr); 
        return *this;
    }

    ~auto_ptr() noexcept {
        delete _Myptr;
    }

    [[nodiscard]] _Ty& operator*() const noexcept {

        do { if (_Myptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory", 987, 0, "%s", "auto_ptr not dereferenceable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"auto_ptr not dereferenceable\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory", 987, 0); } while (false); } ; } while (false);
#line 989 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

        return *get();
    }

    [[nodiscard]] _Ty* operator->() const noexcept {

        do { if (_Myptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory", 995, 0, "%s", "auto_ptr not dereferenceable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"auto_ptr not dereferenceable\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory", 995, 0); } while (false); } ; } while (false);
#line 997 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

        return get();
    }

    [[nodiscard]] _Ty* get() const noexcept {
        return _Myptr;
    }

    _Ty* release() noexcept {
        _Ty* _Tmp = _Myptr;
        _Myptr    = nullptr;
        return _Tmp;
    }

    void reset(_Ty* _Ptr = nullptr) noexcept { 
        if (_Ptr != _Myptr) {
            delete _Myptr;
        }

        _Myptr = _Ptr;
    }

private:
    _Ty* _Myptr; 
};

template <>
class auto_ptr<void> {
public:
    using element_type = void;
};
#line 1029 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"


class bad_weak_ptr : public exception { 
public:
    bad_weak_ptr() noexcept {}

    [[nodiscard]] const char*  what() const noexcept override {
        
        return "bad_weak_ptr";
    }
};

[[noreturn]] inline void _Throw_bad_weak_ptr() {
    throw bad_weak_ptr{};
}

class __declspec(novtable) _Ref_count_base { 
private:










    virtual void _Destroy() noexcept     = 0; 
    virtual void _Delete_this() noexcept = 0; 
#line 1060 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    _Atomic_counter_t _Uses  = 1;
    _Atomic_counter_t _Weaks = 1;

protected:
    constexpr _Ref_count_base() noexcept = default; 

public:
    _Ref_count_base(const _Ref_count_base&) = delete;
    _Ref_count_base& operator=(const _Ref_count_base&) = delete;

    virtual ~_Ref_count_base() noexcept {} 

    bool _Incref_nz() noexcept { 
        auto& _Volatile_uses = reinterpret_cast<volatile long&>(_Uses);



        long _Count = __iso_volatile_load32(reinterpret_cast<volatile int*>(&_Volatile_uses));
#line 1080 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
        while (_Count != 0) {
            const long _Old_value = _InterlockedCompareExchange(&_Volatile_uses, _Count + 1, _Count);
            if (_Old_value == _Count) {
                return true;
            }

            _Count = _Old_value;
        }

        return false;
    }

    void _Incref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Uses));
    }

    void _Incwref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Weaks));
    }

    void _Decref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Uses)) == 0) {
            _Destroy();
            _Decwref();
        }
    }

    void _Decwref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Weaks)) == 0) {
            _Delete_this();
        }
    }

    long _Use_count() const noexcept {
        return static_cast<long>(_Uses);
    }

    virtual void* _Get_deleter(const type_info&) const noexcept {
        return nullptr;
    }
};

template <class _Ty>
class _Ref_count : public _Ref_count_base { 
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) {}

private:
    void _Destroy() noexcept override { 
        delete _Ptr;
    }

    void _Delete_this() noexcept override { 
        delete this;
    }

    _Ty* _Ptr;
};

template <class _Resource, class _Dx>
class _Ref_count_resource : public _Ref_count_base { 
public:
    _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Px) {}




    ~_Ref_count_resource() noexcept override = default; 
#line 1150 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

        return nullptr;
    }

private:
    void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2);
    }

    void _Delete_this() noexcept override { 
        delete this;
    }

    _Compressed_pair<_Dx, _Resource> _Mypair;
};

template <class _Resource, class _Dx, class _Alloc>
class _Ref_count_resource_alloc : public _Ref_count_base {
    
public:
    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(),
          _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _One_then_variadic_args_t{}, _Ax, _Px) {}




    ~_Ref_count_resource_alloc() noexcept override = default; 
#line 1188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

        return nullptr;
    }

private:
    using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

    void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2._Myval2);
    }

    void _Delete_this() noexcept override { 
        _Myalty _Al = _Mypair._Myval2._Get_first();
        this->~_Ref_count_resource_alloc();
        _Deallocate_plain(_Al, this);
    }

    _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
};

template <class _Ty>
struct default_delete;

template <class _Ty, class _Dx = default_delete<_Ty>>
class unique_ptr;

template <class _Ty>
class shared_ptr;

template <class _Ty>
class weak_ptr;

template <class _Yty, class = void>
struct _Can_enable_shared : false_type {}; 

template <class _Yty>
struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*, typename _Yty::_Esft_type*>::type {
    
};

struct _Exception_ptr_access;

template <class _Ty>
class _Ptr_base { 
public:
    using element_type = remove_extent_t<_Ty>;

    [[nodiscard]] long use_count() const noexcept {
        return _Rep ? _Rep->_Use_count() : 0;
    }

    template <class _Ty2>
    [[nodiscard]] bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept { 
        return _Rep < _Right._Rep;
    }

    _Ptr_base(const _Ptr_base&) = delete;
    _Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
    [[nodiscard]] element_type* get() const noexcept {
        return _Ptr;
    }

    constexpr _Ptr_base() noexcept = default;

    ~_Ptr_base() = default;

    template <class _Ty2>
    void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
        
        _Ptr = _Right._Ptr;
        _Rep = _Right._Rep;

        _Right._Ptr = nullptr;
        _Right._Rep = nullptr;
    }

    template <class _Ty2>
    void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
        
        _Other._Incref();

        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
        
        _Other._Incref();

        _Ptr = _Px;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
        
        _Ptr = _Px;
        _Rep = _Other._Rep;

        _Other._Ptr = nullptr;
        _Other._Rep = nullptr;
    }

    template <class _Ty0>
    friend class weak_ptr; 

    template <class _Ty2>
    bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep && _Other._Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            return true;
        }

        return false;
    }

    void _Incref() const noexcept {
        if (_Rep) {
            _Rep->_Incref();
        }
    }

    void _Decref() noexcept { 
        if (_Rep) {
            _Rep->_Decref();
        }
    }

    void _Swap(_Ptr_base& _Right) noexcept { 
        ::std:: swap(_Ptr, _Right._Ptr);
        ::std:: swap(_Rep, _Right._Rep);
    }

    template <class _Ty2>
    void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { 
        if (_Other._Rep) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            _Rep->_Incwref();
        } else {
            ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_lvalue_avoiding_expired_conversions(const _Ptr_base<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep) {
            _Rep = _Other._Rep; 
            _Rep->_Incwref();

            if (_Rep->_Incref_nz()) {
                _Ptr = _Other._Ptr; 
                _Rep->_Decref();
            } else {
                ;
            }
        } else {
            ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base<_Ty2>&& _Other) noexcept {
        
        _Rep        = _Other._Rep; 
        _Other._Rep = nullptr;

        if (_Rep && _Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr; 
            _Rep->_Decref();
        } else {
            ;
        }

        _Other._Ptr = nullptr;
    }

    void _Incwref() const noexcept {
        if (_Rep) {
            _Rep->_Incwref();
        }
    }

    void _Decwref() noexcept { 
        if (_Rep) {
            _Rep->_Decwref();
        }
    }

private:
    element_type* _Ptr{nullptr};
    _Ref_count_base* _Rep{nullptr};

    template <class _Ty0>
    friend class _Ptr_base;

    friend shared_ptr<_Ty>;

    template <class _Ty0>
    friend struct atomic;

    friend _Exception_ptr_access;


    template <class _Dx, class _Ty0>
    friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
#line 1411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
};

template <class _Yty, class = void>
struct _Can_scalar_delete : false_type {};
template <class _Yty>
struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std:: declval<_Yty*>())>> : true_type {};

template <class _Yty, class = void>
struct _Can_array_delete : false_type {};
template <class _Yty>
struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std:: declval<_Yty*>())>> : true_type {};

template <class _Fx, class _Arg, class = void>
struct _Can_call_function_object : false_type {};
template <class _Fx, class _Arg>
struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std:: declval<_Fx>()(::std:: declval<_Arg>()))>> : true_type {};

template <class _Yty, class _Ty>
struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type {};
template <class _Yty, class _Uty>
struct _SP_convertible<_Yty, _Uty[]> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {};
template <class _Yty, class _Uty, size_t _Ext>
struct _SP_convertible<_Yty, _Uty[_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {};

template <class _Yty, class _Ty>
struct _SP_pointer_compatible : is_convertible<_Yty*, _Ty*>::type {
    
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]> : true_type {
    
};

template <class _Ux>
struct _Temporary_owner {
    _Ux* _Ptr;

    explicit _Temporary_owner(_Ux* const _Ptr_) noexcept : _Ptr(_Ptr_) {}
    _Temporary_owner(const _Temporary_owner&) = delete;
    _Temporary_owner& operator=(const _Temporary_owner&) = delete;
    ~_Temporary_owner() {
        delete _Ptr;
    }
};

template <class _UxptrOrNullptr, class _Dx>
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx& _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del(const _UxptrOrNullptr _Ptr_, _Dx& _Dt_) noexcept : _Ptr(_Ptr_), _Dt(_Dt_) {}
    _Temporary_owner_del(const _Temporary_owner_del&) = delete;
    _Temporary_owner_del& operator=(const _Temporary_owner_del&) = delete;
    ~_Temporary_owner_del() {
        if (_Call_deleter) {
            _Dt(_Ptr);
        }
    }
};

template <class _Ty>
class shared_ptr : public _Ptr_base<_Ty> { 
private:
    using _Mybase = _Ptr_base<_Ty>;

public:
    using typename _Mybase::element_type;



#line 1496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    constexpr shared_ptr() noexcept = default;

    constexpr shared_ptr(nullptr_t) noexcept {} 

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    explicit shared_ptr(_Ux* _Px) { 
        if constexpr (is_array_v<_Ty>) {
            _Setpd(_Px, default_delete<_Ux[]>{});
        } else {
            _Temporary_owner<_Ux> _Owner(_Px);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count<_Ux>(_Owner._Ptr));
            _Owner._Ptr = nullptr;
        }
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt) { 
        _Setpd(_Px, ::std:: move(_Dt));
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(_Px, ::std:: move(_Dt), _Ax);
    }

    template <class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt) { 
        _Setpd(nullptr, ::std:: move(_Dt));
    }

    template <class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(nullptr, ::std:: move(_Dt), _Ax);
    }

    template <class _Ty2>
    shared_ptr(const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept {
        
        this->_Alias_construct_from(_Right, _Px);
    }

    template <class _Ty2>
    shared_ptr(shared_ptr<_Ty2>&& _Right, element_type* _Px) noexcept {
        
        this->_Alias_move_construct_from(::std:: move(_Right), _Px);
    }

    shared_ptr(const shared_ptr& _Other) noexcept { 
        this->_Copy_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        
        this->_Copy_construct_from(_Other);
    }

    shared_ptr(shared_ptr&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    explicit shared_ptr(const weak_ptr<_Ty2>& _Other) { 
        if (!this->_Construct_from_weak(_Other)) {
            _Throw_bad_weak_ptr();
        }
    }


    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    shared_ptr(auto_ptr<_Ty2>&& _Other) { 
        _Ty2* _Px = _Other.get();
        _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>(_Px));
        _Other.release();
    }
#line 1589 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr(unique_ptr<_Ux, _Dx>&& _Other) {
        using _Fancy_t   = typename unique_ptr<_Ux, _Dx>::pointer;
        using _Raw_t     = typename unique_ptr<_Ux, _Dx>::element_type*;
        using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std:: ref(_Other.get_deleter())), _Dx>;

        const _Fancy_t _Fancy = _Other.get();

        if (_Fancy) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx =
                new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, ::std:: forward<_Dx>(_Other.get_deleter()));
            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
            _Other.release();
        }
    }

    ~shared_ptr() noexcept { 
        this->_Decref();
    }

    shared_ptr& operator=(const shared_ptr& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2>
    shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }


    template <class _Ty2>
    shared_ptr& operator=(auto_ptr<_Ty2>&& _Right) {
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
#line 1643 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    template <class _Ux, class _Dx>
    shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right) { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    void swap(shared_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    void reset() noexcept { 
        shared_ptr().swap(*this);
    }

    template <class _Ux>
    void reset(_Ux* _Px) { 
        shared_ptr(_Px).swap(*this);
    }

    template <class _Ux, class _Dx>
    void reset(_Ux* _Px, _Dx _Dt) { 
        shared_ptr(_Px, _Dt).swap(*this);
    }

    template <class _Ux, class _Dx, class _Alloc>
    void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        shared_ptr(_Px, _Dt, _Ax).swap(*this);
    }

    using _Mybase::get;

    template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
    [[nodiscard]] _Ty2& operator*() const noexcept {
        return *get();
    }

    template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Ty2* operator->() const noexcept {
        return get();
    }

    template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Elem& operator[](ptrdiff_t _Idx) const noexcept  {
        return get()[_Idx];
    }


     [[nodiscard]] bool unique() const noexcept {
        
        return this->use_count() == 1;
    }
#line 1696 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    explicit operator bool() const noexcept {
        return get() != nullptr;
    }

private:
    template <class _UxptrOrNullptr, class _Dx>
    void _Setpd(const _UxptrOrNullptr _Px, _Dx _Dt) { 
        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Set_ptr_rep_and_enable_shared(
            _Owner._Ptr, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Owner._Ptr, ::std:: move(_Dt)));
        _Owner._Call_deleter = false;
    }

    template <class _UxptrOrNullptr, class _Dx, class _Alloc>
    void _Setpda(const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) { 
        using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>>;

        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Alref_alloc _Alref(_Ax);
        _Alloc_construct_ptr<_Alref_alloc> _Constructor(_Alref);
        _Constructor._Allocate();
        _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, ::std:: move(_Dt), _Ax);
        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));
        _Constructor._Ptr    = nullptr;
        _Owner._Call_deleter = false;
    }


































#line 1758 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
    template <class _Ty0, class... _Types>
    friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);

    template <class _Ty0, class _Alloc, class... _Types>
    friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);
#line 1764 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = _Px;
        this->_Rep = _Rx;
        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }
    }

    void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = nullptr;
        this->_Rep = _Rx;
    }
};







#line 1789 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() == _Right.get();
}






#line 1801 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() != _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() < _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() >= _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() > _Right.get();
}

template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <= _Right.get();
}
#line 1826 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty>
[[nodiscard]] bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() == nullptr;
}






#line 1838 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
template <class _Ty>
[[nodiscard]] bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr == _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() != nullptr;
}

template <class _Ty>
[[nodiscard]] bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr != _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() < static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) < _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) >= _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() > static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) > _Right.get();
}

template <class _Ty>
[[nodiscard]] bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
[[nodiscard]] bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) <= _Right.get();
}
#line 1893 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px) {
    
    return _Out << _Px.get();
}

template <class _Ty>
void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}


template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    return {};
}

template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
    }

    return {};
}





#line 1977 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"


template <class _Dx, class _Ty>
[[nodiscard]] _Dx* get_deleter(const shared_ptr<_Ty>& _Sx) noexcept {
    
    if (_Sx._Rep) {
        return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
    }

    return nullptr;
}



#line 1992 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"





#line 1998 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty>
class _Ref_count_obj2 : public _Ref_count_base { 
public:
    template <class... _Types>
    explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {





#line 2010 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
        {
            _Construct_in_place(_Storage._Value, ::std:: forward<_Types>(_Args)...);
        }
    }

    ~_Ref_count_obj2() noexcept override { 
        

        
        
        
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    void _Destroy() noexcept override { 
        _Destroy_in_place(_Storage._Value);
    }

    void _Delete_this() noexcept override { 
        delete this;
    }
};






















































































































































































































































































































































#line 2379 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
class _Ebco_base : private _Ty { 
private:
    using _Mybase = _Ty; 

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return *this;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return *this;
    }
};

template <class _Ty>
class _Ebco_base<_Ty, false> { 
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return _Myval;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return _Myval;
    }
};

template <class _Ty, class _Alloc>
class _Ref_count_obj_alloc3 : public _Ebco_base<_Rebind_alloc_t<_Alloc, _Ty>>, public _Ref_count_base {
    
private:
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Rebound = _Rebind_alloc_t<_Alloc, _Ty>;

public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc3(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() {





#line 2437 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
        {
            allocator_traits<_Rebound>::construct(
                this->_Get_val(), ::std:: addressof(_Storage._Value), ::std:: forward<_Types>(_Args)...);
        }
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_obj_alloc3() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        allocator_traits<_Rebound>::destroy(this->_Get_val(), ::std:: addressof(_Storage._Value));
    }

    void _Delete_this() noexcept override { 
        _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc3> _Al(this->_Get_val());
        this->~_Ref_count_obj_alloc3();
        _Deallocate_plain(_Al, this);
    }
};

























































































































































































































































#line 2714 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty, class... _Types>
[[nodiscard]]


#line 2720 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
    shared_ptr<_Ty>
#line 2722 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
    make_shared(_Types&&... _Args) { 
    const auto _Rx = new _Ref_count_obj2<_Ty>(::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(::std:: addressof(_Rx->_Storage._Value), _Rx);
    return _Ret;
}














































































#line 2807 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty, class _Alloc, class... _Types>
[[nodiscard]]


#line 2813 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
    shared_ptr<_Ty>
#line 2815 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
    allocate_shared(const _Alloc& _Al, _Types&&... _Args) { 
    
    
    using _Refoa   = _Ref_count_obj_alloc3<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr<_Alblock> _Constructor{_Rebound};
    _Constructor._Allocate();
    _Construct_in_place(*_Constructor._Ptr, _Al, ::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = reinterpret_cast<_Ty*>(::std:: addressof(_Constructor._Ptr->_Storage._Value));
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    return _Ret;
}




















































































































#line 2946 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty>
class weak_ptr : public _Ptr_base<_Ty> { 
public:
    constexpr weak_ptr() noexcept {}

    weak_ptr(const weak_ptr& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept {
        this->_Weakly_convert_lvalue_avoiding_expired_conversions(_Other);
    }

    weak_ptr(weak_ptr&& _Other) noexcept {
        this->_Move_construct_from(::std:: move(_Other));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept {
        this->_Weakly_convert_rvalue_avoiding_expired_conversions(::std:: move(_Other));
    }

    ~weak_ptr() noexcept {
        this->_Decwref();
    }

    weak_ptr& operator=(const weak_ptr& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    weak_ptr& operator=(weak_ptr&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2>
    weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    void reset() noexcept { 
        weak_ptr{}.swap(*this);
    }

    void swap(weak_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    [[nodiscard]] bool expired() const noexcept {
        return this->use_count() == 0;
    }

    [[nodiscard]] shared_ptr<_Ty> lock() const noexcept { 
        shared_ptr<_Ty> _Ret;
        (void) _Ret._Construct_from_weak(*this);
        return _Ret;
    }
};




#line 3030 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty>
void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _Ty>
class enable_shared_from_this { 
public:
    using _Esft_type = enable_shared_from_this;

    [[nodiscard]] shared_ptr<_Ty> shared_from_this() {
        return shared_ptr<_Ty>(_Wptr);
    }

    [[nodiscard]] shared_ptr<const _Ty> shared_from_this() const {
        return shared_ptr<const _Ty>(_Wptr);
    }

    [[nodiscard]] weak_ptr<_Ty> weak_from_this() noexcept {
        return _Wptr;
    }

    [[nodiscard]] weak_ptr<const _Ty> weak_from_this() const noexcept {
        return _Wptr;
    }

protected:
    constexpr enable_shared_from_this() noexcept : _Wptr() {}

    enable_shared_from_this(const enable_shared_from_this&) noexcept : _Wptr() {
        
    }

    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { 
        return *this;
    }

    ~enable_shared_from_this() = default;

private:
    template <class _Yty>
    friend class shared_ptr;

    mutable weak_ptr<_Ty> _Wptr;
};


template <class _Ty>
struct default_delete { 
    constexpr default_delete() noexcept = default;

    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    default_delete(const default_delete<_Ty2>&) noexcept {}

    void operator()(_Ty* _Ptr) const noexcept  { 
        static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
        delete _Ptr;
    }
};

template <class _Ty>
struct default_delete<_Ty[]> { 
    constexpr default_delete() noexcept = default;

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    default_delete(const default_delete<_Uty[]>&) noexcept {}

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    void operator()(_Uty* _Ptr) const noexcept  { 
        static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
        delete[] _Ptr;
    }
};

template <class _Ty, class _Dx_noref, class = void>
struct _Get_deleter_pointer_type { 
    using type = _Ty*;
};

template <class _Ty, class _Dx_noref>
struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>> { 
    using type = typename _Dx_noref::pointer;
};

template <class _Dx2>
using _Unique_ptr_enable_default_t =
    enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;

template <class _Ty, class _Dx >
class unique_ptr { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
    unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Dx2                                                                            = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
    unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Dx2                                                                                      = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Ty2, class _Dx2,
        enable_if_t<
            conjunction_v<negation<is_array<_Ty2>>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
                conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
            int> = 0>
    unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}


    template <class _Ty2,
        enable_if_t<conjunction_v<is_convertible<_Ty2*, _Ty*>, is_same<_Dx, default_delete<_Ty>>>, int> = 0>
    unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Right.release()) {}
#line 3168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

    template <class _Ty2, class _Dx2,
        enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>,
                        is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>,
            int> = 0>
    unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Dx2>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: forward<_Dx>(_Right._Mypair._Get_first());
        }
        return *this;
    }

    void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] add_lvalue_reference_t<_Ty> operator*() const noexcept  {
        return *_Mypair._Myval2;
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return _Mypair._Myval2;
    }

    [[nodiscard]] pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    void reset(pointer _Ptr = nullptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

template <class _Ty, class _Dx>
class unique_ptr<_Ty[], _Dx> { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
    using _Enable_ctor_reset =
        enable_if_t<is_same_v<_Uty, pointer> 
                    || _Is_nullptr::value 
                    || (is_same_v<pointer, element_type*> 
                        && is_pointer_v<_Uty> 
                        && is_convertible_v<remove_pointer_t<_Uty> (*)[], element_type (*)[]>)>; 

    template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, class = _Enable_ctor_reset<_Uty>>
    explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: move(_Right._Mypair._Get_first());
        }

        return *this;
    }

    template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
        class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
    using _Enable_conversion = enable_if_t<
        conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>, is_same<_UP_pointer, _UP_element_type*>,
            is_convertible<_UP_element_type (*)[], element_type (*)[]>, _More>>; 

    template <class _Uty, class _Ex,
        class = _Enable_conversion<_Uty, _Ex,
            conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>>>
    unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Ex>(_Right.get_deleter()), _Right.release()) {}

    template <class _Uty, class _Ex, class = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>>>
    unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Ex>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    void reset(nullptr_t = nullptr) noexcept {
        reset(pointer());
    }

    void swap(unique_ptr& _Right) noexcept {
        _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
        _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
    }

    ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] _Ty& operator[](size_t _Idx) const noexcept  {
        return _Mypair._Myval2[_Idx];
    }

    [[nodiscard]] pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    template <class _Uty, class = _Enable_ctor_reset<_Uty, false_type>>
    void reset(_Uty _Ptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};


template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
[[nodiscard]] unique_ptr<_Ty> make_unique(_Types&&... _Args) { 
    return unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...));
}

template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
[[nodiscard]] unique_ptr<_Ty> make_unique(const size_t _Size) { 
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]());
}

template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
void make_unique(_Types&&...) = delete;
















#line 3407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Left.get() == _Right.get();
}


template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left == _Right);
}
#line 3424 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    using _Ptr1   = typename unique_ptr<_Ty1, _Dx1>::pointer;
    using _Ptr2   = typename unique_ptr<_Ty2, _Dx2>::pointer;
    using _Common = common_type_t<_Ptr1, _Ptr2>;
    return less<_Common>{}(_Left.get(), _Right.get());
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left < _Right);
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Right < _Left;
}

template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Right < _Left);
}














template <class _Ty, class _Dx>
[[nodiscard]] bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept {
    return !_Left;
}


template <class _Ty, class _Dx>
[[nodiscard]] bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept {
    return !_Right;
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator!=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) noexcept {
    return !(_Left == _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator!=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) noexcept {
    return !(_Left == _Right);
}
#line 3482 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left.get(), _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left, _Right.get());
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Left < _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Left < _Right);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Right < _Left);
}

template <class _Ty, class _Dx>
[[nodiscard]] bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Right < _Left);
}












template <class _OutTy, class _PxTy, class = void>
struct _Can_stream_unique_ptr : false_type {};
template <class _OutTy, class _PxTy>
struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(::std:: declval<_OutTy>() << ::std:: declval<_PxTy>().get())>>
    : true_type {};

template <class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px) {
    
    _Out << _Px.get();
    return _Out;
}


enum class pointer_safety { relaxed, preferred, strict };

inline void declare_reachable(void*) {}

template <class _Ty>
_Ty* undeclare_reachable(_Ty* _Ptr) {
    return _Ptr;
}

inline void declare_no_pointers(char*, size_t) {}

inline void undeclare_no_pointers(char*, size_t) {}

inline pointer_safety get_pointer_safety() noexcept {
    return pointer_safety::relaxed;
}
#line 3568 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

template <class _Ty = void>
struct owner_less; 

template <class _Ty>
struct owner_less<shared_ptr<_Ty>> {
     typedef shared_ptr<_Ty> first_argument_type;
     typedef shared_ptr<_Ty> second_argument_type;
     typedef bool result_type;

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <class _Ty>
struct owner_less<weak_ptr<_Ty>> {
     typedef weak_ptr<_Ty> first_argument_type;
     typedef weak_ptr<_Ty> second_argument_type;
     typedef bool result_type;

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <>
struct owner_less<void> {
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    using is_transparent = int;
};

template <class _Ty, class _Dx>
struct hash<unique_ptr<_Ty, _Dx>> : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
                                        is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>> {
    static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval) noexcept(
        _Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) {
        return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
    }
};

template <class _Ty>
struct hash<shared_ptr<_Ty>> {
     typedef shared_ptr<_Ty> argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const shared_ptr<_Ty>& _Keyval) const noexcept {
        return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
    }
};

inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept  {
    
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; 
    }

    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }

    
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}











#line 3682 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}

struct _Shared_ptr_spin_lock { 
    _Shared_ptr_spin_lock() { 
        _Lock_shared_ptr_spin_lock();
    }

    ~_Shared_ptr_spin_lock() noexcept { 
        _Unlock_shared_ptr_spin_lock();
    }
};

template <class _Ty>
 [[nodiscard]] bool atomic_is_lock_free(const shared_ptr<_Ty>*) {
    
    return false;
}

template <class _Ty>
 [[nodiscard]] shared_ptr<_Ty> atomic_load_explicit(
    const shared_ptr<_Ty>* _Ptr, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    shared_ptr<_Ty> _Result = *_Ptr;
    return _Result;
}

template <class _Ty>
 [[nodiscard]] shared_ptr<_Ty> atomic_load(
    const shared_ptr<_Ty>* _Ptr) { 
    return ::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst);
}

template <class _Ty>
 void atomic_store_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
}

template <class _Ty>
 void atomic_store(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) { 
    ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

template <class _Ty>
 shared_ptr<_Ty> atomic_exchange_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
    return _Other;
}

template <class _Ty>
 shared_ptr<_Ty> atomic_exchange(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) {
    
    return ::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

template <class _Ty>
 bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    shared_ptr<_Ty> _Old_exp; 
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
    if (_Success) {
        _Ptr->swap(_Value);
    } else { 
        _Exp->swap(_Old_exp);
        *_Exp = *_Ptr;
    }
    return _Success;
}

template <class _Ty>
 bool atomic_compare_exchange_weak(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

template <class _Ty>
 bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

template <class _Ty>
 bool atomic_compare_exchange_strong(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_strong_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}











































































































































































































































































#line 4054 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"


































































































































































































#line 4249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: allocate_shared;
    using ::std:: bad_weak_ptr;
    using ::std:: const_pointer_cast;
    using ::std:: dynamic_pointer_cast;
    using ::std:: enable_shared_from_this;
    using ::std:: get_deleter;
    using ::std:: make_shared;
    using ::std:: shared_ptr;
    using ::std:: static_pointer_cast;
    using ::std:: swap;
    using ::std:: weak_ptr;
} 
#line 4265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"

}


#pragma warning(pop)
#pragma pack(pop)
#line 4272 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
#line 4273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\memory"
#pragma external_header(pop)
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplinterface.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"





#pragma once















#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xthreads.h"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtimec.h"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ctime"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"
















  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int* __cdecl __daylight(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __dstbias(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __timezone(void);




    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char** __cdecl __tzname(void);



  
__declspec(dllimport) errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
__declspec(dllimport) errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
__declspec(dllimport) errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
__declspec(dllimport) errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );








 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
    __declspec(dllimport) errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

 
__declspec(dllimport) clock_t __cdecl clock(void);

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(  char (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

 
__declspec(dllimport) double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
__declspec(dllimport) double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

__declspec(dllimport) size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl _strdate( char *_Buffer);
#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"


__declspec(dllimport) errno_t __cdecl _strtime_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

__declspec(dllimport) __time32_t __cdecl _time32(
      __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
__declspec(dllimport) int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
__declspec(dllimport) int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );










    __declspec(dllimport) void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );

#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"










    


































































































          __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            return _ctime64(_Time);
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            return _gmtime64(_Time);
        }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            return _localtime64(_Time);
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

    #line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

#line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"










    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
    #line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"

#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\time.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ctime"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
using :: clock_t;
using :: size_t;
using :: time_t;
using :: tm;
using :: asctime;
using :: clock;
using :: ctime;
using :: difftime;
using :: gmtime;
using :: localtime;
using :: mktime;
using :: strftime;
using :: time;



#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ctime"
}



#pragma warning(pop)
#pragma pack(pop)

#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ctime"
#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ctime"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtimec.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




extern "C" {

struct xtime { 
    __time64_t sec;
    long nsec;
};

 int __cdecl xtime_get(xtime*, int);

 long __cdecl _Xtime_diff_to_millis(const xtime*);
 long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime*);
 long long __cdecl _Xtime_get_ticks();

 long long __cdecl _Query_perf_counter();
 long long __cdecl _Query_perf_frequency();

}



#pragma warning(pop)
#pragma pack(pop)
#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtimec.h"
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xtimec.h"
















#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xthreads.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




extern "C" {
using _Thrd_id_t = unsigned int;
struct _Thrd_t { 
    void* _Hnd; 
    _Thrd_id_t _Id;
};

























#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xthreads.h"
#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xthreads.h"

using _Mtx_t = struct _Mtx_internal_imp_t*;

using _Cnd_t = struct _Cnd_internal_imp_t*;

enum { _Thrd_success, _Thrd_nomem, _Thrd_timedout, _Thrd_busy, _Thrd_error };


 int __cdecl _Thrd_detach(_Thrd_t);
 int __cdecl _Thrd_join(_Thrd_t, int*);
 void __cdecl _Thrd_sleep(const xtime*);
 void __cdecl _Thrd_yield();
 unsigned int __cdecl _Thrd_hardware_concurrency();
 _Thrd_id_t __cdecl _Thrd_id();


enum { 
    _Mtx_plain     = 0x01,
    _Mtx_try       = 0x02,
    _Mtx_timed     = 0x04,
    _Mtx_recursive = 0x100
};

 int __cdecl _Mtx_init(_Mtx_t*, int);
 void __cdecl _Mtx_destroy(_Mtx_t);
 void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
 void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
 int __cdecl _Mtx_current_owns(_Mtx_t);
 int __cdecl _Mtx_lock(_Mtx_t);
 int __cdecl _Mtx_trylock(_Mtx_t);
 int __cdecl _Mtx_timedlock(_Mtx_t, const xtime*);
 int __cdecl _Mtx_unlock(_Mtx_t); 

 void* __cdecl _Mtx_getconcrtcs(_Mtx_t);
 void __cdecl _Mtx_clear_owner(_Mtx_t);
 void __cdecl _Mtx_reset_owner(_Mtx_t);



using _Smtx_t = void*;
void __cdecl _Smtx_lock_exclusive(_Smtx_t*);
void __cdecl _Smtx_lock_shared(_Smtx_t*);
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t*);
int __cdecl _Smtx_try_lock_shared(_Smtx_t*);
void __cdecl _Smtx_unlock_exclusive(_Smtx_t*);
void __cdecl _Smtx_unlock_shared(_Smtx_t*);


 int __cdecl _Cnd_init(_Cnd_t*);
 void __cdecl _Cnd_destroy(_Cnd_t);
 void __cdecl _Cnd_init_in_situ(_Cnd_t);
 void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
 int __cdecl _Cnd_wait(_Cnd_t, _Mtx_t); 
 int __cdecl _Cnd_timedwait(_Cnd_t, _Mtx_t, const xtime*);
 int __cdecl _Cnd_broadcast(_Cnd_t); 
 int __cdecl _Cnd_signal(_Cnd_t); 
 void __cdecl _Cnd_register_at_thread_exit(_Cnd_t, _Mtx_t, int*);
 void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
 void __cdecl _Cnd_do_broadcast_at_thread_exit();
}

namespace std {
enum { 
    _DEVICE_OR_RESOURCE_BUSY,
    _INVALID_ARGUMENT,
    _NO_SUCH_PROCESS,
    _NOT_ENOUGH_MEMORY,
    _OPERATION_NOT_PERMITTED,
    _RESOURCE_DEADLOCK_WOULD_OCCUR,
    _RESOURCE_UNAVAILABLE_TRY_AGAIN
};

[[noreturn]]  void __cdecl _Throw_C_error(int _Code);
[[noreturn]]  void __cdecl _Throw_Cpp_error(int _Code);

inline int _Check_C_return(int _Res) { 
    if (_Res != _Thrd_success) {
        _Throw_C_error(_Res);
    }

    return _Res;
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 142 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xthreads.h"
#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xthreads.h"
















#pragma external_header(pop)
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )









#line 38 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"




#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"






#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#line 51 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"




#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"





extern "C" [[nodiscard]] unsigned char __stdcall __std_atomic_compare_exchange_128(
      long long* _Destination,   long long _ExchangeHigh,   long long _ExchangeLow,
      long long* _ComparandResult) noexcept;
extern "C" [[nodiscard]] char __stdcall __std_atomic_has_cmpxchg16b() noexcept;

#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"




#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"


























#line 102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"















extern "C" {
_Smtx_t* __stdcall __std_atomic_get_mutex(const void* _Key) noexcept;
}





#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

namespace std {



#line 134 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty>
struct _Storage_for {
    
    alignas(_Ty) unsigned char _Storage[sizeof(_Ty)];

    _Storage_for()                    = default;
    _Storage_for(const _Storage_for&) = delete;
    _Storage_for& operator=(const _Storage_for&) = delete;






#line 150 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    [[nodiscard]] _Ty& _Ref() noexcept {
        return reinterpret_cast<_Ty&>(_Storage);
    }

    [[nodiscard]] _Ty* _Ptr() noexcept {
        return reinterpret_cast<_Ty*>(&_Storage);
    }
};





#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

extern "C" inline void atomic_thread_fence(const memory_order _Order) noexcept {
    if (_Order == memory_order_relaxed) {
        return;
    }


    __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    if (_Order == memory_order_seq_cst) {
        volatile long _Guard; 

        
        
        
#pragma warning(suppress : 6001) 
#pragma warning(suppress : 28113) 
                                  
        (void) _InterlockedIncrement(&_Guard);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    }




#line 190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
}

extern "C" inline void atomic_signal_fence(const memory_order _Order) noexcept {
    if (_Order != memory_order_relaxed) {
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    }
}

template <class _Ty>
_Ty kill_dependency(_Ty _Arg) noexcept { 
    return _Arg;
}

inline void _Check_memory_order(const memory_order _Order) noexcept {
    
    if (static_cast<unsigned int>(_Order) > static_cast<unsigned int>(memory_order_seq_cst)) {
        do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 206, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 206, 0); } while (false);
    }
}

inline void _Check_store_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_release:
    case memory_order_seq_cst:
        
        break;
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_acq_rel:
    default:
        do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 221, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 221, 0); } while (false);
        break;
    }
}

inline void _Check_load_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_seq_cst:
        
        break;
    case memory_order_release:
    case memory_order_acq_rel:
    default:
        do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 237, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 237, 0); } while (false);
        break;
    }
}

[[nodiscard]] inline memory_order _Combine_cas_memory_orders(
    const memory_order _Success, const memory_order _Failure) noexcept {
    
    
    
    
    
    

    
    
    
    
    static constexpr memory_order _Combined_memory_orders[6][6] = {
        {memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_consume, memory_order_consume, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acquire, memory_order_acquire, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_release, memory_order_acq_rel, memory_order_acq_rel, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst,
            memory_order_seq_cst}};

    _Check_memory_order(_Success);
    _Check_load_memory_order(_Failure);
    return _Combined_memory_orders[static_cast<int>(_Success)][static_cast<int>(_Failure)];
}

template <class _Integral, class _Ty>
[[nodiscard]] _Integral _Atomic_reinterpret_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    if constexpr (is_integral_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return static_cast<_Integral>(_Source);
    } else if constexpr (is_pointer_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return reinterpret_cast<_Integral>(_Source);
    } else {
        _Integral _Result{}; 
        :: memcpy(&_Result, ::std:: addressof(_Source), sizeof(_Source));
        return _Result;
    }
}

inline void _Load_barrier(const memory_order _Order) noexcept { 
    switch (_Order) {
    case memory_order_relaxed:
        
        break;
    default:
    case memory_order_release:
    case memory_order_acq_rel:
        do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 297, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 297, 0); } while (false);
        
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_seq_cst:
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        break;
    }
}


template <class _Ty>
struct _Atomic_padded {
    alignas(sizeof(_Ty)) mutable _Ty _Value; 
};







































#line 352 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty>
struct _Atomic_storage_types {
    using _TStorage = _Atomic_padded<_Ty>;
    using _Spinlock = long;
};

template <class _Ty>
struct _Atomic_storage_types<_Ty&> {
    using _TStorage = _Ty&;
    using _Spinlock = _Smtx_t*; 
};


template <class _Ty, size_t = sizeof(remove_reference_t<_Ty>)>


#line 370 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
struct _Atomic_storage;




























#line 400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"


inline void _Atomic_lock_acquire(long& _Spinlock) noexcept {

    
    
    
    int _Current_backoff   = 1;
    const int _Max_backoff = 64;
    while (_InterlockedExchange(&_Spinlock, 1) != 0) {
        while (__iso_volatile_load32(&reinterpret_cast<int&>(_Spinlock)) != 0) {
            for (int _Count_down = _Current_backoff; _Count_down != 0; --_Count_down) {
                _mm_pause();
            }
            _Current_backoff = _Current_backoff < _Max_backoff ? _Current_backoff << 1 : _Max_backoff;
        }
    }








#line 426 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
}

inline void _Atomic_lock_release(long& _Spinlock) noexcept {

    _InterlockedExchange(&_Spinlock, 0); 






#line 438 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
}

inline void _Atomic_lock_acquire(_Smtx_t* _Spinlock) noexcept {
    _Smtx_lock_exclusive(_Spinlock);
}

inline void _Atomic_lock_release(_Smtx_t* _Spinlock) noexcept {
    _Smtx_unlock_exclusive(_Spinlock);
}

template <class _Spinlock_t>
class [[nodiscard]] _Atomic_lock_guard {
public:
    explicit _Atomic_lock_guard(_Spinlock_t& _Spinlock_) noexcept : _Spinlock(_Spinlock_) {
        _Atomic_lock_acquire(_Spinlock);
    }

    ~_Atomic_lock_guard() {
        _Atomic_lock_release(_Spinlock);
    }

    _Atomic_lock_guard(const _Atomic_lock_guard&) = delete;
    _Atomic_lock_guard& operator=(const _Atomic_lock_guard&) = delete;

private:
    _Spinlock_t& _Spinlock;
};
























#line 490 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#line 491 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty, size_t >
struct _Atomic_storage {
    
    

    using _TVal  = remove_reference_t<_Ty>;
    using _Guard = _Atomic_lock_guard<typename _Atomic_storage_types<_Ty>::_Spinlock>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage(_Value) {
        
    }

    void store(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_store_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _Storage = _Value;
    }

    [[nodiscard]] _TVal load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        
        _Check_load_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _TVal _Local(_Storage);
        return _Local;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _TVal _Result(_Storage);
        _Storage = _Value;
        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Check_memory_order(_Order);
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        bool _Result;


#line 540 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Guard _Lock{_Spinlock};










#line 552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Result = :: memcmp(_Storage_ptr, _Expected_ptr, sizeof(_TVal)) == 0;
#line 554 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        if (_Result) {
            :: memcpy(_Storage_ptr, ::std:: addressof(_Desired), sizeof(_TVal));
        } else {
            :: memcpy(_Expected_ptr, _Storage_ptr, sizeof(_TVal));
        }

        return _Result;
    }













































#line 608 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"


protected:
    void _Init_spinlock_for_ref() noexcept {
        _Spinlock = __std_atomic_get_mutex(::std:: addressof(_Storage));
    }

private:
    
    mutable typename _Atomic_storage_types<_Ty>::_Spinlock _Spinlock{};

public:
    _Ty _Storage{};




#line 626 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
};

template <class _Ty>
struct _Atomic_storage<_Ty, 1> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);




#line 648 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        (void) _InterlockedExchange8(_Mem, _As_bytes);
#line 650 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store8(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store8(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 667, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 667, 0); } while (false);
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes  = __iso_volatile_load8(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes  = __iso_volatile_load8(_Mem);
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        char _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Value));
#line 694 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        char _Expected_bytes = _Atomic_reinterpret_as<char>(_Expected); 
        char _Prev_bytes;




















#line 722 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Desired), _Expected_bytes);
#line 724 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        reinterpret_cast<char&>(_Expected) = _Prev_bytes;
        return false;
    }













#line 745 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 2> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);




#line 769 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        (void) _InterlockedExchange16(_Mem, _As_bytes);
#line 771 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store16(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store16(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 788, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 788, 0); } while (false);
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes = __iso_volatile_load16(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes = __iso_volatile_load16(_Mem);
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        short _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Value));
#line 815 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        short _Expected_bytes = _Atomic_reinterpret_as<short>(_Expected); 
        short _Prev_bytes;



















#line 842 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Desired), _Expected_bytes);
#line 844 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_Ty));
        return false;
    }













#line 865 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 4> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 




#line 887 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        (void) _InterlockedExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Value));
#line 889 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem     = _Atomic_address_as<int>(_Storage);
        const int _As_bytes = _Atomic_reinterpret_as<int>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store32(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store32(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 906, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 906, 0); } while (false);
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        auto _As_bytes  = __iso_volatile_load32(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        auto _As_bytes  = __iso_volatile_load32(_Mem);
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Value));
#line 933 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long _Expected_bytes = _Atomic_reinterpret_as<long>(_Expected); 
        long _Prev_bytes;



















#line 960 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Desired), _Expected_bytes);
#line 962 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }













#line 983 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 8> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);




#line 1007 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"



#line 1011 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        (void) _InterlockedExchange64(_Mem, _As_bytes);
#line 1013 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);
        switch (_Order) {
        case memory_order_relaxed:
            __iso_volatile_store64(_Mem, _As_bytes);
            return;
        case memory_order_release:
            __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
            __iso_volatile_store64(_Mem, _As_bytes);
            return;
        default:
        case memory_order_consume:
        case memory_order_acquire:
        case memory_order_acq_rel:
            do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 1030, 0, "%s", "Invalid memory order")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Invalid memory order\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic", 1030, 0); } while (false);
            
        case memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);
        long long _As_bytes;




        _As_bytes = __iso_volatile_load64(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
#line 1048 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);



        long long _As_bytes = __iso_volatile_load64(_Mem);
#line 1058 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Load_barrier(_Order);
        return reinterpret_cast<_TVal&>(_As_bytes);
    }











    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long long _As_bytes;
        _Check_memory_order(_Order); _As_bytes = _InterlockedExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Value));
#line 1077 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }
#line 1080 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long long _Expected_bytes = _Atomic_reinterpret_as<long long>(_Expected); 
        long long _Prev_bytes;





















#line 1107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Check_memory_order(_Order); _Prev_bytes = _InterlockedCompareExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Desired), _Expected_bytes);
#line 1109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }













#line 1130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};


template <class _Ty>
struct _Atomic_storage<_Ty&, 16> { 
    
    using _TVal = remove_reference_t<_Ty&>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty&>, _Ty&, const _TVal> _Value) noexcept
        : _Storage{_Value} {} 

    void store(const _TVal _Value) noexcept { 
        (void) exchange(_Value);
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        _Check_store_memory_order(_Order);
        (void) exchange(_Value, _Order);
    }

    [[nodiscard]] _TVal load() const noexcept { 
        long long* const _Storage_ptr = const_cast<long long*>(_Atomic_address_as<const long long>(_Storage));
        _Int128 _Result{}; 
        (void) __std_atomic_compare_exchange_128(_Storage_ptr, 0, 0, &_Result._Low);
        return reinterpret_cast<_TVal&>(_Result);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 






















#line 1185 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Check_load_memory_order(_Order);
        return load();
#line 1188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
    }

    _TVal exchange(const _TVal _Value) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value)) { 
        }

        return _Result;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value, _Order)) { 
        }

        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Int128 _Desired_bytes{};
        :: memcpy(&_Desired_bytes, ::std:: addressof(_Desired), sizeof(_TVal));
        _Int128 _Expected_temp{};
        :: memcpy(&_Expected_temp, ::std:: addressof(_Expected), sizeof(_TVal));
        unsigned char _Result;


































#line 1248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"



#line 1252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        (void) _Order;
        _Result = __std_atomic_compare_exchange_128(
            &reinterpret_cast<long long&>(_Storage), _Desired_bytes._High, _Desired_bytes._Low, &_Expected_temp._Low);
#line 1256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        if (_Result == 0) {
            :: memcpy(::std:: addressof(_Expected), &_Expected_temp, sizeof(_TVal));
        }

        return _Result != 0;
    }







































#line 1302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    struct _Int128 {
        alignas(16) long long _Low;
        long long _High;
    };

    typename _Atomic_storage_types<_Ty&>::_TStorage _Storage;
};
#line 1311 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty, size_t = sizeof(_Ty)>
struct _Atomic_integral; 

template <class _Ty>
struct _Atomic_integral<_Ty, 1> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1327 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1332 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1353 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
    }

    _TVal operator++() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
        ++_Before;
        return static_cast<_TVal>(_Before);
    }

    _TVal operator--(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
    }

    _TVal operator--() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
        --_Before;
        return static_cast<_TVal>(_Before);
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 2> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1391 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1410 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 4> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1455 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1460 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1467 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1474 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1481 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 8> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;






    using _Base::_Base;
#line 1519 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"























































    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1578 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedAnd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1585 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedOr64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1592 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(_Order); _Result = _InterlockedXor64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1599 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
    }
#line 1624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
};


template <size_t _TypeSize>
 constexpr bool _Is_always_lock_free = _TypeSize <= 8 && (_TypeSize & (_TypeSize - 1)) == 0;








#line 1638 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty, bool _Is_lock_free = _Is_always_lock_free<sizeof(_Ty)>>
 constexpr bool _Deprecate_non_lock_free_volatile = true;

template <class _Ty>
  constexpr bool _Deprecate_non_lock_free_volatile<_Ty, false> = true;

template <class _Ty>
struct _Atomic_integral_facade : _Atomic_integral<_Ty> {
    
    using _Base           = _Atomic_integral<_Ty>;
    using difference_type = _Ty;





    using _Base::_Base;
#line 1657 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    

    
    
    
    using _Base::fetch_add;
    _Ty fetch_add(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_sub(const _Ty _Operand) noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand) volatile noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    using _Base::fetch_and;
    _Ty fetch_and(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    using _Base::fetch_or;
    _Ty fetch_or(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    using _Base::fetch_xor;
    _Ty fetch_xor(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    using _Base::operator++;
    _Ty operator++(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    using _Base::operator--;
    _Ty operator--(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator+=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty operator-=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->fetch_sub(_Operand) - _Operand);
    }

    _Ty operator&=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator&=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator|=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_xor(_Operand) ^ _Operand);
    }

    _Ty operator^=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand) ^ _Operand);
    }
};

template <class _Ty>
struct _Atomic_integral_facade<_Ty&> : _Atomic_integral<_Ty&> {
    
    using _Base           = _Atomic_integral<_Ty&>;
    using difference_type = _Ty;





    using _Base::_Base;
#line 1790 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_add(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    _Ty fetch_sub(const _Ty _Operand) const noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) const noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty operator++(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    _Ty operator--(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty fetch_and(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    _Ty fetch_or(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    _Ty fetch_xor(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    _Ty operator&=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_xor(_Operand) ^ _Operand);
    }
};




































































































#line 1972 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty>
struct _Atomic_pointer : _Atomic_storage<_Ty> {
    using _Base           = _Atomic_storage<_Ty>;
    using difference_type = ptrdiff_t;





    using _Base::_Base;
#line 1984 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 1993 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes);
#line 1995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#line 1996 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    

    _Ty fetch_add(const ptrdiff_t _Diff) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff);
    }

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff, _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) volatile noexcept {
        return fetch_add(1);
    }

    _Ty operator++(int) noexcept {
        return fetch_add(1);
    }

    _Ty operator++() volatile noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator++() noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) volatile noexcept {
        return fetch_add(-1);
    }

    _Ty operator--(int) noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() volatile noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator--() noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator+=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};


template <class _Ty>
struct _Atomic_pointer<_Ty&> : _Atomic_storage<_Ty&> {
    using _Base           = _Atomic_storage<_Ty&>;
    using difference_type = ptrdiff_t;





    using _Base::_Base;
#line 2086 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) const noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 2095 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        _Check_memory_order(_Order); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes);
#line 2097 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#line 2098 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) const noexcept {
        return fetch_add(1);
    }

    _Ty operator++() const noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) const noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() const noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};





template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base2_t =
    typename _Select<is_integral_v<_TVal> && !is_same_v<bool, _TVal>>::template _Apply<_Atomic_integral_facade<_Ty>,
        typename _Select<is_pointer_v<_TVal> && is_object_v<remove_pointer_t<_TVal>>>::template _Apply<
            _Atomic_pointer<_Ty>, _Atomic_storage<_Ty>>>;





#line 2149 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base_t = _Choose_atomic_base2_t<_TVal, _Ty>;
#line 2152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty>
struct atomic : _Choose_atomic_base_t<_Ty> { 
private:
    using _Base = _Choose_atomic_base_t<_Ty>;

public:
    
    static_assert(is_trivially_copyable_v<_Ty> && is_copy_constructible_v<_Ty> && is_move_constructible_v<_Ty>
        && is_copy_assignable_v<_Ty> && is_move_assignable_v<_Ty>,
        "atomic<T> requires T to be trivially copyable, copy constructible, move constructible, copy assignable, "
        "and move assignable.");
    

    using value_type = _Ty;




    using _Base::_Base;
#line 2173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    constexpr atomic() noexcept(is_nothrow_default_constructible_v<_Ty>) : _Base() {}

    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;



#line 2182 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"


    [[nodiscard]] bool is_lock_free() const volatile noexcept {
        constexpr bool _Result = sizeof(_Ty) <= 8 && (sizeof(_Ty) & sizeof(_Ty) - 1) == 0;
        return _Result;
    }










#line 2199 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    [[nodiscard]] bool is_lock_free() const noexcept {
        return static_cast<const volatile atomic*>(this)->is_lock_free();
    }

    _Ty operator=(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        this->store(_Value);
        return _Value;
    }

    _Ty operator=(const _Ty _Value) noexcept {
        this->store(_Value);
        return _Value;
    }

    
    
    
    
    
    using _Base::store;
    void store(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value);
    }

    void store(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value, _Order);
    }

    using _Base::load;
    [[nodiscard]] _Ty load() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load();
    }

    [[nodiscard]] _Ty load(const memory_order _Order) const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load(_Order);
    }

    using _Base::exchange;
    _Ty exchange(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value);
    }

    _Ty exchange(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value, _Order);
    }

    using _Base::compare_exchange_strong;
    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }
















#line 2321 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    operator _Ty() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->load();
    }

    operator _Ty() const noexcept {
        return this->load();
    }
};




#line 2336 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"













































































































#line 2446 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const volatile atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

template <class _Ty>
void atomic_store(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value);
}

template <class _Ty>
void atomic_store(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    _Mem->store(_Value);
}

template <class _Ty>
void atomic_store_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value, _Order);
}

template <class _Ty>
void atomic_store_explicit(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    _Mem->store(_Value, _Order);
}

template <class _Ty>
 void atomic_init(
    volatile atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

template <class _Ty>
 void atomic_init(
    atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load(const volatile atomic<_Ty>* const _Mem) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load();
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load(const atomic<_Ty>* const _Mem) noexcept {
    return _Mem->load();
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const volatile atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load(_Order);
}

template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    return _Mem->load(_Order);
}

template <class _Ty>
_Ty atomic_exchange(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value);
}

template <class _Ty>
_Ty atomic_exchange(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    return _Mem->exchange(_Value);
}

template <class _Ty>
_Ty atomic_exchange_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value, _Order);
}

template <class _Ty>
_Ty atomic_exchange_explicit(
    atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    return _Mem->exchange(_Value, _Order);
}

template <class _Ty>
bool atomic_compare_exchange_strong(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_strong(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_strong_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
bool atomic_compare_exchange_strong_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
bool atomic_compare_exchange_weak(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_weak(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

template <class _Ty>
bool atomic_compare_exchange_weak_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
bool atomic_compare_exchange_weak_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

template <class _Ty>
_Ty atomic_fetch_add(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value);
}

template <class _Ty>
_Ty atomic_fetch_add(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_add(_Value);
}

template <class _Ty>
_Ty atomic_fetch_add_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_add_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_add(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_sub(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value);
}

template <class _Ty>
_Ty atomic_fetch_sub(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_sub(_Value);
}

template <class _Ty>
_Ty atomic_fetch_sub_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_sub_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_sub(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_and(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value);
}

template <class _Ty>
_Ty atomic_fetch_and(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_and(_Value);
}

template <class _Ty>
_Ty atomic_fetch_and_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_and_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_and(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_or(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value);
}

template <class _Ty>
_Ty atomic_fetch_or(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_or(_Value);
}

template <class _Ty>
_Ty atomic_fetch_or_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_or_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_or(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_xor(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value);
}

template <class _Ty>
_Ty atomic_fetch_xor(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_xor(_Value);
}

template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value, _Order);
}

template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_xor(_Value, _Order);
}













































#line 2756 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

using atomic_bool = atomic<bool>;

using atomic_char   = atomic<char>;
using atomic_schar  = atomic<signed char>;
using atomic_uchar  = atomic<unsigned char>;
using atomic_short  = atomic<short>;
using atomic_ushort = atomic<unsigned short>;
using atomic_int    = atomic<int>;
using atomic_uint   = atomic<unsigned int>;
using atomic_long   = atomic<long>;
using atomic_ulong  = atomic<unsigned long>;
using atomic_llong  = atomic<long long>;
using atomic_ullong = atomic<unsigned long long>;




using atomic_char16_t = atomic<char16_t>;
using atomic_char32_t = atomic<char32_t>;
using atomic_wchar_t  = atomic<wchar_t>;

using atomic_int8_t   = atomic<int8_t>;
using atomic_uint8_t  = atomic<uint8_t>;
using atomic_int16_t  = atomic<int16_t>;
using atomic_uint16_t = atomic<uint16_t>;
using atomic_int32_t  = atomic<int32_t>;
using atomic_uint32_t = atomic<uint32_t>;
using atomic_int64_t  = atomic<int64_t>;
using atomic_uint64_t = atomic<uint64_t>;

using atomic_int_least8_t   = atomic<int_least8_t>;
using atomic_uint_least8_t  = atomic<uint_least8_t>;
using atomic_int_least16_t  = atomic<int_least16_t>;
using atomic_uint_least16_t = atomic<uint_least16_t>;
using atomic_int_least32_t  = atomic<int_least32_t>;
using atomic_uint_least32_t = atomic<uint_least32_t>;
using atomic_int_least64_t  = atomic<int_least64_t>;
using atomic_uint_least64_t = atomic<uint_least64_t>;

using atomic_int_fast8_t   = atomic<int_fast8_t>;
using atomic_uint_fast8_t  = atomic<uint_fast8_t>;
using atomic_int_fast16_t  = atomic<int_fast16_t>;
using atomic_uint_fast16_t = atomic<uint_fast16_t>;
using atomic_int_fast32_t  = atomic<int_fast32_t>;
using atomic_uint_fast32_t = atomic<uint_fast32_t>;
using atomic_int_fast64_t  = atomic<int_fast64_t>;
using atomic_uint_fast64_t = atomic<uint_fast64_t>;

using atomic_intptr_t  = atomic<intptr_t>;
using atomic_uintptr_t = atomic<uintptr_t>;
using atomic_size_t    = atomic<size_t>;
using atomic_ptrdiff_t = atomic<ptrdiff_t>;
using atomic_intmax_t  = atomic<intmax_t>;
using atomic_uintmax_t = atomic<uintmax_t>;






#line 2818 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"



struct atomic_flag { 








#line 2831 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    void clear(const memory_order _Order = memory_order_seq_cst) noexcept {
        _Storage.store(false, _Order);
    }

    void clear(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        _Storage.store(false, _Order);
    }

    constexpr atomic_flag() noexcept = default;

























#line 2875 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"


    atomic<long> _Storage;


#line 2881 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
};



















#line 2902 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

inline bool atomic_flag_test_and_set(atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

inline bool atomic_flag_test_and_set(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

inline bool atomic_flag_test_and_set_explicit(atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

inline void atomic_flag_clear(atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

inline void atomic_flag_clear(volatile atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

inline void atomic_flag_clear_explicit(atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}

inline void atomic_flag_clear_explicit(volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}


































































































#line 3033 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"

}














#pragma warning(pop)
#pragma pack(pop)
#line 3052 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#line 3053 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\atomic"
#pragma external_header(pop)
#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplinterface.h"

namespace Concurrency
{






typedef void (__cdecl * TaskProc_t)(void *);




struct __declspec(novtable) scheduler_interface
{
    virtual void schedule( TaskProc_t, void* ) = 0;
};






struct scheduler_ptr
{
    
    
    
    explicit scheduler_ptr(::std::shared_ptr<scheduler_interface> _Scheduler) : _M_sharedScheduler(::std::move(_Scheduler))
    {
        _M_scheduler = _M_sharedScheduler.get();
    }

    
    
    
    explicit scheduler_ptr(  scheduler_interface * _PScheduler) : _M_scheduler(_PScheduler)
    {
    }

    
    
    
    scheduler_interface *operator->() const
    {
        return get();
    }

    
    
    
    scheduler_interface * get() const
    {
        return _M_scheduler;
    }

    
    
    
    operator bool() const { return get() != nullptr; }

private:

    ::std::shared_ptr<scheduler_interface> _M_sharedScheduler;
    scheduler_interface * _M_scheduler;
};












enum task_group_status
{
    
    
    
    
    
    not_complete,

    
    
    
    
    completed,

    
    
    
    
    canceled
};









class invalid_operation : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit invalid_operation(  const char* _Message) noexcept
        : exception(_Message)
    { }

    
    
    
    
    invalid_operation() noexcept
        : exception()
    {}
};









class task_canceled : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit task_canceled(  const char * _Message) noexcept
        : exception(_Message)
    {}

    
    
    
    
    task_canceled() noexcept
        : exception()
    {}
};

namespace details
{






class _Interruption_exception : public ::std::exception
{
public:
    explicit _Interruption_exception(const char * _Message) noexcept
        : exception(_Message)
    {}

    _Interruption_exception() noexcept
        : exception()
    {}
};
















enum _TaskInliningMode
{
    
    _NoInline = 0,
    
    _DefaultAutoInline = 16,
    
    _ForceInline = -1,
};




typedef ::std::atomic<long> atomic_long;
typedef ::std::atomic<size_t> atomic_size_t;

template<typename _T>
_T atomic_compare_exchange(::std::atomic<_T>& _Target, _T _Exchange, _T _Comparand)
{
    _T _Result = _Comparand;
    _Target.compare_exchange_strong(_Result, _Exchange);
    return _Result;
}

template<typename _T>
_T atomic_exchange(::std::atomic<_T>& _Target, _T _Value)
{
    return _Target.exchange(_Value);
}

template<typename _T>
_T atomic_increment(::std::atomic<_T>& _Target)
{
    return _Target.fetch_add(1) + 1;
}

template<typename _T>
_T atomic_decrement(::std::atomic<_T>& _Target)
{
    return _Target.fetch_sub(1) - 1;
}

template<typename _T>
_T atomic_add(::std::atomic<_T>& _Target, _T _Value)
{
    return _Target.fetch_add(_Value) + _Value;
}

}} 

#line 272 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplinterface.h"
#pragma external_header(pop)
#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )
 
 
 



struct _SECURITY_ATTRIBUTES;
typedef _SECURITY_ATTRIBUTES* LPSECURITY_ATTRIBUTES;

struct _GROUP_AFFINITY;
typedef _GROUP_AFFINITY* PGROUP_AFFINITY;



typedef unsigned long DWORD;





typedef   long HRESULT;
#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"
typedef void * HANDLE;








#line 85 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"












#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"








typedef unsigned __int64 DWORD_PTR, *PDWORD_PTR;

#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"















#line 125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"


#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"




typedef void * _CONCRT_BUFFER;








namespace Concurrency
{














__declspec(dllimport) void __cdecl wait(unsigned int _Milliseconds);
















__declspec(dllimport) void * __cdecl Alloc(size_t _NumBytes);














__declspec(dllimport) void __cdecl Free(    void * _PAllocation);































__declspec(dllimport) void __cdecl set_task_execution_resources(DWORD_PTR _ProcessAffinityMask);

#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"

























__declspec(dllimport) void __cdecl set_task_execution_resources(unsigned short _Count, PGROUP_AFFINITY _PGroupAffinity);

#line 252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"






typedef void (__cdecl * TaskProc)(void *);




class Scheduler;
class ScheduleGroup;
class Context;

namespace details
{
    
    
    
    class ContextBase;
    class _TaskCollectionBase;

    
    
    
    template<class _Ty>
    void _InternalDeleteHelper(_Ty * _PObject)
    {
        delete _PObject;
    }

    
    
    struct _AllocBase
    {
        
        void * operator new(size_t _Size)
        {
            return ::Concurrency::Alloc(_Size);
        }

        
        void operator delete(void * _Ptr) noexcept
        {
            ::Concurrency::Free(_Ptr);
        }

        
        void * operator new(size_t _Size, const ::std::nothrow_t&) noexcept
        {
            void * _Ptr;

            try
            {
                _Ptr = ::Concurrency::Alloc(_Size);
            }
            catch(...)
            {
                _Ptr = nullptr;
            }

            return (_Ptr);
        }

        
        void operator delete(void * _Ptr, const ::std::nothrow_t&) noexcept
        {
            operator delete(_Ptr);
        }

        
        void * operator new[](size_t _Size)
        {
            return operator new(_Size);
        }

        
        void operator delete[](void * _Ptr) noexcept
        {
            operator delete(_Ptr);
        }

        
        void * operator new[](size_t _Size, const ::std::nothrow_t& _No_throw) noexcept
        {
            return operator new(_Size, _No_throw);
        }

        
        void operator delete[](void * _Ptr, const ::std::nothrow_t& _No_throw) noexcept
        {
            operator delete(_Ptr, _No_throw);
        }

        
        void * operator new(size_t, void * _Location) noexcept
        {
            return _Location;
        }

        
        void operator delete(void *, void *) noexcept
        {
        }

        
        void * __cdecl operator new[](size_t, void * _Location) noexcept
        {
            return _Location;
        }

        
        void __cdecl operator delete[](void *, void *) noexcept
        {
        }
    };

    
    class _Context
    {
    public:
        __declspec(dllimport) _Context(::Concurrency::Context * _PContext = nullptr) : _M_pContext(_PContext) {}
        __declspec(dllimport) static _Context __cdecl _CurrentContext();
        __declspec(dllimport) static void __cdecl _Yield();
        __declspec(dllimport) static void __cdecl _Oversubscribe(bool _BeginOversubscription);
        __declspec(dllimport) bool _IsSynchronouslyBlocked() const;
    private:
        ::Concurrency::Context * _M_pContext;
    };

    class _Scheduler
    {
    public:
        __declspec(dllimport) _Scheduler(::Concurrency::Scheduler * _PScheduler = nullptr) : _M_pScheduler(_PScheduler) {}
        __declspec(dllimport) unsigned int _Reference();
        __declspec(dllimport) unsigned int _Release();
        __declspec(dllimport) ::Concurrency::Scheduler * _GetScheduler() { return _M_pScheduler; }

    private:
        ::Concurrency::Scheduler * _M_pScheduler;
    };

    class _CurrentScheduler
    {
    public:
        __declspec(dllimport) static void __cdecl _ScheduleTask(TaskProc _Proc, void * _Data);
        __declspec(dllimport) static unsigned int __cdecl _Id();
        __declspec(dllimport) static unsigned int __cdecl _GetNumberOfVirtualProcessors();
        __declspec(dllimport) static _Scheduler __cdecl _Get();
    };

    
    
    
    template <size_t _Size>
    struct _Subatomic_impl { };

    template<>
    struct _Subatomic_impl<4> {
        template <typename _Ty>
        static void _StoreWithRelease(volatile _Ty& _Location, _Ty _Rhs) {
            
            
            _Location = _Rhs;
        }

        template <typename _Ty>
        static _Ty _LoadWithAquire(volatile _Ty& _Location) {
            
            
            return _Location;
        }

        template <typename _Ty>
        static _Ty _CompareAndSwap(volatile _Ty& _Location, _Ty _NewValue, _Ty _Comperand) {
            return (_Ty)_InterlockedCompareExchange((volatile long*)&_Location, (long)_NewValue, (long)_Comperand);
        }

        template <typename _Ty>
        static _Ty _FetchAndAdd(volatile _Ty& _Location, _Ty _Addend) {
            return (_Ty)_InterlockedExchangeAdd((volatile long*)&_Location, (long)_Addend);
        }

        template <typename _Ty>
        static _Ty _Increment(volatile _Ty& _Location) {
            return (_Ty)_InterlockedIncrement((volatile long*)&_Location);
        }

        template <typename _Ty>
        static _Ty _Decrement(volatile _Ty& _Location) {
            return (_Ty)_InterlockedDecrement((volatile long*)&_Location);
        }
    };


    template<>
    struct _Subatomic_impl<8> {
        template <typename _Ty>
        static void _StoreWithRelease(volatile _Ty& _Location, _Ty _Rhs) {
            
            _Location = _Rhs;
        }

        template <typename _Ty>
        static _Ty _LoadWithAquire(volatile _Ty& _Location) {
            
            return _Location;
        }

        template <typename _Ty>
        static _Ty _CompareAndSwap(volatile _Ty& _Location, _Ty _NewValue, _Ty _Comperand) {
            return (_Ty)_InterlockedCompareExchange64((volatile __int64*)&_Location, (__int64)_NewValue, (__int64)_Comperand);
        }

        template <typename _Ty>
        static _Ty _FetchAndAdd(volatile _Ty& _Location, _Ty _Addend) {
            return (_Ty)_InterlockedExchangeAdd64((volatile __int64*)&_Location, (__int64)_Addend);
        }

        template <typename _Ty>
        static _Ty _Increment(volatile _Ty& _Location) {
            return (_Ty)_InterlockedIncrement64((volatile __int64*)&_Location);
        }

        template <typename _Ty>
        static _Ty _Decrement(volatile _Ty& _Location) {
            return (_Ty)_InterlockedDecrement64((volatile __int64*)&_Location);
        }
    };
#line 483 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"


    
    
    
    
    template <typename _Ty>
    class _Subatomic {
    private:
        volatile _Ty _M_value;

    public:
        operator _Ty() const volatile {
            return _Subatomic_impl<sizeof(_Ty)>::_LoadWithAquire(_M_value);
        }

        _Ty operator=(_Ty _Rhs) {
            _Subatomic_impl<sizeof(_Ty)>::_StoreWithRelease(_M_value, _Rhs);
            return _Rhs;
        }

        _Ty _CompareAndSwap(_Ty _NewValue, _Ty _Comperand) {
            return _Subatomic_impl<sizeof(_Ty)>::_CompareAndSwap(_M_value, _NewValue, _Comperand);
        }

        _Ty _FetchAndAdd(_Ty _Addend) {
            return _Subatomic_impl<sizeof(_Ty)>::_FetchAndAdd(_M_value, _Addend);
        }

        _Ty operator++() {
            return _Subatomic_impl<sizeof(_Ty)>::_Increment(_M_value);
        }

        _Ty operator++(int) {
            return _Subatomic_impl<sizeof(_Ty)>::_Increment(_M_value) - 1;
        }

        _Ty operator--() {
            return _Subatomic_impl<sizeof(_Ty)>::_Decrement(_M_value);
        }

        _Ty operator--(int) {
            return _Subatomic_impl<sizeof(_Ty)>::_Decrement(_M_value) + 1;
        }

        _Ty operator+=(_Ty _Addend) {
            return _FetchAndAdd(_Addend) + _Addend;
        }
    };

    
    
    
    class _SpinLock
    {
    private:
        volatile long& _M_flag;

    public:
        __declspec(dllimport) _SpinLock(volatile long& _Flag);
        __declspec(dllimport) ~_SpinLock();

    private:
        _SpinLock(const _SpinLock&);
        void operator=(const _SpinLock&);
    };

    
    
    
    
    struct _SpinCount
    {
        
        
        static void __cdecl _Initialize();

        
        __declspec(dllimport) static unsigned int __cdecl _Value();

        
        static unsigned int _S_spinCount;
    };

    
    
    
    
    void __declspec(dllimport) __cdecl _UnderlyingYield();

    
    
    
    
    
    unsigned int __declspec(dllimport) __cdecl _GetConcurrency();

    
    
    
    
    template<unsigned int _YieldCount = 1>
    class __declspec(dllimport) _SpinWait
    {
    public:

        typedef void (__cdecl *_YieldFunction)();

        
        
        
        
        _SpinWait(_YieldFunction _YieldMethod = _UnderlyingYield)
            : _M_state(_StateInitial), _M_yieldFunction(_YieldMethod)
        {
            
        }

        
        
        
        
        void _SetSpinCount(unsigned int _Count)
        {
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_state == _StateInitial))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 607, 0, L"%ls", L"_M_state == _StateInitial")) || (__debugbreak(), 0) ); __assume(_M_state == _StateInitial);} while(false);
            if (_Count == 0)
            {
                
                _M_state = _StateSingle;
            }
            else
            {
                _M_currentSpin = _Count;
                _M_currentYield = _YieldCount;
                _M_state = _StateSpin;
            }
        }

        
        
        
        
        
        
        
        
        
        
        
        
        bool _SpinOnce()
        {
            switch (_M_state)
            {
            case _StateSpin:
            {
                unsigned long _Count = _NumberOfSpins();

                for (unsigned long _I = 0; _I < _Count; _I++)
                {
                    _mm_pause();
                }

                if (!_ShouldSpinAgain())
                {
                    _M_state = (_M_currentYield == 0) ? _StateBlock : _StateYield;
                }

                return true;
            }

            case _StateYield:
                __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_currentYield > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 655, 0, L"%ls", L"_M_currentYield > 0")) || (__debugbreak(), 0) ); __assume(_M_currentYield > 0);} while(false);
                if (--_M_currentYield == 0)
                {
                    _M_state = _StateBlock;
                }

                
                _DoYield();
                return true;

            case _StateBlock:
                
                _Reset();
                return false;

            case _StateSingle:
                
                _DoYield();
                return false;

            case _StateInitial:
                
                _Reset();
                return _SpinOnce();
            default:
                
                return false;
            };
        }

    protected:

        
        
        
        
        enum _SpinState
        {
            _StateInitial,
            _StateSpin,
            _StateYield,
            _StateBlock,
            _StateSingle
        };

        
        
        
        
        void _DoYield()
        {
            constexpr bool _ShouldYield = (_YieldCount != 0);
            if constexpr (_ShouldYield)
            {
                __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_yieldFunction != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 709, 0, L"%ls", L"_M_yieldFunction != nullptr")) || (__debugbreak(), 0) ); __assume(_M_yieldFunction != nullptr);} while(false);
                _M_yieldFunction();
            }
            else
            {
                _mm_pause();
            }
        }

        
        
        
        
        void _Reset()
        {
            _M_state = _StateInitial;

            
            
            _SetSpinCount(_SpinCount::_Value());

            __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_state != _StateInitial))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 730, 0, L"%ls", L"_M_state != _StateInitial")) || (__debugbreak(), 0) ); __assume(_M_state != _StateInitial);} while(false);
        }

        
        
        
        
        
        
        
        unsigned long _NumberOfSpins()
        {
            return 1;
        }

        
        
        
        
        
        
        
        bool _ShouldSpinAgain()
        {
            return (--_M_currentSpin > 0);
        }

        unsigned long  _M_currentSpin;
        unsigned long  _M_currentYield;
        _SpinState     _M_state;
        _YieldFunction _M_yieldFunction;
    };

    typedef _SpinWait<>   _SpinWaitBackoffNone;
    typedef _SpinWait<0>  _SpinWaitNoYield;

    
    
    
    
    
    class _ReentrantBlockingLock
    {
    public:
        
        __declspec(dllimport) _ReentrantBlockingLock();

        
        __declspec(dllimport) ~_ReentrantBlockingLock();

        
        __declspec(dllimport) void _Acquire();

        
        
        __declspec(dllimport) bool _TryAcquire();

        
        __declspec(dllimport) void _Release();


        
        class _Scoped_lock
        {
        public:
            
            explicit _Scoped_lock(_ReentrantBlockingLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _ReentrantBlockingLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    
            _Scoped_lock const & operator=(const _Scoped_lock&);  
        };

    private:
        
        
        _CONCRT_BUFFER _M_criticalSection[(4 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    
    
    
    
    
    class _ReentrantLock
    {
    public:
        
        __declspec(dllimport) _ReentrantLock();

        
        __declspec(dllimport) void _Acquire();

        
        
        __declspec(dllimport) bool _TryAcquire();

        
        __declspec(dllimport) void _Release();

        
        class _Scoped_lock
        {
        public:
            
            explicit _Scoped_lock(_ReentrantLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _ReentrantLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    
            _Scoped_lock const & operator=(const _Scoped_lock&);  
        };

    private:
        long _M_recursionCount;
        volatile long _M_owner;
    };

    
    
    
    
    
    class _NonReentrantBlockingLock
    {
    public:
        
        
        
        
        __declspec(dllimport) _NonReentrantBlockingLock();

        
        __declspec(dllimport) ~_NonReentrantBlockingLock();

        
        __declspec(dllimport) void _Acquire();

        
        
        __declspec(dllimport) bool _TryAcquire();

        
        __declspec(dllimport) void _Release();

        
        class _Scoped_lock
        {
        public:
            
            explicit _Scoped_lock(_NonReentrantBlockingLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._Acquire();
            }

            
            ~_Scoped_lock()
            {
                _M_lock._Release();
            }
        private:
            _NonReentrantBlockingLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    
            _Scoped_lock const & operator=(const _Scoped_lock&);  
        };

    private:
        
        
        _CONCRT_BUFFER _M_criticalSection[(4 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    
    
    
    
    
    
    
    
    
    class _ReaderWriterLock
    {
    public:
        
        
        
        
        __declspec(dllimport) _ReaderWriterLock();

        
        
        __declspec(dllimport) void _AcquireRead();

        
        __declspec(dllimport) void _ReleaseRead();

        
        
        __declspec(dllimport) void _AcquireWrite();

        
        __declspec(dllimport) void _ReleaseWrite();

        
        
        __declspec(dllimport) bool _TryAcquireWrite();

        
        bool _HasWriteLock() const
        {
            return (_M_state == _Write);
        }

        
        void _FlushWriteOwners();

        
        class _Scoped_lock
        {
        public:
            
            explicit _Scoped_lock(_ReaderWriterLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._AcquireWrite();
            }

            
            ~_Scoped_lock()
            {
                _M_lock._ReleaseWrite();
            }

        private:

            _ReaderWriterLock& _M_lock;

            _Scoped_lock(const _Scoped_lock&);                    
            _Scoped_lock const & operator=(const _Scoped_lock&);  
        };

        
        class _Scoped_lock_read
        {
        public:
            
            explicit _Scoped_lock_read(_ReaderWriterLock& _Lock) : _M_lock(_Lock)
            {
                _M_lock._AcquireRead();
            }

            
            ~_Scoped_lock_read()
            {
                _M_lock._ReleaseRead();
            }

        private:

            _ReaderWriterLock& _M_lock;

            _Scoped_lock_read(const _Scoped_lock_read&);                    
            _Scoped_lock_read const & operator=(const _Scoped_lock_read&);  
        };

    private:
        
        
        
        
        enum _State
        {
          _Write = -1,
          _Free  = 0,
          _Read  = 1
        };

        
        
        volatile long _M_state;

        
        
        
        volatile long _M_numberOfWriters;

        
        static void __cdecl _WaitEquals(volatile const long& _Location, long _Value, long _Mask = 0xFFFFFFFF);
    };

    
    
    

    
    
    
    template<typename _ElemType>
    class _MallocaArrayHolder
    {
    public:

        _MallocaArrayHolder() : _M_ElemArray(nullptr), _M_ElemsConstructed(0) {}

        
        void _Initialize(_ElemType * _Elem)
        {
            
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_ElemArray == nullptr && _M_ElemsConstructed == 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 1058, 0, L"%ls", L"_M_ElemArray == nullptr && _M_ElemsConstructed == 0")) || (__debugbreak(), 0) ); __assume(_M_ElemArray == nullptr && _M_ElemsConstructed == 0);} while(false);
            _M_ElemArray = _Elem;
            _M_ElemsConstructed = 0;
        }

        
        
        
        _ElemType * _InitOnRawMalloca(void * _MallocaRet)
        {
            if (_MallocaRet == nullptr)
                throw ::std::bad_alloc();
            _Initialize(static_cast<_ElemType *>(_MallocaRet));
            return static_cast<_ElemType *>(_MallocaRet);
        }

        
        
        void _IncrementConstructedElemsCount()
        {
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_ElemArray != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 1078, 0, L"%ls", L"_M_ElemArray != nullptr")) || (__debugbreak(), 0) ); __assume(_M_ElemArray != nullptr);} while(false); 
            _M_ElemsConstructed++;
        }

        virtual ~_MallocaArrayHolder()
        {
            for( size_t _I=0; _I < _M_ElemsConstructed; ++_I )
            {
                _M_ElemArray[_I].~_ElemType();
            }
            
            _freea(_M_ElemArray);
        }
    private:
        _ElemType * _M_ElemArray;
        size_t     _M_ElemsConstructed;

        
        _MallocaArrayHolder(const _MallocaArrayHolder & );
        _MallocaArrayHolder&  operator = (const _MallocaArrayHolder & );
    };

    
    
    
    template<typename _ElemType>
    class _MallocaListHolder
    {
    public:
        
        size_t _GetAllocationSize() const
        {
            return sizeof(_ElemNodeType);
        }

        _MallocaListHolder() : _M_FirstNode(nullptr)
        {
        }

        
        void _AddNode(_ElemType * _Elem)
        {
            _ElemNodeType * _Node = reinterpret_cast<_ElemNodeType *>(_Elem);
            _Node->_M_Next = _M_FirstNode;
            _M_FirstNode = reinterpret_cast<_ElemNodeType *>(_Elem);
        }

        
        
        
        _ElemType * _AddRawMallocaNode(void * _MallocaRet)
        {
            if (_MallocaRet == nullptr)
                throw ::std::bad_alloc();
            _AddNode(static_cast<_ElemType *>(_MallocaRet));
            return static_cast<_ElemType *>(_MallocaRet);
        }

        
         virtual ~_MallocaListHolder()
        {
            for( _ElemNodeType * _Node = _M_FirstNode; _Node != nullptr; )
            {
                auto _M_Next = _Node->_M_Next;
                _Node->_M_Elem._ElemType::~_ElemType();
                 _freea(_Node);
                _Node = _M_Next;
            }
        }

    private:

        class _ElemNodeType
        {
            friend class _MallocaListHolder;
            _ElemType _M_Elem;
            _ElemNodeType * _M_Next;
            
            _ElemNodeType();
            ~_ElemNodeType();
            
            _ElemNodeType(const _ElemNodeType & );
            _ElemNodeType &  operator = (const _ElemNodeType & );
        };

        _ElemNodeType* _M_FirstNode;

        
        _MallocaListHolder(const _MallocaListHolder & );
        _MallocaListHolder &  operator = (const _MallocaListHolder & );
    };

    
    class _StructuredTaskCollection;
    class _TaskCollection;
    class _UnrealizedChore;
} 

















class scheduler_resource_allocation_error : public ::std::exception
{
public:
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) scheduler_resource_allocation_error(  const char * _Message, HRESULT _Hresult) noexcept;

    
    
    
    
    
    
    
    explicit __declspec(dllimport) scheduler_resource_allocation_error(HRESULT _Hresult) noexcept;

    
    
    
    
    
    
    
    __declspec(dllimport) HRESULT get_error_code() const noexcept;

private:
    HRESULT _Hresult;
};











class scheduler_worker_creation_error : public scheduler_resource_allocation_error
{
public:
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) scheduler_worker_creation_error(  const char * _Message, HRESULT _Hresult) noexcept;

    
    
    
    
    
    
    
    explicit __declspec(dllimport) scheduler_worker_creation_error(HRESULT _Hresult) noexcept;
};





class unsupported_os  : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) unsupported_os(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) unsupported_os() noexcept;
};








class scheduler_not_attached  : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) scheduler_not_attached(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) scheduler_not_attached() noexcept;
};








class improper_scheduler_attach : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) improper_scheduler_attach(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) improper_scheduler_attach() noexcept;
};









class improper_scheduler_detach : public ::std::exception
{
public:

    
    
    
    
    
    
    
    explicit __declspec(dllimport) improper_scheduler_detach(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) improper_scheduler_detach() noexcept;
};








class improper_scheduler_reference : public ::std::exception
{
public:

    
    
    
    
    
    
    
    explicit __declspec(dllimport) improper_scheduler_reference(  const char* _Message) noexcept;

    
    
    
    
    __declspec(dllimport) improper_scheduler_reference() noexcept;
};







class default_scheduler_exists : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) default_scheduler_exists(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) default_scheduler_exists() noexcept;
};















class context_unblock_unbalanced : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) context_unblock_unbalanced(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) context_unblock_unbalanced() noexcept;
};








class context_self_unblock : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) context_self_unblock(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) context_self_unblock() noexcept;
};


















class missing_wait : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) missing_wait(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) missing_wait() noexcept;
};











class bad_target : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) bad_target(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) bad_target() noexcept;
};






class message_not_found : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) message_not_found(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) message_not_found() noexcept;
};








class invalid_link_target : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) invalid_link_target(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) invalid_link_target() noexcept;
};











class invalid_scheduler_policy_key : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) invalid_scheduler_policy_key(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) invalid_scheduler_policy_key() noexcept;
};










class invalid_scheduler_policy_value : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) invalid_scheduler_policy_value(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) invalid_scheduler_policy_value() noexcept;
};










class invalid_scheduler_policy_thread_specification : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) invalid_scheduler_policy_thread_specification(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) invalid_scheduler_policy_thread_specification() noexcept;
};
















class nested_scheduler_missing_detach : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) nested_scheduler_missing_detach(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) nested_scheduler_missing_detach() noexcept;
};





class operation_timed_out : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) operation_timed_out(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) operation_timed_out() noexcept;
};
















class invalid_multiple_scheduling : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) invalid_multiple_scheduling(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) invalid_multiple_scheduling() noexcept;
};








class invalid_oversubscribe_operation : public ::std::exception
{
public:
    
    
    
    
    
    
    
    explicit __declspec(dllimport) invalid_oversubscribe_operation(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) invalid_oversubscribe_operation() noexcept;
};











class improper_lock : public ::std::exception
{
public:

    
    
    
    
    
    
    
    explicit __declspec(dllimport) improper_lock(  const char * _Message) noexcept;

    
    
    
    
    __declspec(dllimport) improper_lock() noexcept;
};





class location
{
public:

    
    
    
    
    
    
    
    location() :
        _M_type(_System),
        _M_reserved(0),
        _M_bindingId(0),
        _M_ptr(nullptr),
        _M_pBinding(nullptr)
    {
    }

    
    
    
    
    location(const location& _Src)
    {
        _Assign(_Src);
    }



    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static location __cdecl from_numa_node(unsigned short _NumaNodeNumber);

#line 1873 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"

    
    
    
    
    
    
    
    __declspec(dllimport) static location __cdecl current();

    
    
    
    
    
    
    
    location& operator=(const location& _Rhs)
    {
        _Assign(_Rhs);
        return *this;
    }

    
    
    
    
    ~location()
    {
    }

    
    
    
    
    
    
    
    bool operator==(const location& _Rhs) const
    {
        return (_M_type == _Rhs._M_type && _M_ptr == _Rhs._M_ptr);
    }

    
    
    
    
    
    
    
    bool operator!=(const location& _Rhs) const
    {
        return !operator==(_Rhs);
    }

    
    
    
    
    

    
    
    
    
    __declspec(dllimport) static location __cdecl _Current_node();

    
    
    
    
    enum _Type
    {
        
        
        
        _System, 

        
        
        
        _NumaNode, 

        
        
        
        _SchedulingNode, 

        
        
        
        _ExecutionResource, 
    };

    
    
    
    
    location(_Type _LocationType, unsigned int _Id, unsigned int _BindingId = 0,   void *_PBinding = nullptr);

    
    
    
    
    
    
    
    
    
    
    
    bool _FastVPIntersects(const location& _Rhs) const;

    
    
    
    
    
    
    
    
    
    
    
    bool _FastNodeIntersects(const location& _Rhs) const;

    
    
    
    
    void _Assign(const location& _Rhs)
    {
        _M_type = _Rhs._M_type;
        _M_reserved = _Rhs._M_reserved;

        _M_ptr = _Rhs._M_ptr;

        _M_bindingId = _Rhs._M_bindingId;
        _M_pBinding = _Rhs._M_pBinding;
    }

    
    
    
    
    bool _Is_system() const
    {
        return (_Type)_M_type == _System;
    }

    
    
    
    
    template<typename _Ty>
    _Ty* _As() const
    {
        return reinterpret_cast<_Ty *>(_M_pBinding);
    }

    
    
    
    
    unsigned int _GetId() const
    {
        return _M_id;
    }

    
    
    
    
    _Type _GetType() const
    {
        return (_Type)_M_type;
    }

    
    
    
    
    unsigned int _GetBindingId() const
    {
        return _M_bindingId;
    }

private:

    
    unsigned int _M_type : 28;

    
    unsigned int _M_reserved : 4;

    
    unsigned int _M_bindingId;

    
    union
    {
        
        unsigned int _M_id;

        
        void *_M_ptr;
    };

    
    
    void *_M_pBinding;
};












class ScheduleGroup
{
public:

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual void ScheduleTask(TaskProc _Proc,   void * _Data) =0;

    
    
    
    
    
    
    
    virtual unsigned int Id() const =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual unsigned int Reference() =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual unsigned int Release() =0;

protected:

    
    
    
    template<class _Ty> friend void ::Concurrency::details::_InternalDeleteHelper(_Ty * _PObject);

    virtual ~ScheduleGroup() {};
};







const unsigned int MaxExecutionResources = 0xFFFFFFFF;







const unsigned int INHERIT_THREAD_PRIORITY = 0x0000F000;










enum PolicyElementKey
{
    
    
    
    
    
    
    
    SchedulerKind,

    
    
    
    
    
    
    
    
    
    
    MaxConcurrency,

    
    
    
    
    
    
    
    
    
    
    
    MinConcurrency,

    
    
    
    
    
    
    
    TargetOversubscriptionFactor,

    
    
    
    
    
    
    
    
    
    LocalContextCacheSize,

    
    
    
    
    
    
    ContextStackSize,

    
    
    
    
    
    
    
    
    ContextPriority,

    
    
    
    
    
    
    
    SchedulingProtocol,

    
    
    
    
    
    
    
    
    
    DynamicProgressFeedback,

    
    
    
    
    
    
    
    
    WinRTInitialization,

    
    
    
    
    MaxPolicyElementKey
};








enum SchedulerType
{
    
    
    
    
    ThreadScheduler,

    
    
    
    
    
    
    UmsThreadDefault = ThreadScheduler
};

#pragma deprecated(UmsThreadDefault)








enum SchedulingProtocolType
{
    
    
    
    
    
    
    EnhanceScheduleGroupLocality,

    
    
    
    
    
    EnhanceForwardProgress
};









enum DynamicProgressFeedbackType
{
    
    
    
    
    
    
    
    ProgressFeedbackDisabled,

    
    
    
    
    
    
    
    ProgressFeedbackEnabled
};








enum WinRTInitializationType
{
    
    
    
    
    
    InitializeWinRTAsMTA,

    
    
    
    
    
    DoNotInitializeWinRT
};














class SchedulerPolicy
{
public:

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) SchedulerPolicy();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) SchedulerPolicy(size_t _PolicyKeyCount, ...);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) SchedulerPolicy(const SchedulerPolicy& _SrcPolicy);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) SchedulerPolicy& operator=(const SchedulerPolicy& _RhsPolicy);

    
    
    
    
    __declspec(dllimport) ~SchedulerPolicy();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) unsigned int GetPolicyValue(PolicyElementKey _Key) const;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) unsigned int SetPolicyValue(PolicyElementKey _Key, unsigned int _Value);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) void SetConcurrencyLimits(unsigned int _MinConcurrency, unsigned int _MaxConcurrency = MaxExecutionResources);

    
    
    
    
    
    
    
    
    
    void _ValidateConcRTPolicy() const;

private:

    struct _PolicyBag
    {
        union
        {
            unsigned int _M_pPolicyBag[MaxPolicyElementKey];
            struct
            {
                SchedulerType _M_schedulerKind;
                unsigned int _M_maxConcurrency;
                unsigned int _M_minConcurrency;
                unsigned int _M_targetOversubscriptionFactor;
                unsigned int _M_localContextCacheSize;
                unsigned int _M_contextStackSize;
                unsigned int _M_contextPriority;
                SchedulingProtocolType _M_schedulingProtocol;
                DynamicProgressFeedbackType _M_dynamicProgressFeedback;
                WinRTInitializationType _M_WinRTInitialization;
            } _M_specificValues;
        } _M_values;
    } *_M_pPolicyBag;

    
    
    
    
    void _Initialize(size_t _PolicyKeyCount, va_list * _PArgs);

    
    
    
    
    void _Assign(const SchedulerPolicy& _SrcPolicy);

    
    
    
    
    static bool __cdecl _ValidPolicyKey(PolicyElementKey _Key);

    
    
    
    
    static bool __cdecl _ValidPolicyValue(PolicyElementKey _Key, unsigned int _Value);

    
    
    
    
    static bool __cdecl _AreConcurrencyLimitsValid(unsigned int _MinConcurrency, unsigned int _MaxConcurrency);
    bool _AreConcurrencyLimitsValid() const;

    
    
    
    
    bool _ArePolicyCombinationsValid() const;

    
    
    
    
    void _ResolvePolicyValues();

    
    
    
    
    static const char * __cdecl _StringFromPolicyKey(unsigned int _Index);
};













class CurrentScheduler
{
private:
    CurrentScheduler() {}

public:
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static unsigned int __cdecl Id();

    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static SchedulerPolicy __cdecl GetPolicy();

    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static Scheduler * __cdecl Get();

    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static unsigned int __cdecl GetNumberOfVirtualProcessors();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl Create(const SchedulerPolicy& _Policy);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl Detach();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl RegisterShutdownEvent(HANDLE _ShutdownEvent);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static ScheduleGroup * __cdecl CreateScheduleGroup();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static ScheduleGroup * __cdecl CreateScheduleGroup(location& _Placement);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl ScheduleTask(TaskProc _Proc,   void * _Data);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl ScheduleTask(TaskProc _Proc,   void * _Data, location& _Placement);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static bool __cdecl IsAvailableLocation(const location& _Placement);
};
















class Scheduler
{
protected:
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    Scheduler() {}

    
    
    
    
    virtual ~Scheduler() {}

public:

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static Scheduler * __cdecl Create(const SchedulerPolicy& _Policy);

    
    
    
    
    
    
    
    virtual unsigned int Id() const =0;

    
    
    
    
    
    
    
    
    
    virtual unsigned int GetNumberOfVirtualProcessors() const =0;


    
    
    
    
    
    
    
    
    
    
    virtual SchedulerPolicy GetPolicy() const =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual unsigned int Reference() =0 ;

    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual unsigned int Release() =0;

    
    
    
    
    
    
    
    
    
    virtual void RegisterShutdownEvent(HANDLE _Event) =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual void Attach() =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl SetDefaultSchedulerPolicy(const SchedulerPolicy& _Policy);

    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl ResetDefaultSchedulerPolicy();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual ScheduleGroup * CreateScheduleGroup() =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual ScheduleGroup * CreateScheduleGroup(location& _Placement) =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual void ScheduleTask(TaskProc _Proc,   void * _Data) =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual void ScheduleTask(TaskProc _Proc,   void * _Data, location& _Placement) =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual bool IsAvailableLocation(const location& _Placement) const =0;
};


















class Context
{
public:
    
    
    
    
    
    
    
    virtual unsigned int GetId() const =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual unsigned int GetVirtualProcessorId() const =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual unsigned int GetScheduleGroupId() const =0;

    
    
    
    
    
    
    
    
    __declspec(dllimport) static unsigned int __cdecl Id();

    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static unsigned int __cdecl VirtualProcessorId();

    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static unsigned int __cdecl ScheduleGroupId();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl Block();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual void Unblock() =0;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    virtual bool IsSynchronouslyBlocked() const =0;

    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl _SpinYield();

    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void (__cdecl Yield)();

    
    
    
    
    
    
    
    
    
    
    
    static inline void __cdecl YieldExecution()
    {
        (Yield)();
    }

    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static bool __cdecl IsCurrentTaskCollectionCanceling();

    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static Context * __cdecl CurrentContext();

    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static void __cdecl Oversubscribe(bool _BeginOversubscription);

protected:

    
    
    
    template<class _Ty> friend void ::Concurrency::details::_InternalDeleteHelper(_Ty * _PObject);

    virtual ~Context() {};
};

#line 3465 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"








const size_t COOPERATIVE_WAIT_TIMEOUT = 0xffffffffffffffffui64;








const unsigned int COOPERATIVE_TIMEOUT_INFINITE = (unsigned int)-1;









class critical_section
{
public:

    
    
    
    
    __declspec(dllimport) critical_section();

    
    
    
    
    
    
    
    
    __declspec(dllimport) ~critical_section();

    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) void lock();

    
    
    
    
    
    
    
    
    __declspec(dllimport) bool try_lock();

    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) bool try_lock_for(unsigned int _Timeout);

    
    
    
    
    
    
    __declspec(dllimport) void unlock();

    
    
    
    
    typedef critical_section& native_handle_type;

    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) native_handle_type native_handle();

    
    
    
    
    
    
    
    
    void _Flush_current_owner();

    
    
    
    
    
    
    
    
    
    
    
    
    
    bool _Acquire_lock(void * _PLockingNode, bool _FHasExternalNode);

    
    
    
    
    class scoped_lock
    {
    public:

        
        
        
        
        
        
        
        
        
        explicit __declspec(dllimport) scoped_lock(critical_section& _Critical_section);

        
        
        
        
        
        __declspec(dllimport) ~scoped_lock();

    private:

        critical_section& _M_critical_section;
        _CONCRT_BUFFER _M_node[(4 * sizeof(void *) + 2 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

        scoped_lock(const scoped_lock&);                    
        scoped_lock const & operator=(const scoped_lock&);  
    };

private:
    
    
    
    
    
    
    
    
    
    void _Switch_to_active(void * _PLockingNode);

    _CONCRT_BUFFER  _M_activeNode[(4 * sizeof(void *) + 2 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    void * volatile _M_pHead;
    void * volatile _M_pTail;

    
    
    
    
    critical_section(const critical_section&);

    
    
    
    
    critical_section& operator=(const critical_section&);
};










class reader_writer_lock
{
public:

    
    
    
    
    __declspec(dllimport) reader_writer_lock();

    
    
    
    
    
    
    
    
    __declspec(dllimport) ~reader_writer_lock();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) void lock();

    
    
    
    
    
    
    
    
    __declspec(dllimport) bool try_lock();

    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) void lock_read();

    
    
    
    
    
    
    
    
    __declspec(dllimport) bool try_lock_read();

    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) void unlock();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    void _Acquire_lock(void * _PLockingNode, bool _FHasExternalNode);

    
    
    
    
    class scoped_lock
    {
    public:
        
        
        
        
        
        
        
        
        explicit __declspec(dllimport) scoped_lock(reader_writer_lock& _Reader_writer_lock);

        
        
        
        
        __declspec(dllimport) ~scoped_lock();

    private:

        reader_writer_lock& _M_reader_writer_lock;
        _CONCRT_BUFFER _M_writerNode[(4 * sizeof(void *) + 2 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

        scoped_lock(const scoped_lock&);                    
        scoped_lock const & operator=(const scoped_lock&);  
    };

    
    
    
    
    class scoped_lock_read
    {
    public:
        
        
        
        
        
        
        
        
        
        explicit __declspec(dllimport) scoped_lock_read(reader_writer_lock& _Reader_writer_lock);

        
        
        
        
        __declspec(dllimport) ~scoped_lock_read();

    private:

        reader_writer_lock& _M_reader_writer_lock;

        scoped_lock_read(const scoped_lock_read&);                    
        scoped_lock_read const & operator=(const scoped_lock_read&);  
    };

private:

    
    
    
    
    
    
    
    
    bool _Set_next_writer(void * _PWriter);

    
    
    
    
    
    
    
    
    
    
    void * _Get_reader_convoy();

    
    
    
    
    
    
    void _Unlock_writer();

    
    
    
    
    
    void _Unlock_reader();

    
    
    
    
    
    
    
    
    
    
    void _Remove_last_writer(void * _PWriter);

    
    
    
    
    
    
    
    
    
    void _Switch_to_active(void * _PWriter);

    _CONCRT_BUFFER _M_activeWriter[(4 * sizeof(void *) + 2 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    void *         _M_pReaderHead;
    void *         _M_pWriterHead;
    void *         _M_pWriterTail;
    volatile long  _M_lockState;

    
    
    
    
    reader_writer_lock (const reader_writer_lock& _Lock);

    
    
    
    
    reader_writer_lock& operator=(const reader_writer_lock& _Lock);
};








class event
{
public:

    
    
    
    
    __declspec(dllimport) event();

    
    
    
    
    
    
    
    
    __declspec(dllimport) ~event();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) size_t wait(unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);

    
    
    
    
    
    
    
    
    
    __declspec(dllimport) void set();

    
    
    
    
    
    
    __declspec(dllimport) void reset();

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __declspec(dllimport) static size_t __cdecl wait_for_multiple(  event ** _PPEvents, size_t _Count, bool _FWaitAll, unsigned int _Timeout = COOPERATIVE_TIMEOUT_INFINITE);


    
    
    
    static const unsigned int timeout_infinite = COOPERATIVE_TIMEOUT_INFINITE;
private:

    
    event(const event& _Event);
    event& operator=(const event& _Event);

    void * volatile _M_pWaitChain;
    void * _M_pResetChain;
    ::Concurrency::critical_section _M_lock;
};

namespace details
{
    
    class _RefCounterBase
    {
    public:

        virtual ~_RefCounterBase()
        {
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_refCount == 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 4041, 0, L"%ls", L"_M_refCount == 0")) || (__debugbreak(), 0) ); __assume(_M_refCount == 0);} while(false);
        }

        
        
        long _Reference()
        {
            long _Refcount = _InterlockedIncrement(&_M_refCount);

            
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_Refcount > 1))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 4051, 0, L"%ls", L"_Refcount > 1")) || (__debugbreak(), 0) ); __assume(_Refcount > 1);} while(false);
            return _Refcount;
        }

        
        
        long _Release()
        {
            long _Refcount = _InterlockedDecrement(&_M_refCount);
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_Refcount >= 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 4060, 0, L"%ls", L"_Refcount >= 0")) || (__debugbreak(), 0) ); __assume(_Refcount >= 0);} while(false);

            if (_Refcount == 0)
            {
                _Destroy();
            }

            return _Refcount;
        }

    protected:

        
        virtual void _Destroy()
        {
            delete this;
        }

        
        _RefCounterBase(long _InitialCount = 1) : _M_refCount(_InitialCount)
        {
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_refCount > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 4081, 0, L"%ls", L"_M_refCount > 0")) || (__debugbreak(), 0) ); __assume(_M_refCount > 0);} while(false);
        }

        
        volatile long _M_refCount;
    };

    class _CancellationTokenState;
    class _CancellationTokenRegistration;

    
    
    class _NonReentrantPPLLock
    {
    public:

        
        __declspec(dllimport) _NonReentrantPPLLock();
        _NonReentrantPPLLock(const _NonReentrantPPLLock&) = delete;

        _NonReentrantPPLLock& operator=(const _NonReentrantPPLLock&) = delete;
        
        __declspec(dllimport) void _Acquire(void * _Lock_node);

        
        __declspec(dllimport) void _Release();

        
        class _Scoped_lock
        {
        public:
            
            __declspec(dllimport) explicit _Scoped_lock(_NonReentrantPPLLock& _Lock);

            _Scoped_lock(const _Scoped_lock&) = delete;
            _Scoped_lock& operator=(const _Scoped_lock&) = delete;

            
            __declspec(dllimport) ~_Scoped_lock();

        private:
            _NonReentrantPPLLock& _M_lock;
            _CONCRT_BUFFER  _M_lockNode[(4 * sizeof(void *) + 2 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
        };

    private:
        
        ::Concurrency::critical_section _M_criticalSection;
    };

    
    class _ReentrantPPLLock
    {
    public:
        
        __declspec(dllimport) _ReentrantPPLLock();
        _ReentrantPPLLock(const _ReentrantPPLLock&) = delete;

        _ReentrantPPLLock& operator=(const _ReentrantPPLLock&) = delete;

        
        __declspec(dllimport) void _Acquire(void * _Lock_node);

        
        __declspec(dllimport) void _Release();

        
        class _Scoped_lock
        {
        public:
            
            __declspec(dllimport) explicit _Scoped_lock(_ReentrantPPLLock& _Lock);

            
            __declspec(dllimport) ~_Scoped_lock();

        private:
            _ReentrantPPLLock& _M_lock;
            _CONCRT_BUFFER  _M_lockNode[(4 * sizeof(void *) + 2 * sizeof(unsigned int) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];

            _Scoped_lock(const _Scoped_lock&);                    
            _Scoped_lock const & operator=(const _Scoped_lock&);  
        };

    private:
        
        ::Concurrency::critical_section _M_criticalSection;

        
        long _M_recursionCount;

        
        volatile long _M_owner;
    };

    struct _Chore
    {
    protected:
        
        explicit _Chore(TaskProc _PFunction) : m_pFunction(_PFunction)
        {
        }

        _Chore()
        {
        }

        virtual ~_Chore()
        {
        }

    public:

        
        TaskProc m_pFunction;
    };

    
    
    
    class _UnrealizedChore : public _Chore, public _AllocBase
    {
    public:
        
        _UnrealizedChore() :
            _M_pTaskCollection(nullptr)
        {
        }
        virtual ~_UnrealizedChore() {}


        
        void _Invoke()
        {
            _M_pChoreFunction(this);
        }

        
        void _SetDetached(bool _FDetached);

        
        ::Concurrency::details::_TaskCollectionBase* _OwningCollection() const
        {
            return _M_pTaskCollection;
        }

        
        
        void _SetRuntimeOwnsLifetime(bool _FValue)
        {
            _M_fRuntimeOwnsLifetime = _FValue;
        }

        
        
        bool _GetRuntimeOwnsLifetime() const
        {
            return _M_fRuntimeOwnsLifetime;
        }

        
        template <typename _ChoreType, typename _Function>
        static _ChoreType * _InternalAlloc(const _Function& _Func)
        {
            
            _ChoreType * _Chore = new _ChoreType(_Func);
            _Chore->_M_fRuntimeOwnsLifetime = true;
            return _Chore;
        }

        
        void _PrepareSteal(ContextBase *_PContext);

    protected:
        
        template <typename _ChoreType>
        static void __cdecl _InvokeBridge(void * _PContext)
        {
            auto _PChore = static_cast<_ChoreType *>(_PContext);
            (*_PChore)();
        }

        
        __declspec(dllimport) void _CheckTaskCollection();

    private:

        friend class _StructuredTaskCollection;
        friend class _TaskCollection;
        typedef void (__cdecl * CHOREFUNC)(_UnrealizedChore * _PChore);

        
        ::Concurrency::details::_TaskCollectionBase * _M_pTaskCollection;

        
        CHOREFUNC _M_pChoreFunction;

        
        
        bool _M_fRuntimeOwnsLifetime;

        
        bool _M_fDetached;

        
        void _PrepareStealStructured(ContextBase *_PContext);
        void _PrepareStealUnstructured(ContextBase *_PContext);

        
        __declspec(noinline)
        static void __cdecl _StructuredChoreWrapper(_UnrealizedChore * _PChore);

        
        __declspec(noinline)
        static void __cdecl _UnstructuredChoreWrapper(_UnrealizedChore * _PChore);

        
        static void _InternalFree(_UnrealizedChore * _PChore);

        
        static void __cdecl _CancelViaToken(::Concurrency::details::ContextBase *_PContext);
    };

    
    enum _TaskCollectionStatus
    {
        _NotComplete,
        _Completed,
        _Canceled
    };

    
    class _TaskCollectionBase
    {
    public:
        
        _TaskCollectionBase() :
            _M_inliningDepth(_S_notInlined),
            _M_pTokenState(nullptr),
            _M_unpoppedChores(0),
            _M_completedStolenChores(_CollectionNotInitialized),
            _M_pException(nullptr)
        {
        }
        _TaskCollectionBase(const _TaskCollectionBase&) = delete;

        
        _TaskCollectionBase(_CancellationTokenState *_PTokenState) :
            _M_inliningDepth(_S_notInlined),
            _M_pTokenState(_PTokenState),
            _M_unpoppedChores(0),
            _M_completedStolenChores(_CollectionNotInitialized),
            _M_pException(nullptr)
        {
        }

        _TaskCollectionBase& operator=(const _TaskCollectionBase&) = delete;

        
        void * _OwningContext() const
        {
            return _M_pOwningContext;
        }

        
        int _InliningDepth() const
        {
            return _M_inliningDepth;
        }

        
        bool _IsCurrentlyInlined() const
        {
            return (_M_inliningDepth != _S_notInlined);
        }

        
        bool _IsStructured()
        {
            return (_M_inlineFlags & _S_structured) != 0;
        }

        
        _CancellationTokenState *_GetTokenState(_CancellationTokenRegistration **_PRegistration = nullptr);

    protected:

        friend class ::Concurrency::details::_UnrealizedChore;
        friend class ::Concurrency::details::ContextBase;

        enum _TaskCollectionBaseState
        {
            _CollectionNotInitialized = (-2147483647L - 1),
            _CollectionInitializationInProgress = (-2147483647L - 1)+1,
            _CollectionInitialized = 0
        };

        
        ::std::exception_ptr * _Exception() const
        {
            return (::std::exception_ptr *) ((size_t)_M_pException & ~_S_cancelBitsMask);
        }

        
        bool _IsAbnormalExit() const
        {
            return _M_pException != nullptr;
        }

        
        size_t _CancelState() const
        {
            return (size_t) _M_pException & _S_cancelBitsMask;
        }

        
        bool _IsMarkedForCancellation() const
        {
            return (_CancelState() & _S_cancelBitsMask) != 0;
        }

        
        bool _PerformedInlineCancel() const
        {
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_CancelState() != _S_cancelStarted))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 4405, 0, L"%ls", L"_CancelState() != _S_cancelStarted")) || (__debugbreak(), 0) ); __assume(_CancelState() != _S_cancelStarted);} while(false);
            return _CancelState() == _S_cancelShotdownOwner;
        }

        bool _PerformedPendingCancel() const
        {
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_CancelState() != _S_cancelStarted))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 4411, 0, L"%ls", L"_CancelState() != _S_cancelStarted")) || (__debugbreak(), 0) ); __assume(_CancelState() != _S_cancelStarted);} while(false);
            return _CancelState() == _S_cancelDeferredShootdownOwner;
        }

        
        _TaskCollectionBase *_SafeGetParent()
        {
            return ((_M_inliningDepth != _S_notInlined) ? _M_pParent : nullptr);
        }

        
        bool _WillInterruptForPendingCancel();

        
        
        void _RaisedException();

        
        
        void _RethrowException();

        
        bool _MarkCancellation();

        
        
        void _FinishCancelState(size_t _NewCancelState);

        
        
        
        void _RaisedCancel();

        
        
        _TaskCollectionBase * _M_pParent;

        
        int _M_inliningDepth : 28;
        int _M_inlineFlags : 4;

        
        _CancellationTokenState *_M_pTokenState;

        
        void * _M_pOwningContext;

        
        
        long _M_unpoppedChores;

        
        volatile long _M_completedStolenChores;

        
        
        
        
        
        
        
        ::std::exception_ptr * _M_pException;

        
        static const size_t _S_cancelBitsMask = 0x3;
        static const size_t _S_cancelNone = 0x0;
        static const size_t _S_cancelStarted = 0x1;
        static const size_t _S_cancelDeferredShootdownOwner = 0x2;
        static const size_t _S_cancelShotdownOwner = 0x3;

        
        static const size_t _S_nonNull = 0x8;
        static const size_t _S_cancelException = 0xC;

        
        static const int _S_notInlined = -1;

        
        static const int _S_structured = 0x00000001;
        static const int _S_localCancel = 0x00000002;
        static const int _S_reserved = 0x0000000C;
    };

    
    
    
    
    
    class _StructuredTaskCollection : public _TaskCollectionBase
    {
    public:

        
        
        
        
        _StructuredTaskCollection()
        {
            _Construct();
            _M_pTokenState = nullptr;
        }

        _StructuredTaskCollection(const _StructuredTaskCollection&) = delete;
        _StructuredTaskCollection& operator=(const _StructuredTaskCollection&) = delete;
        
        
        
        
        
        
        
        __declspec(dllimport) _StructuredTaskCollection(_CancellationTokenState *_PTokenState);

        
        
        
        
        
        
        
        __declspec(dllimport) ~_StructuredTaskCollection();

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) void _Schedule(_UnrealizedChore * _PChore, location * _PLocation);

        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) void _Schedule(_UnrealizedChore * _PChore);

        
        
        
        
        __declspec(dllimport) void _Cancel();

        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) bool _IsCanceling();

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) _TaskCollectionStatus __stdcall _RunAndWait(_UnrealizedChore * _PChore = nullptr);

        
        
        
        
        
        
        
        
        
        
        _TaskCollectionStatus _Wait()
        {
            return _RunAndWait();
        }

        
        
        
        
        void _CancelStolenContexts();

    private:

        friend class _UnrealizedChore;

        void _Construct()
        {
            _M_pOwningContext = nullptr;
            _M_inlineFlags = _S_structured;
        }

        
        
        
        
        __declspec(dllimport) void _Abort();

        
        
        
        __declspec(dllimport) void _CleanupToken();

        
        
        
        
        bool _TaskCleanup()
        {
            
            
            
            
            
            if (_M_unpoppedChores > 0)
            {
                _Abort();

                if (!__uncaught_exception())
                {
                    return false;
                }
            }

            return true;
        }

        
        
        
        
        void _Initialize();

        
        
        
        
        
        
        
        void _WaitOnStolenChores(long _StolenChoreCount);

        
        
        
        
        void _CountUp();

        
        
        
        
        
        static void __cdecl _CancelViaToken(_StructuredTaskCollection *_PCollection);

        
        
        
        
        _CONCRT_BUFFER _M_event[(sizeof(void*) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER)];
    };

    
    
    
    
    
    
    
    class _TaskCollection : public _TaskCollectionBase
    {
    public:

        
        
        
        
        __declspec(dllimport) _TaskCollection();
        _TaskCollection(const _TaskCollection&) = delete;

        _TaskCollection& operator=(const _TaskCollection&) = delete;
        
        
        
        
        
        
        
        __declspec(dllimport) _TaskCollection(_CancellationTokenState *_PTokenState);

        
        
        
        
        
        
        
        __declspec(dllimport) ~_TaskCollection();

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) void _Schedule(_UnrealizedChore * _PChore, location * _PLocation);

        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) void _Schedule(_UnrealizedChore * _PChore);

        
        
        
        
        __declspec(dllimport) void _Cancel();

        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) bool _IsCanceling();

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) _TaskCollectionStatus __stdcall _RunAndWait(_UnrealizedChore * _PChore = nullptr);

        
        
        
        
        
        
        
        
        
        
        
        _TaskCollectionStatus _Wait()
        {
            return _RunAndWait();
        }

        
        
        
        
        bool _IsMarkedForAbnormalExit() const;

        
        
        
        
        _TaskCollection * _OriginalCollection() const;

        
        
        
        
        bool _IsAlias() const;

        
        
        
        
        
        
        
        
        
        
        void _RegisterCompletionHandler(TaskProc _Func, void * _PCompletionContext);

    private:

        friend class _UnrealizedChore;
        friend class ::Concurrency::details::ContextBase;

        
        
        
        
        
        bool _IsStaleAlias() const;

        
        
        
        
        void _ReleaseAlias();

        
        
        
        
        
        
        
        
        
        
        _TaskCollection(_TaskCollection * _POriginCollection, bool _FDirectAlias);

        
        
        
        
        _TaskCollection * _Alias();

        
        
        
        
        
        
        
        void _Abort(bool _FLeaveCanceled = false);

        
        
        
        
        bool _IsIndirectAlias() const;

        
        
        
        
        bool _IsDirectAlias() const;

        
        
        
        
        bool _HasDirectAlias() const;

        
        
        
        
        
        
        
        
        
        
        
        void _Cancel(bool _InsideException, _TaskCollection * _PSnapPoint);

        
        
        
        
        void _NotifyNewChore();

        
        
        
        
        
        
        
        void _NotifyCompletedChoreAndFree(_UnrealizedChore * _PChore = nullptr);

        
        
        
        
        
        
        
        void _FullAliasWait(_TaskCollection * _PSnapPoint);

        
        
        
        
        
        
        
        void _Reset(_TaskCollection * _PSnapPoint);

        
        
        
        
        
        
        void _RaisedException();

        
        
        
        
        
        
        void _RaisedCancel();

        
        
        
        
        
        
        
        
        
        
        bool _SetCancelState(long _Status);

        
        
        
        
        
        
        
        
        void _CancelFromArbitraryThread(bool _InsideException);

        
        
        
        
        
        
        
        
        
        
        
        void _CancelDirectAliases(bool _InsideException, _TaskCollection * _PSnapPoint);

        
        
        
        
        
        
        
        
        
        
        
        
        
        void _CancelStolenContexts(bool _InsideException, bool _FInlineGated);

        
        
        
        
        void *_GetStealTrackingList() const;

        
        
        
        
        void _Initialize();

        
        
        
        
        
        
        
        void _AbortiveSweep(void *_PCtx);

        
        
        
        
        
        
        
        
        
        
        
        
        
        static bool __cdecl _CollectionMatchPredicate(_UnrealizedChore *_PChore, void *_PData);

        
        
        
        
        
        
        
        
        
        
        
        
        
        static bool __cdecl _SweepAbortedChore(_UnrealizedChore *_PChore, void *_PData);

        
        
        
        
        
        
        
        bool _TaskCleanup(bool _FExceptional);

        
        
        
        
        static void __cdecl _CancelViaToken(_TaskCollection *_PCollection);

        
        
        
        
        
        _CONCRT_BUFFER _M_stealTracker[((3 * sizeof(void *) + 2 * sizeof(long) + sizeof(_CONCRT_BUFFER) - 1) / sizeof(_CONCRT_BUFFER))];

        
        
        
        
        
        long _M_activeStealersForCancellation;

        
        
        
        
        
        volatile long _M_exitCode;

        
        
        
        
        volatile long _M_executionStatus;

        
        
        
        
        event _M_event;

        _TaskCollection * _M_pOriginalCollection;
        _TaskCollection * _M_pNextAlias;
        void * _M_pTaskExtension;

        int _M_taskCookies[2];

        volatile long _M_flags;
        volatile long _M_chaining;

        DWORD _M_boundQueueId;
        int _M_stackPos;

        TaskProc _M_completionHandler;
        void * _M_pCompletionContext;
    };

    
    
    
    
    class _StackGuard
    {
    public:
        _StackGuard() : _Depth(_GetCurrentInlineDepth())
        {
            
            ++_Depth;
        }
        _StackGuard(const _StackGuard&) = delete;

        _StackGuard& operator=(const _StackGuard&) = delete;

        ~_StackGuard()
        {
            
            --_Depth;
        }

        bool _ShouldInline(_TaskInliningMode _InliningMode) const
        {
            
            
            return _Depth <= static_cast<size_t>(_InliningMode);
        }
    private:
        size_t & _Depth;

        
        
        
        
        
        __declspec(dllimport) static size_t & __cdecl _GetCurrentInlineDepth();
    };

    
    
    
    
    
    class _AsyncTaskCollection : public _RefCounterBase
    {
    public:
        _AsyncTaskCollection(const _AsyncTaskCollection&) = delete;
        _AsyncTaskCollection& operator=(const _AsyncTaskCollection&) = delete;
        
        
        
        
        
        
        
        
        
        __declspec(dllimport) static _AsyncTaskCollection * __cdecl _NewCollection(_CancellationTokenState *_PTokenState);

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        _TaskCollectionStatus _ScheduleWithAutoInline(_UnrealizedChore * _PChore, _TaskInliningMode _InliningMode)
        {
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_PChore != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h", 5217, 0, L"%ls", L"_PChore != nullptr")) || (__debugbreak(), 0) ); __assume(_PChore != nullptr);} while(false);
            _Reference();

            if (_InliningMode == _NoInline)
            {
                _M_taskCollection._Schedule(_PChore);
                return _NotComplete;
            }
            else
            {
                _StackGuard _Guard;
                if (_Guard._ShouldInline(_InliningMode))
                {
                    return _M_taskCollection._RunAndWait(_PChore);
                }
                else
                {
                    _M_taskCollection._Schedule(_PChore);
                    return _NotComplete;
                }
            }
        }

        
        
        
        void _Cancel()
        {
            _M_taskCollection._Cancel();
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        _TaskCollectionStatus _RunAndWait()
        {
            
            _StackGuard _Guard;
            return _M_taskCollection._RunAndWait();
        }

    private:

        void _NotificationHandler();

        __declspec(dllimport) virtual void _Destroy();

        
        _AsyncTaskCollection(_CancellationTokenState *_PTokenState);

        __declspec(noinline)
        static void __cdecl _CompletionHandler(void * _PCompletionContext);

    private:

        
        _TaskCollection _M_taskCollection;
    };

    
    
    
    struct _Beacon_reference
    {
        volatile long _M_signals;
    };

    
    
    
    
    
    
    
    
    
    class _Cancellation_beacon
    {
    public:

        __declspec(dllimport) _Cancellation_beacon();

        __declspec(dllimport) ~_Cancellation_beacon();

        bool _Is_signaled() const
        {
            return (_M_pRef->_M_signals != 0);
        }

        
        
        __declspec(dllimport) bool _Confirm_cancel();

        void _Raise()
        {
            _InterlockedIncrement(&_M_pRef->_M_signals);
        }

        void _Lower()
        {
            _InterlockedDecrement(&_M_pRef->_M_signals);
        }

    private:

        _Beacon_reference *_M_pRef;

    };

    
    
    
    class _TimerStub;

    
    
    
    
    class _Timer
    {
    protected:
        
        
        
        
        __declspec(dllimport) _Timer(unsigned int _Ms, bool _FRepeating);

        
        __declspec(dllimport) virtual ~_Timer();

        
        __declspec(dllimport) void _Start();

        
        __declspec(dllimport) void _Stop();

    private:
        friend class _TimerStub;

        
        virtual void _Fire() =0;

        
        HANDLE _M_hTimer;

        
        unsigned int _M_ms;

        
        bool _M_fRepeating;
    };

    
    
    
    
    struct _CONCRT_TRACE_INFO
    {
        volatile unsigned long EnableFlags;    
        volatile unsigned char EnableLevel;    

        void _EnableTrace(unsigned char _Level, unsigned long _Flags)
        {
            EnableFlags = _Flags;
            EnableLevel = _Level;
        }
#pragma warning ( push )
#pragma warning ( disable : 5393 )  
        void _DisableTrace()
        {
            EnableLevel = 0;
            EnableFlags = 0;
        }
#pragma warning ( pop )

        bool _IsEnabled(unsigned char _Level, unsigned long _Flags) const
        {
            return ((_Level <= EnableLevel) &&  ((EnableFlags & _Flags) == _Flags));
        }
    };

    
    
    
    
    
    __declspec(dllimport) const _CONCRT_TRACE_INFO * _GetConcRTTraceInfo();

    
    
    
    
    void _RegisterConcRTEventTracing();

    
    
    
    
    void _UnregisterConcRTEventTracing();

} 









__declspec(deprecated("Concurrency::EnableTracing is a deprecated function.")) __declspec(dllimport) HRESULT __cdecl EnableTracing();









__declspec(deprecated("Concurrency::DisableTracing is a deprecated function.")) __declspec(dllimport) HRESULT __cdecl DisableTracing();





enum ConcRT_EventType
{
    
    
    
    
    CONCRT_EVENT_GENERIC    = 0,
    
    
    
    
    CONCRT_EVENT_START      = 1,
    
    
    
    
    CONCRT_EVENT_END        = 2,
    
    
    
    
    CONCRT_EVENT_BLOCK      = 3,
    
    
    
    
    CONCRT_EVENT_UNBLOCK    = 4,
    
    
    
    
    CONCRT_EVENT_YIELD      = 5,
    
    
    
    
    CONCRT_EVENT_IDLE       = 6,
    
    
    
    
    CONCRT_EVENT_ATTACH     = 7,
    
    
    
    
    CONCRT_EVENT_DETACH     = 8,
};















__declspec(dllimport) extern const GUID ConcRT_ProviderGuid;












__declspec(dllimport) extern const GUID ConcRTEventGuid;







__declspec(dllimport) extern const GUID SchedulerEventGuid;









__declspec(dllimport) extern const GUID ScheduleGroupEventGuid;






__declspec(dllimport) extern const GUID ContextEventGuid;










__declspec(dllimport) extern const GUID ChoreEventGuid;





__declspec(dllimport) extern const GUID VirtualProcessorEventGuid;










__declspec(dllimport) extern const GUID LockEventGuid;









__declspec(dllimport) extern const GUID ResourceManagerEventGuid;







__declspec(dllimport) extern const GUID PPLParallelInvokeEventGuid;







__declspec(dllimport) extern const GUID PPLParallelForEventGuid;







__declspec(dllimport) extern const GUID PPLParallelForeachEventGuid;





__declspec(dllimport) extern const GUID AgentEventGuid;


__declspec(dllimport) void __cdecl _Trace_ppl_function(const GUID& _Guid, unsigned char _Level, ConcRT_EventType _Type);





enum Concrt_TraceFlags
{
    SchedulerEventFlag              = 0x1,
    ContextEventFlag                = 0x2,
    VirtualProcessorEventFlag       = 0x4,
    ResourceManagerEventFlag        = 0x8,
    PPLEventFlag                    = 0x10,
    AgentEventFlag                  = 0x20,

    AllEventsFlag                   = 0xFFFFFFFF
};





enum Agents_EventType
{
    
    
    
    
    AGENTS_EVENT_CREATE   = 0,

    
    
    
    
    AGENTS_EVENT_START    = 1,

    
    
    
    
    AGENTS_EVENT_END      = 2,

    
    
    
    
    AGENTS_EVENT_DESTROY  = 3,

    
    
    
    
    AGENTS_EVENT_SCHEDULE = 4,

    
    
    
    
    AGENTS_EVENT_LINK     = 5,

    
    
    
    
    AGENTS_EVENT_UNLINK   = 6,

    
    
    
    
    AGENTS_EVENT_NAME     = 7

};





















__declspec(dllimport) void __cdecl _Trace_agents(Agents_EventType _Type, __int64 _AgentId, ...);
}









    
    



#line 5736 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"


    





#line 5745 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"


    
#line 5749 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"

#pragma comment(lib, "concrt" "d" "")






#line 5758 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\concrt.h"

namespace concurrency = ::Concurrency;

 
 
 
 #pragma warning(pop)
 #pragma pack(pop)
#pragma external_header(pop)
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"


















































































#pragma external_header(pop)
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"





#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )





extern "C" {







__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_1(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_2(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_4(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_8(
    const void* _First, const void* _Last, void* _Dest) noexcept;
}
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

namespace std {
 constexpr int _ISORT_MAX = 32; 

template <class _It>
 constexpr auto _Isort_max = _Iter_diff_t<_It>{_ISORT_MAX};

template <class _Diff>
constexpr ptrdiff_t _Temporary_buffer_size(const _Diff _Value) noexcept {
    
    using _CT = common_type_t<ptrdiff_t, _Diff>;
    return static_cast<ptrdiff_t>((::std:: min) (static_cast<_CT>(9223372036854775807i64), static_cast<_CT>(_Value)));
}

template <class _Ty>
struct _Optimistic_temporary_buffer { 
    static constexpr size_t _Optimistic_size  = 4096; 
    static constexpr size_t _Optimistic_count = (::std:: max) (static_cast<size_t>(1), _Optimistic_size / sizeof(_Ty));

    template <class _Diff>
    explicit _Optimistic_temporary_buffer(const _Diff _Requested_size) noexcept { 
        const auto _Attempt = _Temporary_buffer_size(_Requested_size);
        
        
        if (static_cast<size_t>(_Requested_size) <= _Optimistic_count) { 
            _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
            _Capacity = static_cast<ptrdiff_t>(_Requested_size); 
            return;
        }

        const pair<_Ty*, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Attempt);
        if (static_cast<size_t>(_Raw.second) > _Optimistic_count) { 
            _Data     = _Raw.first;
            _Capacity = _Raw.second;
            return;
        }

        
        _Return_temporary_buffer(_Raw.first);
        _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
        _Capacity = _Optimistic_count;
    }

    _Optimistic_temporary_buffer(const _Optimistic_temporary_buffer&) = delete;
    _Optimistic_temporary_buffer& operator=(const _Optimistic_temporary_buffer&) = delete;

    ~_Optimistic_temporary_buffer() noexcept {
        if (static_cast<size_t>(_Capacity) > _Optimistic_count) {
            _Return_temporary_buffer(_Data);
        }
    }

    _Ty* _Data; 
    ptrdiff_t _Capacity;
    aligned_union_t<0, _Ty> _Stack_space[_Optimistic_count];
};
































































































































































template <class _InIt, class _Fn>
inline _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        _Func(*_UFirst);
    }

    return _Func;
}

























#line 292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"





















































































#line 378 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}




#line 399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt adjacent_find(const _FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; _UFirst = _UNext) {
            if (_Pred(*_UFirst, *_UNext)) {
                _ULast = _UFirst;
                break;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

template <class _FwdIt>
[[nodiscard]] inline _FwdIt adjacent_find(const _FwdIt _First, const _FwdIt _Last) { 
    return ::std:: adjacent_find(_First, _Last, equal_to<>{});
}










#line 434 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

































































































template <class _InIt, class _Pr>
[[nodiscard]] inline _Iter_diff_t<_InIt> count_if(_InIt _First, _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst               = _Get_unwrapped(_First);
    const auto _ULast          = _Get_unwrapped(_Last);
    _Iter_diff_t<_InIt> _Count = 0;
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            ++_Count;
        }
    }

    return _Count;
}





#line 552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"












































template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
        ++_UFirst1;
        ++_UFirst2;
    }

    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}





#line 618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: mismatch(_First1, _Last1, _First2, equal_to<>{});
}










#line 635 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    auto _ULast1       = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>) {
        using _CT         = _Common_diff_t<_InIt1, _InIt2>;
        const _CT _Count1 = _ULast1 - _UFirst1;
        const _CT _Count2 = _ULast2 - _UFirst2;
        const auto _Count = static_cast<_Iter_diff_t<_InIt1>>((::std:: min) (_Count1, _Count2));
        _ULast1           = _UFirst1 + _Count;
        while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    } else {
        while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}





#line 673 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: mismatch(_First1, _Last1, _First2, _Last2, equal_to<>{});
}










#line 690 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"



































































































template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));

    for (;; ++_UFirst1, (void) ++_UFirst2) { 
        if (_UFirst1 == _ULast1) { 
            return true;
        }

        if (!_Pred(*_UFirst1, *_UFirst2)) { 
            break;
        }
    }

    
    
    const auto _Dist2 = static_cast<_Iter_diff_t<_FwdIt2>>(::std:: distance(_UFirst1, _ULast1));
    return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, ::std:: next(_UFirst2, _Dist2), _Pass_fn(_Pred));
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2) {
    
    return ::std:: is_permutation(_First1, _Last1, _First2, equal_to<>{});
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    forward_iterator_tag, forward_iterator_tag) {
    
    for (;; ++_First1, (void) ++_First2) { 
        if (_First1 == _Last1) {
            return _First2 == _Last2;
        }

        if (_First2 == _Last2) {
            return false;
        }

        if (!_Pred(*_First1, *_First2)) { 
            break;
        }
    }

    auto _Next1 = _First1;
    auto _Next2 = _First2;
    for (;; ++_Next1, (void) ++_Next2) { 
        if (_Next1 == _Last1) {
            if (_Next2 == _Last2) {
                return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
            }

            return false; 
        }

        if (_Next2 == _Last2) {
            return false; 
        }
    }
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    random_access_iterator_tag, random_access_iterator_tag) {
    
    if (_Last1 - _First1 != _Last2 - _First2) {
        return false;
    }

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) { 
        if (!_Pred(*_First1, *_First2)) {
            
            return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
        }
    }

    return true;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool is_permutation(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    return _Is_permutation_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1), _Get_unwrapped(_First2),
        _Get_unwrapped(_Last2), _Pass_fn(_Pred), _Iter_cat_t<_FwdIt1>{}, _Iter_cat_t<_FwdIt2>{});
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) {
    
    return ::std:: is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>{});
}










































































































































































































































template <class _InIt, class _Pr>
[[nodiscard]] inline bool all_of(_InIt _First, _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            return false;
        }
    }

    return true;
}




#line 1139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"











































template <class _InIt, class _Pr>
[[nodiscard]] inline bool any_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return true;
        }
    }

    return false;
}




#line 1201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"











































template <class _InIt, class _Pr>
[[nodiscard]] inline bool none_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return false;
        }
    }

    return true;
}




#line 1263 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"











































































































template <class _InIt, class _OutIt, class _Pr>
inline _OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}










#line 1397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"






































































































































































template <class _InIt, class _OutIt1, class _OutIt2, class _Pr>
inline pair<_OutIt1, _OutIt2> partition_copy(
    _InIt _First, _InIt _Last, _OutIt1 _Dest_true, _OutIt2 _Dest_false, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest_true  = _Get_unwrapped_unverified(_Dest_true);
    auto _UDest_false = _Get_unwrapped_unverified(_Dest_false);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest_true = *_UFirst;
            ++_UDest_true;
        } else {
            *_UDest_false = *_UFirst;
            ++_UDest_false;
        }
    }

    _Seek_wrapped(_Dest_false, _UDest_false);
    _Seek_wrapped(_Dest_true, _UDest_true);
    return {_Dest_true, _Dest_false};
}

















































































#line 1668 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt, class _Pr>
[[nodiscard]] inline bool is_partitioned(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    for (;; ++_UFirst) { 
        if (_UFirst == _ULast) {
            return true;
        }

        if (!_Pred(*_UFirst)) {
            break;
        }
    }

    while (++_UFirst != _ULast) { 
        if (_Pred(*_UFirst)) {
            return false; 
        }
    }

    return true;
}




#line 1699 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"





















































template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _Count       = ::std:: distance(_UFirst, _ULast);
    while (0 < _Count) { 
        const auto _Count2 = static_cast<_Iter_diff_t<_FwdIt>>(_Count / 2);
        const auto _UMid   = ::std:: next(_UFirst, _Count2);

        if (_Pred(*_UMid)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2;
            --_Count;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}



































































































template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool _Equal_rev_pred_unchecked(_InIt1 _First1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    if constexpr (_Equal_memcmp_is_safe<_InIt1, _InIt2, _Pr>) {


#line 1881 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"
        {
            return _Memcmp_ranges(_First2, _Last2, _First1) == 0;
        }
    }

    for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
        if (!_Pred(*_First1, *_First2)) {
            return false;
        }
    }

    return true;
}

template <class _FwdItHaystack, class _FwdItPat, class _Pr>
[[nodiscard]] inline _FwdItHaystack search(_FwdItHaystack _First1, _FwdItHaystack _Last1, const _FwdItPat _First2,
    const _FwdItPat _Last2, _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_FwdItHaystack> && _Is_random_iter_v<_FwdItPat>) {
        const _Iter_diff_t<_FwdItPat> _Count2 = _ULast2 - _UFirst2;
        if (_ULast1 - _UFirst1 >= _Count2) {
            const auto _Last_possible = _ULast1 - static_cast<_Iter_diff_t<_FwdItHaystack>>(_Count2);
            for (;; ++_UFirst1) {
                if (_Equal_rev_pred_unchecked(_UFirst1, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    break;
                }

                if (_UFirst1 == _Last_possible) {
                    break;
                }
            }
        }
    } else {
        for (;; ++_UFirst1) { 
            auto _UMid1 = _UFirst1;
            for (auto _UMid2 = _UFirst2;; ++_UMid1, (void) ++_UMid2) {
                if (_UMid2 == _ULast2) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    return _Last1;
                } else if (_UMid1 == _ULast1) {
                    return _Last1;
                } else if (!_Pred(*_UMid1, *_UMid2)) {
                    break;
                }
            }
        }
    }

    return _Last1;
}





#line 1943 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdItHaystack, class _FwdItPat>
[[nodiscard]] inline _FwdItHaystack search(
    const _FwdItHaystack _First1, const _FwdItHaystack _Last1, const _FwdItPat _First2, const _FwdItPat _Last2) {
    
    return ::std:: search(_First1, _Last1, _First2, _Last2, equal_to<>{});
}








#line 1959 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdItHaystack, class _Searcher>
[[nodiscard]] inline _FwdItHaystack search(
    const _FwdItHaystack _First, const _FwdItHaystack _Last, const _Searcher& _Search) {
    
    return _Search(_First, _Last).first;
}























































































































































template <class _FwdIt, class _Diff, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt search_n(
    const _FwdIt _First, _FwdIt _Last, const _Diff _Count_raw, const _Ty& _Val, _Pr _Pred) {
    
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    if (static_cast<uintmax_t>(_Count) > static_cast<uintmax_t>((numeric_limits<_Iter_diff_t<_FwdIt>>::max) ())) {
        
        return _Last;
    }

    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Is_random_iter_v<_FwdIt>) {
        const auto _Count_diff = static_cast<_Iter_diff_t<_FwdIt>>(_Count);
        auto _UOld_first       = _UFirst;
        for (_Iter_diff_t<_FwdIt> _Inc = 0; _Count_diff <= _ULast - _UOld_first;) { 
            _UFirst = _UOld_first + _Inc;
            if (_Pred(*_UFirst, _Val)) { 
                _Iter_diff_t<_FwdIt> _Count1 = _Count_diff;
                auto _UMid                   = _UFirst;

                while (_UOld_first != _UFirst && _Pred(*_Prev_iter(_UFirst), _Val)) { 
                    --_Count1;
                    --_UFirst;
                }

                if (_Count1 <= _ULast - _UMid) {
                    for (;;) { 
                        if (--_Count1 == 0) {
                            _Seek_wrapped(_Last, _UFirst); 
                            return _Last;
                        } else if (!_Pred(*++_UMid, _Val)) { 
                            break;
                        }
                    }
                }
                _UOld_first = ++_UMid; 
                _Inc        = 0;
            } else { 
                _UOld_first = _Next_iter(_UFirst);
                _Inc        = _Count_diff - 1;
            }
        }
    } else {
        for (; _UFirst != _ULast; ++_UFirst) {
            if (_Pred(*_UFirst, _Val)) { 
                auto _UMid = _UFirst;

                for (_Algorithm_int_t<_Diff> _Count1 = _Count;;) {
                    if (--_Count1 == 0) {
                        _Seek_wrapped(_Last, _UFirst); 
                        return _Last;
                    } else if (++_UMid == _ULast) {
                        return _Last; 
                    } else if (!_Pred(*_UMid, _Val)) { 
                        break;
                    }
                }

                _UFirst = _UMid; 
            }
        }
    }

    return _Last;
}





#line 2194 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdIt, class _Diff, class _Ty>
[[nodiscard]] inline _FwdIt search_n(const _FwdIt _First, const _FwdIt _Last, const _Diff _Count, const _Ty& _Val) {
    
    return ::std:: search_n(_First, _Last, _Count, _Val, equal_to<>{});
}







#line 2208 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"




































































































































































template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline _FwdIt1 find_end(
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_FwdIt1> && _Is_random_iter_v<_FwdIt2>) {
        const _Iter_diff_t<_FwdIt2> _Count2 = _ULast2 - _UFirst2;
        if (_Count2 > 0 && _Count2 <= _ULast1 - _UFirst1) {
            for (auto _UCandidate = _ULast1 - static_cast<_Iter_diff_t<_FwdIt1>>(_Count2);; --_UCandidate) {
                if (_Equal_rev_pred_unchecked(_UCandidate, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_First1, _UCandidate);
                    return _First1;
                }

                if (_UCandidate == _UFirst1) {
                    break;
                }
            }
        }

        return _Last1;
    } else if constexpr (_Is_bidi_iter_v<_FwdIt1> && _Is_bidi_iter_v<_FwdIt2>) {
        for (auto _UCandidate = _ULast1;; --_UCandidate) { 
            auto _UNext1 = _UCandidate;
            auto _UNext2 = _ULast2;
            for (;;) { 
                if (_UFirst2 == _UNext2) { 
                    _Seek_wrapped(_First1, _UNext1);
                    return _First1;
                }

                if (_UFirst1 == _UNext1) {
                    
                    return _Last1;
                }

                --_UNext1;
                --_UNext2;
                if (!_Pred(*_UNext1, *_UNext2)) { 
                    break;
                }
            }
        }
    } else {
        auto _UResult = _ULast1;
        for (;;) { 
            auto _UNext1 = _UFirst1;
            auto _UNext2 = _UFirst2;
            for (;;) { 
                const bool _End_of_needle = static_cast<bool>(_UNext2 == _ULast2);
                if (_End_of_needle) { 
                    _UResult = _UFirst1;
                }

                if (_UNext1 == _ULast1) {
                    
                    _Seek_wrapped(_First1, _UResult);
                    return _First1;
                }

                if (_End_of_needle || !_Pred(*_UNext1, *_UNext2)) {
                    break; 
                }

                ++_UNext1;
                ++_UNext2;
            }

            ++_UFirst1;
        }

        _Seek_wrapped(_First1, _UResult);
        return _First1;
    }
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline _FwdIt1 find_end(
    _FwdIt1 const _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2) {
    
    return ::std:: find_end(_First1, _Last1, _First2, _Last2, equal_to<>{});
}











#line 2471 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"






































































































































































template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline _FwdIt1 find_first_of(
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    for (; _UFirst1 != _ULast1; ++_UFirst1) {
        for (auto _UMid2 = _UFirst2; _UMid2 != _ULast2; ++_UMid2) {
            if (_Pred(*_UFirst1, *_UMid2)) {
                _Seek_wrapped(_First1, _UFirst1);
                return _First1;
            }
        }
    }

    _Seek_wrapped(_First1, _UFirst1);
    return _First1;
}

template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline _FwdIt1 find_first_of(const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) { 
    return ::std:: find_first_of(_First1, _Last1, _First2, _Last2, equal_to<>{});
}











#line 2677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"





























































































































































template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 swap_ranges(const _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    
    _Adl_verify_range(_First1, _Last1);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
    _Seek_wrapped(_First2, _Swap_ranges_unchecked(_UFirst1, _ULast1, _UFirst2));
    return _First2;
}








#line 2853 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt, class _OutIt, class _Fn>
inline _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        *_UDest = _Func(*_UFirst);
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}





#line 2874 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Fn>
inline _OutIt transform(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    const auto _Count  = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Count);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Count);
    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2, ++_UDest) {
        *_UDest = _Func(*_UFirst1, *_UFirst2);
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}





#line 2898 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"
















































































































template <class _FwdIt, class _Ty>
inline void replace(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval, const _Ty& _Newval) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (*_UFirst == _Oldval) {
            *_UFirst = _Newval;
        }
    }
}





#line 3028 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"


























































template <class _FwdIt, class _Pr, class _Ty>
inline void replace_if(const _FwdIt _First, const _FwdIt _Last, _Pr _Pred, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UFirst = _Val;
        }
    }
}




#line 3103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

























































template <class _InIt, class _OutIt, class _Ty>
inline _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (*_UFirst == _Oldval) {
            *_UDest = _Newval;
        } else {
            *_UDest = *_UFirst;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}











#line 3190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

































































template <class _InIt, class _OutIt, class _Pr, class _Ty>
inline _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (_Pred(*_UFirst)) {
            *_UDest = _Val;
        } else {
            *_UDest = *_UFirst;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}











#line 3285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"















































































































































































template <class _FwdIt, class _Fn>
inline void generate(_FwdIt _First, _FwdIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        *_UFirst = _Func();
    }
}








#line 3478 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _OutIt, class _Diff, class _Fn>
inline _OutIt generate_n(_OutIt _Dest, const _Diff _Count_raw, _Fn _Func) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UDest = _Get_unwrapped_n(_Dest, _Count);
        do {
            *_UDest = _Func();
            --_Count;
            ++_UDest;
        } while (0 < _Count);

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}









#line 3506 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt, class _OutIt, class _Ty>
inline _OutIt remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!(*_UFirst == _Val)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}










#line 3535 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt, class _OutIt, class _Pr>
inline _OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}










#line 3564 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"








#line 3573 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"







































































































































































































































template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UFirstb = _UFirst; ++_UFirst != _ULast; _UFirstb = _UFirst) {
            if (_Pred(*_UFirstb, *_UFirst)) { 
                while (++_UFirst != _ULast) {
                    if (!_Pred(*_UFirstb, *_UFirst)) {
                        *++_UFirstb = ::std:: move(*_UFirst);
                    }
                }

                _Seek_wrapped(_Last, ++_UFirstb);
                return _Last;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

template <class _FwdIt>
[[nodiscard]] inline _FwdIt unique(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: unique(_First, _Last, equal_to<>{});
}















#line 3849 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"








































































template <class _InIt, class _OutIt>
 constexpr bool _Can_reread_dest =
    _Is_fwd_iter_v<_OutIt> && is_same_v<_Iter_value_t<_InIt>, _Iter_value_t<_OutIt>>;
#line 3925 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"


template <class _InIt, class _OutIt, class _Pr>
inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);

    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    if (_UFirst == _ULast) {
        return _Dest;
    }

    auto _UDest = _Get_unwrapped_unverified(_Dest);

    if constexpr (_Is_fwd_iter_v<_InIt>) { 
        auto _Firstb = _UFirst;

        *_UDest = *_Firstb;
        ++_UDest;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(*_Firstb, *_UFirst))) { 
                _Firstb = _UFirst;
                *_UDest = *_Firstb;
                ++_UDest;
            }
        }
    } else if constexpr (_Can_reread_dest<_InIt, _OutIt>) { 
        *_UDest = *_UFirst;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(*_UDest, *_UFirst))) {
                *++_UDest = *_UFirst;
            }
        }

        ++_UDest;
    } else { 
        _Iter_value_t<_InIt> _Val = *_UFirst;

        *_UDest = _Val;
        ++_UDest;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(_Val, *_UFirst))) { 
                _Val    = *_UFirst;
                *_UDest = _Val;
                ++_UDest;
            }
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}

template <class _InIt, class _OutIt>
inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    return ::std:: unique_copy(_First, _Last, _Dest, equal_to<>{});
}



















#line 4007 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

















































































































































































template <class _BidIt, class _OutIt>
inline _OutIt reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_BidIt>(_UFirst, _ULast));


    using _Elem                         = remove_reference_t<_Iter_ref_t<remove_const_t<decltype(_UFirst)>>>;
    using _DestElem                     = remove_reference_t<_Iter_ref_t<decltype(_UDest)>>;
    constexpr bool _Allow_vectorization = conjunction_v<is_same<remove_const_t<_Elem>, _DestElem>,
        bool_constant<_Iterators_are_contiguous<decltype(_UFirst), decltype(_UDest)>>, is_trivially_copyable<_Elem>,
        negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

#pragma warning(suppress : 6326) 
    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {


#line 4205 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"
        {
            if constexpr (_Nx == 1) {
                __std_reverse_copy_trivially_copyable_1(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else if constexpr (_Nx == 2) {
                __std_reverse_copy_trivially_copyable_2(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else if constexpr (_Nx == 4) {
                __std_reverse_copy_trivially_copyable_4(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else {
                __std_reverse_copy_trivially_copyable_8(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            }

            _UDest += _ULast - _UFirst;
            _Seek_wrapped(_Dest, _UDest);
            return _Dest;
        }
    }
#line 4222 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

    for (; _UFirst != _ULast; ++_UDest) {
        *_UDest = *--_ULast;
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
































































































#line 4327 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"















































































































template <class _FwdIt, class _OutIt>
inline _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _UMid   = _Get_unwrapped(_Mid);
    const auto _ULast  = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_FwdIt>(_UFirst, _ULast));
    _UDest             = _Copy_unchecked(_UMid, _ULast, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _UMid, _UDest));
    return _Dest;
}












































































































































































































































































#line 4720 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _RanIt, class _RngFn>
void _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn& _RngFunc) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _ULast) {
        return;
    }

    using _Diff         = _Iter_diff_t<_RanIt>;
    auto _UTarget       = _UFirst;
    _Diff _Target_index = 1;
    for (; ++_UTarget != _ULast; ++_Target_index) { 
        _Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));
        do { if (0 <= _Off && _Off <= _Target_index) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm", 4736, 0, "%s", "random value out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"random value out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm", 4736, 0); } while (false); } ; } while (false);
        if (_Off != _Target_index) { 
            ::std:: iter_swap(_UTarget, _UFirst + _Off);
        }
    }
}

template <class _RanIt, class _Urng>
void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func) { 
    using _Urng0 = remove_reference_t<_Urng>;
    _Rng_from_urng<_Iter_diff_t<_RanIt>, _Urng0> _RngFunc(_Func);
    _Random_shuffle1(_First, _Last, _RngFunc);
}





























































template <class _RanIt, class _RngFn>
void random_shuffle(_RanIt _First, _RanIt _Last, _RngFn&& _RngFunc) {
    
    _Random_shuffle1(_First, _Last, _RngFunc);
}

struct _Rand_urng_from_func { 
    using result_type = unsigned int;

    static result_type(min)() { 
        return 0;
    }

    static result_type(max)() { 
        return 0x7fff;
    }

    result_type operator()() { 
        return static_cast<result_type>(:: rand());
    }
};

template <class _RanIt>
void random_shuffle(_RanIt _First, _RanIt _Last) { 
    _Rand_urng_from_func _Func;
    ::std:: shuffle(_First, _Last, _Func);
}
#line 4838 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"























































































































#line 4958 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdIt, class _Pr>
inline _FwdIt partition(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if constexpr (_Is_bidi_iter_v<_FwdIt>) {
        for (;;) { 
            for (;;) { 
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }

                if (!_Pred(*_UFirst)) {
                    break;
                }

                ++_UFirst;
            }

            do { 
                --_ULast;
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }
            } while (!_Pred(*_ULast));

            ::std:: iter_swap(_UFirst, _ULast); 
            ++_UFirst;
        }
    } else {
        for (;;) { 
            if (_UFirst == _ULast) {
                _Seek_wrapped(_First, _UFirst);
                return _First;
            }

            if (!_Pred(*_UFirst)) {
                break;
            }

            ++_UFirst;
        }

        for (auto _UNext = _UFirst; ++_UNext != _ULast;) {
            if (_Pred(*_UNext)) {
                ::std:: iter_swap(_UFirst, _UNext); 
                ++_UFirst;
            }
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}























































































#line 5104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _BidIt>
_BidIt _Buffered_rotate_unchecked(const _BidIt _First, const _BidIt _Mid, const _BidIt _Last,
    const _Iter_diff_t<_BidIt> _Count1, const _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity) { 
                                 
                                 
    if (_Count1 == 0) {
        return _Last;
    }

    if (_Count2 == 0) {
        return _First;
    }

    if (_Count1 <= _Count2 && _Count1 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
        const _BidIt _New_mid = _Move_unchecked(_Mid, _Last, _First);
        _Move_unchecked(_Backout._First, _Backout._Last, _New_mid);
        return _New_mid; 
    }

    if (_Count2 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
        _Move_backward_unchecked(_First, _Mid, _Last);
        return _Move_unchecked(_Backout._First, _Backout._Last, _First); 
    }

    
    return ::std:: rotate(_First, _Mid, _Last);
}

template <class _BidIt, class _Pr>
pair<_BidIt, _Iter_diff_t<_BidIt>> _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr _Pred,
    const _Iter_diff_t<_BidIt> _Count, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity) {
    
    
    
    
    
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count - static_cast<_Diff>(1) <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr};
        _BidIt _Next = _First;
        _Backout._Emplace_back(::std:: move(*_First));
        while (++_First != _Last) { 
                                    
            if (_Pred(*_First)) {
                *_Next = ::std:: move(*_First);
                ++_Next;
            } else {
                _Backout._Emplace_back(::std:: move(*_First));
            }
        }

        
        *_Next = ::std:: move(*_Last);
        ++_Next;
        _Move_unchecked(_Backout._First, _Backout._Last, _Next); 
        _Diff _True_distance = static_cast<_Diff>(_Count - static_cast<_Diff>(_Backout._Last - _Backout._First));
        return pair<_BidIt, _Diff>(_Next, _True_distance); 
    }

    const _Diff _Mid_offset = _Count / static_cast<_Diff>(2); 
    const _BidIt _Mid       = ::std:: next(_First, _Mid_offset);

    
    _BidIt _Left           = _Mid;
    _Diff _Left_true_count = _Mid_offset;
    for (;;) { 
        --_Left;
        if (_First == _Left) { 
            --_Left_true_count; 
            break;
        }

        if (_Pred(*_Left)) { 
            const pair<_BidIt, _Diff> _Low =
                _Stable_partition_unchecked1(_First, _Left, _Pred, _Left_true_count, _Temp_ptr, _Capacity);
            _Left            = _Low.first;
            _Left_true_count = _Low.second;
            break;
        }

        --_Left_true_count;
    }

    
    _BidIt _Right           = _Mid;
    _Diff _Right_true_count = 0;
    for (;;) { 
        if (_Right == _Last) { 
            ++_Right; 
            ++_Right_true_count;
            break;
        }

        if (!_Pred(*_Right)) { 
            const _Diff _Right_count = _Count - _Mid_offset;
            const _Diff _Remaining   = _Right_count - _Right_true_count;
            const pair<_BidIt, _Diff> _High =
                _Stable_partition_unchecked1(_Right, _Last, _Pred, _Remaining, _Temp_ptr, _Capacity);
            _Right = _High.first;
            _Right_true_count += _High.second;
            break;
        }

        ++_Right;
        ++_Right_true_count;
    }

    
    const _BidIt _Partition_point = _Buffered_rotate_unchecked(_Left, _Mid, _Right,
        static_cast<_Diff>(_Mid_offset - _Left_true_count), _Right_true_count, _Temp_ptr, _Capacity);
    return pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count));
}

template <class _BidIt, class _Pr>
_BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    for (;;) {
        if (_First == _Last) { 
            return _First;
        }

        if (!_Pred(*_First)) { 
            break;
        }

        ++_First;
    }

    for (;;) {
        --_Last;
        if (_First == _Last) { 
            return _First;
        }

        if (_Pred(*_Last)) { 
            break;
        }
    }

    using _Diff              = _Iter_diff_t<_BidIt>;
    const _Diff _Temp_count  = ::std:: distance(_First, _Last); 
    const _Diff _Total_count = _Temp_count + static_cast<_Diff>(1);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Temp_count};
    return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;
}

template <class _BidIt, class _Pr>
_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Stable_partition_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}








#line 5273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"











































































































































































































template <class _RanIt, class _Ty, class _Pr>
inline void _Push_heap_by_index(
    _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {
    
    using _Diff = _Iter_diff_t<_RanIt>;
    for (_Diff _Idx = (_Hole - 1) >> 1; 
         _Top < _Hole && _Debug_lt_pred(_Pred, *(_First + _Idx), _Val); 
         _Idx = (_Hole - 1) >> 1) { 
        
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }

    *(_First + _Hole) = ::std:: forward<_Ty>(_Val); 
}

template <class _RanIt, class _Pr>
inline void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    using _Diff        = _Iter_diff_t<_RanIt>;
    _Diff _Count       = _ULast - _UFirst;
    if (2 <= _Count) {
        _Iter_value_t<_RanIt> _Val = ::std:: move(*--_ULast);
        _Push_heap_by_index(_UFirst, --_Count, _Diff(0), ::std:: move(_Val), _Pass_fn(_Pred));
    }
}

template <class _RanIt>
inline void push_heap(_RanIt _First, _RanIt _Last) {
    
    ::std:: push_heap(_First, _Last, less<>{});
}












































































template <class _RanIt, class _Ty, class _Pr>
inline void _Pop_heap_hole_by_index(
    _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {
    
    ;

    using _Diff      = _Iter_diff_t<_RanIt>;
    const _Diff _Top = _Hole;
    _Diff _Idx       = _Hole;

    
    
    const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; 
    while (_Idx < _Max_sequence_non_leaf) { 
        _Idx = 2 * _Idx + 2;
        if (_Debug_lt_pred(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
            --_Idx;
        }
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }

    if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { 
        *(_First + _Hole) = ::std:: move(*(_First + (_Bottom - 1)));
        _Hole             = _Bottom - 1;
    }

    _Push_heap_by_index(_First, _Hole, _Top, ::std:: forward<_Ty>(_Val), _Pred);
}

template <class _RanIt, class _Ty, class _Pr>
inline void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {
    
    
    
    *_Dest      = ::std:: move(*_First);
    using _Diff = _Iter_diff_t<_RanIt>;
    _Pop_heap_hole_by_index(
        _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), ::std:: forward<_Ty>(_Val), _Pred);
}

template <class _RanIt, class _Pr>
inline void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    if (2 <= _Last - _First) {
        --_Last;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*_Last);
        _Pop_heap_hole_unchecked(_First, _Last, _Last, ::std:: move(_Val), _Pred);
    }
}

template <class _RanIt, class _Pr>
inline void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}

template <class _RanIt>
inline void pop_heap(_RanIt _First, _RanIt _Last) {
    
    ::std:: pop_heap(_First, _Last, less<>{});
}











































































































template <class _RanIt, class _Pr>
inline void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    using _Diff   = _Iter_diff_t<_RanIt>;
    _Diff _Bottom = _Last - _First;
    for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { 
        
        --_Hole;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*(_First + _Hole));
        _Pop_heap_hole_by_index(_First, _Hole, _Bottom, ::std:: move(_Val), _Pred);
    }
}

template <class _RanIt, class _Pr>
inline void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Make_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}

template <class _RanIt>
inline void make_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: make_heap(_First, _Last, less<>{});
}

























































template <class _RanIt, class _Pr>
inline _RanIt _Is_heap_until_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    using _Diff       = _Iter_diff_t<_RanIt>;
    const _Diff _Size = _Last - _First;
    for (_Diff _Off = 1; _Off < _Size; ++_Off) {
        if (_Debug_lt_pred(_Pred, *(_First + ((_Off - 1) >> 1)), *(_First + _Off))) { 
            return _First + _Off;
        }
    }

    return _Last;
}

template <class _RanIt, class _Pr>
[[nodiscard]] inline _RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Is_heap_until_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

template <class _RanIt, class _Pr>
[[nodiscard]] inline bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}

template <class _RanIt>
[[nodiscard]] inline _RanIt is_heap_until(_RanIt _First, _RanIt _Last) {
    
    return ::std:: is_heap_until(_First, _Last, less<>{});
}

template <class _RanIt>
[[nodiscard]] inline bool is_heap(_RanIt _First, _RanIt _Last) { 
    return ::std:: is_heap(_First, _Last, less<>{});
}









































































































#line 5984 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _RanIt, class _Pr>
inline void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    for (; _Last - _First >= 2; --_Last) {
        _Pop_heap_unchecked(_First, _Last, _Pred);
    }
}

template <class _RanIt, class _Pr>
inline void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);

    const auto _Counterexample = _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
    if (_Counterexample != _ULast) {
        do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm", 6001, 0, "%s", "invalid heap in sort_heap()")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid heap in sort_heap()\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm", 6001, 0); } while (false);
    }
#line 6004 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"
    _Sort_heap_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
}

template <class _RanIt>
inline void sort_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: sort_heap(_First, _Last, less<>{});
}










































































































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid             = ::std:: next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: upper_bound(_First, _Last, _Val, less<>{});
}


























































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    using _Diff  = _Iter_diff_t<_FwdIt>;
    _Diff _Count = ::std:: distance(_UFirst, _ULast);

    for (;;) { 
        if (_Count <= 0) {
            _Seek_wrapped(_Last, _UFirst); 
            _Seek_wrapped(_First, _UFirst);
            break;
        }

        _Diff _Count2    = _Count / 2;
        const auto _UMid = ::std:: next(_UFirst, _Count2);
        if (_Debug_lt_pred(_Pred, *_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else if (_Pred(_Val, *_UMid)) {
            _Count = _Count2; 
        } else { 
            auto _UFirst2 = ::std:: lower_bound(_UFirst, _UMid, _Val, _Pass_fn(_Pred));
            ::std:: advance(_UFirst, _Count);
            auto _ULast2 = ::std:: upper_bound(_Next_iter(_UMid), _UFirst, _Val, _Pass_fn(_Pred));
            _Seek_wrapped(_Last, _ULast2);
            _Seek_wrapped(_First, _UFirst2);
            break;
        }
    }

    return {_First, _Last};
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: equal_range(_First, _Last, _Val, less<>{});
}
































































template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));
    return _UFirst != _ULast && !_Pred(_Val, *_UFirst);
}

template <class _FwdIt, class _Ty>
[[nodiscard]] inline bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: binary_search(_First, _Last, _Val, less<>{});
}


































[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Distance_unknown, _Distance_unknown) {
    return {};
}

template <class _Diff1>
[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Diff1, _Distance_unknown) {
    return {};
}

template <class _Diff2>
[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Distance_unknown, _Diff2) {
    return {};
}

template <class _Diff1, class _Diff2>
[[nodiscard]] constexpr auto _Idl_dist_add(_Diff1 _Lhs, _Diff2 _Rhs) {
    return _Lhs + _Rhs;
}

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    const auto _Count1 = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    const auto _Count2 = _Idl_distance<_InIt2>(_UFirst2, _ULast2);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_dist_add(_Count1, _Count2));
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (;;) {
            if (_Debug_lt_pred(_Pred, *_UFirst2, *_UFirst1)) {
                *_UDest = *_UFirst2;
                ++_UDest;
                ++_UFirst2;

                if (_UFirst2 == _ULast2) {
                    break;
                }
            } else {
                *_UDest = *_UFirst1;
                ++_UDest;
                ++_UFirst1;

                if (_UFirst1 == _ULast1) {
                    break;
                }
            }
        }
    }

    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest); 
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}









































































































#line 6528 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"









template <class _BidIt>
void _Rotate_one_right(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_Mid));
    _Move_backward_unchecked(_First, _Mid, _Last);
    *_First = ::std:: move(_Temp);
}

template <class _BidIt>
void _Rotate_one_left(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_First));
    *_Move_unchecked(_Mid, _Last, _First) = ::std:: move(_Temp);
}

template <class _BidIt, class _Pr>
void _Inplace_merge_buffer_left(
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
    _Ptr_ty _Left_first      = _Temp_ptr;
    const _Ptr_ty _Left_last = _Backout._Last - 1; 
    *_First                  = ::std:: move(*_Mid); 
    ++_First;
    ++_Mid;
    for (;;) {
        if (_Pred(*_Mid, *_Left_first)) { 
            *_First = ::std:: move(*_Mid);
            ++_First;
            ++_Mid;
            if (_Mid == _Last) {
                _Move_unchecked(_Left_first, _Backout._Last, _First); 
                return;
            }
        } else { 
            *_First = ::std:: move(*_Left_first);
            ++_First;
            ++_Left_first;
            if (_Left_first == _Left_last) {
                
                *_Move_unchecked(_Mid, _Last, _First) = ::std:: move(*_Left_last);
                return;
            }
        }
    }
}

template <class _BidIt, class _Pr>
void _Inplace_merge_buffer_right(
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
    *--_Last                   = ::std:: move(*--_Mid); 
    const _Ptr_ty _Right_first = _Temp_ptr;
    _Ptr_ty _Right_last        = _Backout._Last - 1;
    --_Mid;
    for (;;) {
        if (_Pred(*_Right_last, *_Mid)) { 
            *--_Last = ::std:: move(*_Mid);
            if (_First == _Mid) {
                *--_Last = ::std:: move(*_Right_last); 
                _Move_backward_unchecked(_Right_first, _Right_last, _Last); 
                return;
            }

            --_Mid;
        } else { 
            *--_Last = ::std:: move(*_Right_last);
            --_Right_last;
            if (_Right_first == _Right_last) { 
                *--_Last = ::std:: move(*_Mid); 
                _Move_backward_unchecked(_First, _Mid, _Last);
                *_First = ::std:: move(*_Right_first);
                return;
            }
        }
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred);

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_divide_and_conquer2(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred,
    _BidIt _Firstn, _BidIt _Lastn, _Iter_diff_t<_BidIt> _Count1n, _Iter_diff_t<_BidIt> _Count2n) {
    
    using _Diff  = _Iter_diff_t<_BidIt>;
    _BidIt _Midn = _Buffered_rotate_unchecked(_Firstn, _Mid, _Lastn, static_cast<_Diff>(_Count1 - _Count1n), _Count2n,
        _Temp_ptr, _Capacity); 
    _Buffered_inplace_merge_unchecked(
        _First, _Firstn, _Midn, _Count1n, _Count2n, _Temp_ptr, _Capacity, _Pred); 
    _Buffered_inplace_merge_unchecked(_Midn, _Lastn, _Last, static_cast<_Diff>(_Count1 - _Count1n),
        static_cast<_Diff>(_Count2 - _Count2n), _Temp_ptr, _Capacity, _Pred);
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_divide_and_conquer(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count1 <= _Count2) {
        const _Diff _Count1n = _Count1 >> 1; 
        const _BidIt _Firstn = ::std:: next(_First, _Count1n);
        const _BidIt _Lastn  = ::std:: lower_bound(_Mid, _Last, *_Firstn, _Pred);
        _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, _Count1n, ::std:: distance(_Mid, _Lastn));
    } else {
        const _Diff _Count2n = _Count2 >> 1; 
        const _BidIt _Lastn  = ::std:: next(_Mid, _Count2n);
        const _BidIt _Firstn = ::std:: upper_bound(_First, _Mid, *_Lastn, _Pred);
        _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, ::std:: distance(_First, _Firstn), _Count2n);
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked_impl(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    if (_Count1 <= _Count2 && _Count1 <= _Capacity) {
        _Inplace_merge_buffer_left(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else if (_Count2 <= _Capacity) {
        _Inplace_merge_buffer_right(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else {
        _Buffered_inplace_merge_divide_and_conquer(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    
    if (_Mid == _Last) {
        return;
    }

    for (;;) {
        if (_First == _Mid) {
            return;
        }

        if (_Pred(*_Mid, *_First)) {
            break;
        }

        ++_First;
        --_Count1;
    }

    const auto _Highest = _Prev_iter(_Mid);
    do {
        --_Last;
        --_Count2;
        if (_Mid == _Last) {
            _Rotate_one_right(_First, _Mid, ++_Last);
            return;
        }
    } while (!_Pred(*_Last, *_Highest));

    ++_Last;
    ++_Count2;

    if (_Count1 == 1) {
        _Rotate_one_left(_First, _Mid, _Last);
        return;
    }

    _Buffered_inplace_merge_unchecked_impl(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
}

template <class _BidIt, class _Pr>
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _UMid   = _Get_unwrapped(_Mid);
    auto _ULast  = _Get_unwrapped(_Last);
    _Debug_order_unchecked(_UFirst, _UMid, _Pred);

    
    if (_UMid == _ULast) {
        return;
    }

    for (;;) {
        if (_UFirst == _UMid) {
            return;
        }

        if (_Pred(*_UMid, *_UFirst)) { 
            break;
        }

        ++_UFirst;
    }

    const auto _Highest = _Prev_iter(_UMid);
    do {
        --_ULast;
        if (_UMid == _ULast) { 
            _Rotate_one_right(_UFirst, _UMid, ++_ULast);
            return;
        }
    } while (!_Pred(*_ULast, *_Highest)); 

    ++_ULast;

    using _Diff         = _Iter_diff_t<_BidIt>;
    const _Diff _Count1 = ::std:: distance(_UFirst, _UMid);
    if (_Count1 == 1) { 
        _Rotate_one_left(_UFirst, _UMid, _ULast);
        return;
    }

    const _Diff _Count2 = ::std:: distance(_UMid, _ULast);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{(::std:: min) (_Count1, _Count2)};
    _Buffered_inplace_merge_unchecked_impl(
        _UFirst, _UMid, _ULast, _Count1, _Count2, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}

template <class _BidIt>
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    ::std:: inplace_merge(_First, _Mid, _Last, less<>{});
}















#line 6791 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"





















































































































































































































































































































































template <class _BidIt, class _Pr>
inline _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {
    
    if (_First != _Last) {
        for (_BidIt _Mid = _First; ++_Mid != _Last;) { 
            _BidIt _Hole               = _Mid;
            _Iter_value_t<_BidIt> _Val = ::std:: move(*_Mid);

            if (_Debug_lt_pred(_Pred, _Val, *_First)) { 
                _Move_backward_unchecked(_First, _Mid, ++_Hole);
                *_First = ::std:: move(_Val);
            } else { 
                for (_BidIt _Prev = _Hole; _Debug_lt_pred(_Pred, _Val, *--_Prev); _Hole = _Prev) {
                    *_Hole = ::std:: move(*_Prev); 
                }

                *_Hole = ::std:: move(_Val); 
            }
        }
    }

    return _Last;
}

template <class _RanIt, class _Pr>
inline void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    if (_Debug_lt_pred(_Pred, *_Mid, *_First)) {
        ::std:: iter_swap(_Mid, _First);
    }

    if (_Debug_lt_pred(_Pred, *_Last, *_Mid)) { 
        ::std:: iter_swap(_Last, _Mid);

        if (_Debug_lt_pred(_Pred, *_Mid, *_First)) {
            ::std:: iter_swap(_Mid, _First);
        }
    }
}

template <class _RanIt, class _Pr>
inline void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    using _Diff        = _Iter_diff_t<_RanIt>;
    const _Diff _Count = _Last - _First;
    if (40 < _Count) { 
        const _Diff _Step     = (_Count + 1) >> 3; 
        const _Diff _Two_step = _Step << 1; 
        _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);
        _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
        _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);
        _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
    } else {
        _Med3_unchecked(_First, _Mid, _Last, _Pred);
    }
}

template <class _RanIt, class _Pr>
inline pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _RanIt _Mid = _First + ((_Last - _First) >> 1); 
    _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);
    _RanIt _Pfirst = _Mid;
    _RanIt _Plast  = _Next_iter(_Pfirst);

    while (_First < _Pfirst && !_Debug_lt_pred(_Pred, *_Prev_iter(_Pfirst), *_Pfirst)
           && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {
        --_Pfirst;
    }

    while (_Plast < _Last && !_Debug_lt_pred(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {
        ++_Plast;
    }

    _RanIt _Gfirst = _Plast;
    _RanIt _Glast  = _Pfirst;

    for (;;) { 
        for (; _Gfirst < _Last; ++_Gfirst) {
            if (_Debug_lt_pred(_Pred, *_Pfirst, *_Gfirst)) {
                continue;
            } else if (_Pred(*_Gfirst, *_Pfirst)) {
                break;
            } else if (_Plast != _Gfirst) {
                ::std:: iter_swap(_Plast, _Gfirst);
                ++_Plast;
            } else {
                ++_Plast;
            }
        }

        for (; _First < _Glast; --_Glast) {
            if (_Debug_lt_pred(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {
                continue;
            } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {
                break;
            } else if (--_Pfirst != _Prev_iter(_Glast)) {
                ::std:: iter_swap(_Pfirst, _Prev_iter(_Glast));
            }
        }

        if (_Glast == _First && _Gfirst == _Last) {
            return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
        }

        if (_Glast == _First) { 
            if (_Plast != _Gfirst) {
                ::std:: iter_swap(_Pfirst, _Plast);
            }

            ++_Plast;
            ::std:: iter_swap(_Pfirst, _Gfirst);
            ++_Pfirst;
            ++_Gfirst;
        } else if (_Gfirst == _Last) { 
            if (--_Glast != --_Pfirst) {
                ::std:: iter_swap(_Glast, _Pfirst);
            }

            ::std:: iter_swap(_Pfirst, --_Plast);
        } else {
            ::std:: iter_swap(_Gfirst, --_Glast);
            ++_Gfirst;
        }
    }
}

template <class _RanIt, class _Pr>
inline void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {
    
    for (;;) {
        if (_Last - _First <= _ISORT_MAX) { 
            _Insertion_sort_unchecked(_First, _Last, _Pred);
            return;
        }

        if (_Ideal <= 0) { 
            _Make_heap_unchecked(_First, _Last, _Pred);
            _Sort_heap_unchecked(_First, _Last, _Pred);
            return;
        }

        
        auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

        _Ideal = (_Ideal >> 1) + (_Ideal >> 2); 

        if (_Mid.first - _First < _Last - _Mid.second) { 
            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);
            _First = _Mid.second;
        } else { 
            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);
            _Last = _Mid.first;
        }
    }
}

template <class _RanIt, class _Pr>
inline void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));
}

template <class _RanIt>
inline void sort(const _RanIt _First, const _RanIt _Last) { 
    ::std:: sort(_First, _Last, less<>{});
}










#line 7312 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"
































































































































































































































template <class _FwdIt, class _Ty, class _Pr>
_Ty* _Uninitialized_merge_move(_FwdIt _First, const _FwdIt _Mid, const _FwdIt _Last, _Ty* const _Dest, _Pr _Pred) {
    
    
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    _FwdIt _Next = _Mid;
    for (;;) {
        if (_Debug_lt_pred(_Pred, *_Next, *_First)) {
            _Backout._Emplace_back(::std:: move(*_Next));
            ++_Next;

            if (_Next == _Last) {
                _Backout._Last = _Uninitialized_move_unchecked(_First, _Mid, _Backout._Last);
                return _Backout._Release();
            }
        } else {
            _Backout._Emplace_back(::std:: move(*_First));
            ++_First;

            if (_First == _Mid) {
                _Backout._Last = _Uninitialized_move_unchecked(_Next, _Last, _Backout._Last);
                return _Backout._Release();
            }
        }
    }
}

template <class _InIt, class _OutIt, class _Pr>
_OutIt _Merge_move(_InIt _First, const _InIt _Mid, const _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    
    _InIt _Next = _Mid;
    for (;;) {
        if (_Debug_lt_pred(_Pred, *_Next, *_First)) {
            *_Dest = ::std:: move(*_Next);
            ++_Dest;
            ++_Next;

            if (_Next == _Last) {
                return _Move_unchecked(_First, _Mid, _Dest);
            }
        } else {
            *_Dest = ::std:: move(*_First);
            ++_Dest;
            ++_First;

            if (_First == _Mid) {
                return _Move_unchecked(_Next, _Last, _Dest);
            }
        }
    }
}

template <class _BidIt, class _Ty, class _Pr>
void _Uninitialized_chunked_merge_unchecked2(
    _BidIt _First, const _BidIt _Last, _Ty* _Dest, _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    while (_Count > _Isort_max<_BidIt>) {
        _Count -= _Isort_max<_BidIt>;
        const _BidIt _Mid1 = ::std:: next(_First, _Isort_max<_BidIt>);
        const auto _Chunk2 = (::std:: min) (_Isort_max<_BidIt>, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Backout._Last     = _Uninitialized_merge_move(_First, _Mid1, _Mid2, _Backout._Last, _Pred);
        _First             = _Mid2;
    }

    _Uninitialized_move_unchecked(_First, _Last, _Backout._Last); 
    _Backout._Release();
}

template <class _BidIt, class _OutIt, class _Pr>
void _Chunked_merge_unchecked(_BidIt _First, const _BidIt _Last, _OutIt _Dest, const _Iter_diff_t<_BidIt> _Chunk,
    _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    
    while (_Chunk < _Count) {
        _Count -= _Chunk;
        const _BidIt _Mid1 = ::std:: next(_First, _Chunk);
        const auto _Chunk2 = (::std:: min) (_Chunk, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Dest              = _Merge_move(_First, _Mid1, _Mid2, _Dest, _Pred);
        _First             = _Mid2;
    }

    _Move_unchecked(_First, _Last, _Dest); 
}

template <class _BidIt, class _Pr>
void _Insertion_sort_isort_max_chunks(_BidIt _First, const _BidIt _Last, _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    for (; _Isort_max<_BidIt> < _Count; _Count -= _Isort_max<_BidIt>) { 
        _First = _Insertion_sort_unchecked(_First, ::std:: next(_First, _Isort_max<_BidIt>), _Pred);
    }

    _Insertion_sort_unchecked(_First, _Last, _Pred); 
}

template <class _BidIt, class _Pr>
void _Buffered_merge_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    
    _Insertion_sort_isort_max_chunks(_First, _Last, _Count, _Pred);
    
    if (_Count <= _Isort_max<_BidIt>) {
        return;
    }

    
    _Uninitialized_chunked_merge_unchecked2(_First, _Last, _Temp_ptr, _Count, _Pred);
    _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr, _Temp_ptr + _Count};
    auto _Chunk = _Isort_max<_BidIt>;
    for (;;) {
        
        _Chunk <<= 1;
        _Chunked_merge_unchecked(_Temp_ptr, _Temp_ptr + _Count, _First, static_cast<ptrdiff_t>(_Chunk),
            static_cast<ptrdiff_t>(_Count), _Pred);
        _Chunk <<= 1;
        if (_Count <= _Chunk) { 
            return;
        }

        
        _Chunked_merge_unchecked(_First, _Last, _Temp_ptr, _Chunk, _Count, _Pred);
    }
}

template <class _BidIt, class _Pr>
void _Stable_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count <= _ISORT_MAX) {
        _Insertion_sort_unchecked(_First, _Last, _Pred); 
    } else { 
        const auto _Half_count      = static_cast<_Diff>(_Count >> 1); 
        const auto _Half_count_ceil = static_cast<_Diff>(_Count - _Half_count);
        const _BidIt _Mid           = ::std:: next(_First, _Half_count_ceil);
        if (_Half_count_ceil <= _Capacity) { 
            _Buffered_merge_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Pred);
            _Buffered_merge_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Pred);
        } else { 
            _Stable_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Capacity, _Pred);
            _Stable_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Capacity, _Pred);
        }

        _Buffered_inplace_merge_unchecked(
            _First, _Mid, _Last, _Half_count_ceil, _Half_count, _Temp_ptr, _Capacity, _Pred); 
    }
}

template <class _BidIt, class _Pr>
void stable_sort(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _Count  = ::std:: distance(_UFirst, _ULast);
    if (_Count <= _ISORT_MAX) {
        _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
        return;
    }

    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Count - _Count / 2};
    _Stable_sort_unchecked(_UFirst, _ULast, _Count, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}




#line 7715 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _BidIt>
void stable_sort(const _BidIt _First, const _BidIt _Last) { 
    ::std:: stable_sort(_First, _Last, less<>{});
}







#line 7728 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"



































































































































































































































































template <class _RanIt, class _Pr>
inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _UMid  = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);

    if (_UFirst == _UMid) {
        return; 
    }

    _Make_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
    for (auto _UNext = _UMid; _UNext < _ULast; ++_UNext) {
        if (_Debug_lt_pred(_Pred, *_UNext, *_UFirst)) { 
            _Iter_value_t<_RanIt> _Val = ::std:: move(*_UNext);
            _Pop_heap_hole_unchecked(_UFirst, _UMid, _UNext, ::std:: move(_Val), _Pass_fn(_Pred));
        }
    }

    _Sort_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
}

template <class _RanIt>
inline void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last) {
    
    ::std:: partial_sort(_First, _Mid, _Last, less<>{});
}





























































































#line 8110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt, class _RanIt, class _Pr>
inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    auto _UMid2        = _UFirst2;
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (; _UFirst1 != _ULast1 && _UMid2 != _ULast2; ++_UFirst1, (void) ++_UMid2) {
            *_UMid2 = *_UFirst1; 
        }

        _Make_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
        for (; _UFirst1 != _ULast1; ++_UFirst1) {
            if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) {
                
                using _Diff = _Iter_diff_t<_RanIt>;
                _Pop_heap_hole_by_index(
                    _UFirst2, static_cast<_Diff>(0), static_cast<_Diff>(_UMid2 - _UFirst2), *_UFirst1, _Pass_fn(_Pred));
            }
        }

        _Sort_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
    }

    _Seek_wrapped(_First2, _UMid2);
    return _First2;
}

template <class _InIt, class _RanIt>
inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2) {
    
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2, less<>{});
}

















































































































#line 8262 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _RanIt, class _Pr>
inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Nth);
    _Adl_verify_range(_Nth, _Last);
    auto _UFirst     = _Get_unwrapped(_First);
    const auto _UNth = _Get_unwrapped(_Nth);
    auto _ULast      = _Get_unwrapped(_Last);
    if (_UNth == _ULast) {
        return; 
    }

    while (_ISORT_MAX < _ULast - _UFirst) { 
        auto _UMid = _Partition_by_median_guess_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));

        if (_UMid.second <= _UNth) {
            _UFirst = _UMid.second;
        } else if (_UMid.first <= _UNth) {
            return; 
        } else {
            _ULast = _UMid.first;
        }
    }

    _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)); 
}

template <class _RanIt>
inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last) { 
    ::std:: nth_element(_First, _Nth, _Last, less<>{});
}


























































































#line 8385 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1) {
        if (_Debug_lt_pred(_Pred, *_UFirst2, *_UFirst1)) {
            return false;
        }

        if (!_Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst2;
        }
    }

    return _UFirst2 == _ULast2;
}

template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: includes(_First1, _Last1, _First2, _Last2, less<>{});
}





























































































#line 8509 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UDest) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UFirst2;
        } else { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}



































































































#line 8646 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_intersection(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) {
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            ++_UFirst2;
        } else {
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}































































































#line 8778 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else {
            if (!_Pred(*_UFirst2, *_UFirst1)) {
                ++_UFirst1;
            }

            ++_UFirst2;
        }
    }

    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst1, _ULast1, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}



























































































#line 8907 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_symmetric_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UDest;
            ++_UFirst2;
        } else { 
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_symmetric_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}














































































































#line 9058 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_Debug_lt_pred(_Pred, *_Found, *_First)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Max_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: max_element(_First, _Last, less<>{});
}
































































#line 9149 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_Debug_lt_pred(_Pred, *_First, *_Found)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: min_element(_First, _Last, less<>{});
}
































































#line 9240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _FwdIt, class _Pr>
constexpr pair<_FwdIt, _FwdIt> _Minmax_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    pair<_FwdIt, _FwdIt> _Found(_First, _First);

    if (_First != _Last) {
        while (++_First != _Last) { 
            _FwdIt _Next = _First;
            if (++_Next == _Last) { 
                if (_Debug_lt_pred(_Pred, *_First, *_Found.first)) {
                    _Found.first = _First;
                } else if (!_Debug_lt_pred(_Pred, *_First, *_Found.second)) {
                    _Found.second = _First;
                }
            } else { 
                if (_Debug_lt_pred(_Pred, *_Next, *_First)) { 
                    if (_Debug_lt_pred(_Pred, *_Next, *_Found.first)) {
                        _Found.first = _Next;
                    }
                    if (!_Debug_lt_pred(_Pred, *_First, *_Found.second)) {
                        _Found.second = _First;
                    }
                } else { 
                    if (_Debug_lt_pred(_Pred, *_First, *_Found.first)) {
                        _Found.first = _First;
                    }
                    if (!_Debug_lt_pred(_Pred, *_Next, *_Found.second)) {
                        _Found.second = _Next;
                    }
                }
                _First = _Next;
            }
        }
    }

    return _Found;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _Result = _Minmax_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
    _Seek_wrapped(_Last, _Result.second);
    _Seek_wrapped(_First, _Result.first);
    return {_First, _Last};
}

template <class _FwdIt>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last) {
    
    return ::std:: minmax_element(_First, _Last, less<>{});
}








































































































#line 9399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: max) (_Ilist, less<>{});
}


































































template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: min) (_Ilist, less<>{});
}


























































template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Debug_lt_pred(_Pred, _Right, _Left)))  {
    
    if (_Debug_lt_pred(_Pred, _Right, _Left)) {
        return {_Right, _Left};
    }

    return {_Left, _Right};
}

template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    pair<const _Ty*, const _Ty*> _Res = _Minmax_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return pair<_Ty, _Ty>(*_Res.first, *_Res.second);
}

template <class _Ty>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(const _Ty& _Left, const _Ty& _Right) noexcept(
    noexcept(_Right < _Left))  {
    
    if (_Right < _Left) {
        do { if (!(_Left < _Right)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm", 9571, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid comparator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm", 9571, 0); } while (false); } ; } while (false);
        return {_Right, _Left};
    }

    return {_Left, _Right};
}

template <class _Ty>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist) {
    
    return ::std:: minmax(_Ilist, less<>{});
}

































































































template <class _BidIt, class _Pr>
inline bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }

    for (;;) { 
        auto _UNext1 = _UNext;
        if (_Debug_lt_pred(_Pred, *--_UNext, *_UNext1)) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!_Debug_lt_pred(_Pred, *_UNext, *_UMid));

            ::std:: iter_swap(_UNext, _UMid);
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }

        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}

template <class _BidIt>
inline bool next_permutation(_BidIt _First, _BidIt _Last) {
    
    return ::std:: next_permutation(_First, _Last, less<>{});
}








































































template <class _BidIt, class _Pr>
inline bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }

    for (;;) { 
        auto _UNext1 = _UNext;
        if (_Debug_lt_pred(_Pred, *_UNext1, *--_UNext)) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!_Debug_lt_pred(_Pred, *_UMid, *_UNext));

            ::std:: iter_swap(_UNext, _UMid);
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }

        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}

template <class _BidIt>
inline bool prev_permutation(_BidIt _First, _BidIt _Last) {
    
    return ::std:: prev_permutation(_First, _Last, less<>{});
}








































































template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt is_sorted_until(const _FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; ++_UFirst) {
            if (_Debug_lt_pred(_Pred, *_UNext, *_UFirst)) {
                _ULast = _UNext;
                break;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

template <class _FwdIt, class _Pr>
[[nodiscard]] inline bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return ::std:: is_sorted_until(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}

template <class _FwdIt>
[[nodiscard]] inline _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last) {
    
    return ::std:: is_sorted_until(_First, _Last, less<>{});
}

template <class _FwdIt>
[[nodiscard]] inline bool is_sorted(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: is_sorted(_First, _Last, less<>{});
}






















































































































































































































#line 10149 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"

}


#pragma warning(pop)
#pragma pack(pop)
#line 10156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"
#line 10157 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\algorithm"
#pragma external_header(pop)
#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"





#pragma once










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_conditional_explicit_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_conditional_explicit_v0<true, tuple<_Dests...>, _Srcs...> =
    !conjunction_v<is_convertible<_Srcs, _Dests>...>;

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_conditional_explicit_v =
    _Tuple_conditional_explicit_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;
























#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_constructible_v =
    _Tuple_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_constructible_val : bool_constant<_Tuple_constructible_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_nothrow_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_constructible_v =
    _Tuple_nothrow_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_assignable<_Dests&, _Srcs>...>; 

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_assignable_v =
    _Tuple_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_assignable_val : bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
 constexpr bool _Tuple_nothrow_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>; 

template <class _Dest, class... _Srcs>
 constexpr bool _Tuple_nothrow_assignable_v =
    _Tuple_nothrow_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;


template <class _Myself, class... _Other>
struct _Tuple_convert_copy_val : true_type {};

template <class _This, class _Uty>
struct _Tuple_convert_copy_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, const tuple<_Uty>&>,
          is_convertible<const tuple<_Uty>&, _This>>> {};


template <class _Myself, class... _Other>
struct _Tuple_convert_move_val : true_type {};

template <class _This, class _Uty>
struct _Tuple_convert_move_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, tuple<_Uty>>,
          is_convertible<tuple<_Uty>, _This>>> {};


template <class _Myself, class _This2, class... _Rest2>
struct _Tuple_perfect_val : true_type {};

template <class _Myself, class _This2>
struct _Tuple_perfect_val<_Myself, _This2>
    : bool_constant<!is_same_v<_Myself, remove_const_t<remove_reference_t<_This2>>>> {};

struct _Ignore { 
    template <class _Ty>
    constexpr const _Ignore& operator=(const _Ty&) const noexcept  {
        
        return *this;
    }
};

 constexpr _Ignore ignore{};






template <class _Ty>
struct _Tuple_val { 
    constexpr _Tuple_val() : _Val() {}

    template <class _Other>
    constexpr _Tuple_val(_Other&& _Arg) : _Val(::std:: forward<_Other>(_Arg)) {}

    template <class _Alloc, class... _Other, enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
    constexpr _Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg) : _Val(::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: negation<::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(::std:: forward<_Other>(_Arg)..., _Al) {}

    _Ty _Val;
};

struct _Exact_args_t {
    explicit _Exact_args_t() = default;
}; 

struct _Unpack_tuple_t {
    explicit _Unpack_tuple_t() = default;
}; 

struct _Alloc_exact_args_t {
    explicit _Alloc_exact_args_t() = default;
}; 

struct _Alloc_unpack_tuple_t {
    explicit _Alloc_unpack_tuple_t() = default;
}; 

template <class... _Types>
class tuple;

template <>
class tuple<> { 
public:
    constexpr tuple() noexcept = default; 

    constexpr tuple(const tuple&) noexcept  {} 

    template <class _Alloc>
    inline tuple(allocator_arg_t, const _Alloc&) noexcept  {}

    template <class _Alloc>
    inline tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept  {}

    template <class _Tag, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag) noexcept  {}

    template <class _Tag, class _Alloc, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc&) noexcept  {}

    constexpr tuple& operator=(const tuple&) = default;

    inline void swap(tuple&) noexcept {}

    constexpr bool _Equals(const tuple&) const noexcept {
        return true;
    }






    [[nodiscard]] constexpr bool _Less(const tuple&) const noexcept {
        return false;
    }
#line 235 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"
};

template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { 
public:
    using _This_type = _This;
    using _Mybase    = tuple<_Rest...>;

    template <class _Tag, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...), _Myfirst(::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right)
        : tuple(_Unpack_tuple_t{}, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _Tag, class _Alloc, class _This2, class... _Rest2,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
          _Myfirst(_Al, allocator_arg, ::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Alloc, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}


    template <class _This2 = _This,
        enable_if_t<conjunction_v<::std:: is_default_constructible<_This2>, ::std:: is_default_constructible<_Rest>...>,
            int>           = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>,
            is_nothrow_default_constructible<_Rest>...>) 
        : _Mybase(), _Myfirst() {}

















#line 297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>) tuple(
        const _This& _This_arg, const _Rest&... _Rest_arg) noexcept(conjunction_v<is_nothrow_copy_constructible<_This2>,
        is_nothrow_copy_constructible<_Rest>...>) 
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}














#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _This2, class... _Rest2,
        enable_if_t<conjunction_v<::std:: _Tuple_perfect_val<tuple, _This2, _Rest2...>,
                        ::std:: _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>) tuple(_This2&& _This_arg,
        _Rest2&&... _Rest_arg) noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) 
        : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}
















#line 345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

    tuple(const tuple&) = default;
    tuple(tuple&&)      = default;


    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other&...>,
                                               ::std:: _Tuple_convert_copy_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(const tuple<_Other...>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}














#line 372 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other...>,
                                               ::std:: _Tuple_convert_move_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(tuple<_Other...>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}














#line 395 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(const pair<_First, _Second>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}












#line 416 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>) tuple(
        pair<_First, _Second>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}










#line 433 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _Alloc, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: is_default_constructible<_This2>, ::std:: is_default_constructible<_Rest>...>,
            int> = 0>
    inline explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple(allocator_arg_t, const _Alloc& _Al)
        : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg) {}















#line 458 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    inline explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}










#line 476 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<conjunction_v<::std:: _Tuple_perfect_val<tuple, _This2, _Rest2...>,
                        ::std:: _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    inline explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>)
        tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}














#line 500 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
    inline tuple(allocator_arg_t, const _Alloc& _Al, tuple&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}


    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other&...>,
                        ::std:: _Tuple_convert_copy_val<tuple, _Other...>>,
            int> = 0>
    inline explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}














#line 533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other...>,
                        ::std:: _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    inline explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}












#line 555 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    inline explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}










#line 573 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"


    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    inline explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>)
        tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}










#line 591 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

    tuple& operator=(const volatile tuple&) = delete;

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_copy_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_copy_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    inline tuple& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_move_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_move_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    inline tuple& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {
        _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<_Mybase>(_Right._Get_rest());
        return *this;
    }

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, const _Other&...>>,
                                   int> = 0>
    inline tuple& operator=(const tuple<_Other...>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _Other&...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, _Other...>>,
                                   int> = 0>
    inline tuple& operator=(tuple<_Other...>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _Other...>)  {
        _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }

    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
    inline tuple& operator=(const pair<_First, _Second>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>)  {
        _Myfirst._Val             = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }

    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
    inline tuple& operator=(pair<_First, _Second>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _First, _Second>)  {
        _Myfirst._Val             = ::std:: forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
        return *this;
    }

    inline void swap(tuple& _Right) noexcept(
        conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>) {
        _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
        _Mybase::swap(_Right._Get_rest());
    }

    constexpr _Mybase& _Get_rest() noexcept { 
        return *this;
    }

    constexpr const _Mybase& _Get_rest() const noexcept { 
        return *this;
    }

    template <class... _Other>
    constexpr bool _Equals(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val == _Right._Myfirst._Val && _Mybase::_Equals(_Right._Get_rest());
    }












    template <class... _Other>
    [[nodiscard]] constexpr bool _Less(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val < _Right._Myfirst._Val
            || (!(_Right._Myfirst._Val < _Myfirst._Val) && _Mybase::_Less(_Right._Get_rest()));
    }
#line 689 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept;

    _Tuple_val<_This> _Myfirst; 
};
















#line 736 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Equals(_Right);
}










template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator!=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Left == _Right);
}
#line 757 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator<(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Less(_Right);
}

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator>=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Left < _Right);
}

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator>(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return _Right < _Left;
}

template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator<=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Right < _Left);
}
#line 779 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

template <class... _Types, enable_if_t<conjunction_v<::std:: _Is_swappable<_Types>...>, int> = 0>
inline void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    return _Left.swap(_Right);
}

template <class _Ty, class _Tuple>
struct _Tuple_element {}; 

template <class _This, class... _Rest>
struct _Tuple_element<_This, tuple<_This, _Rest...>> { 
    static_assert(!_Is_any_of_v<_This, _Rest...>, "duplicate type T in get<T>(tuple)");
    using _Ttype = tuple<_This, _Rest...>;
};

template <class _Ty, class _This, class... _Rest>
struct _Tuple_element<_Ty, tuple<_This, _Rest...>> { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Rest...>>::_Ttype;
};

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {
    
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _This, class... _Rest>
template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int>>
constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Exact_args_t{}, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

template <class _This, class... _Rest>
template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
    enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int>>
constexpr tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

template <class... _Types>
[[nodiscard]] constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { 
    using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
    return _Ttype(::std:: forward<_Types>(_Args)...);
}

template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&...> tie(_Types&... _Args) noexcept { 
    using _Ttype = tuple<_Types&...>;
    return _Ttype(_Args...);
}

template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { 
    return tuple<_Types&&...>(::std:: forward<_Types>(_Args)...);
}

template <class _Seq_type1, class _Seq_type2>
struct _Cat_sequences;

template <size_t... _Indexes1, size_t... _Indexes2>
struct _Cat_sequences<index_sequence<_Indexes1...>,
    index_sequence<_Indexes2...>> { 
    using type = index_sequence<_Indexes1..., _Indexes2...>;
};

template <class _Ty, size_t _Size>
class array;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;

template <class _Ty, class... _For_array>
struct _View_as_tuple { 
    static_assert(_Always_false<_Ty>, "Unsupported tuple_cat arguments.");
};

template <class... _Types>
struct _View_as_tuple<tuple<_Types...>> { 
    using type = tuple<_Types...>;
};

template <class _Ty1, class _Ty2>
struct _View_as_tuple<pair<_Ty1, _Ty2>> { 
    using type = tuple<_Ty1, _Ty2>;
};

template <class _Ty, class... _Types>
struct _View_as_tuple<array<_Ty, 0>, _Types...> { 
    using type = tuple<_Types...>;
};

template <class _Ty, size_t _Size, class... _Types>
struct _View_as_tuple<array<_Ty, _Size>, _Types...>
    : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...> { 
};

template <size_t _Nx, class _Ty>
struct _Repeat_for : integral_constant<size_t, _Nx> {}; 

template <class _Ret, class _Kx_arg, class _Ix_arg, size_t _Ix_next, class... _Tuples>
struct _Tuple_cat2 { 
    static_assert(sizeof...(_Tuples) == 0, "Unsupported tuple_cat arguments.");
    using type        = _Ret;
    using _Kx_arg_seq = _Kx_arg;
    using _Ix_arg_seq = _Ix_arg;
};

template <class... _Types1, class _Kx_arg, size_t... _Ix, size_t _Ix_next, class... _Types2, class... _Rest>
struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, index_sequence<_Ix...>, _Ix_next, tuple<_Types2...>, _Rest...>
    : _Tuple_cat2<tuple<_Types1..., _Types2...>, typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
          index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>, _Ix_next + 1,
          _Rest...> { 
};

template <class... _Tuples>
struct _Tuple_cat1 : _Tuple_cat2<tuple<>, index_sequence<>, index_sequence<>, 0,
                         typename _View_as_tuple<decay_t<_Tuples>>::type...> { 
                                                                               
};

template <class _Ret, size_t... _Kx, size_t... _Ix, class _Ty>
constexpr _Ret _Tuple_cat(index_sequence<_Kx...>, index_sequence<_Ix...>, _Ty&& _Arg) { 
    return _Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...);
}

template <class... _Tuples>
[[nodiscard]] constexpr typename _Tuple_cat1<_Tuples...>::type tuple_cat(_Tuples&&... _Tpls) { 
    using _Cat1 = _Tuple_cat1<_Tuples...>;
    return _Tuple_cat<typename _Cat1::type>(typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
        ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...));
}

























#line 995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

template <class... _Types, class _Alloc>
struct uses_allocator<tuple<_Types...>, _Alloc> : true_type {}; 


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: get;
    using ::std:: ignore;
    using ::std:: make_tuple;
    using ::std:: ref;
    using ::std:: tie;
    using ::std:: tuple;
} 
#line 1009 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"

}



#pragma warning(pop)
#pragma pack(pop)
#line 1017 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"
#line 1018 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\tuple"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"






#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"




#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {


template <class _Ty = void>
struct divides {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left / _Right;
    }
};

template <class _Ty = void>
struct modulus {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left % _Right;
    }
};

template <class _Ty = void>
struct negate {
     typedef _Ty argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left) const {
        return -_Left;
    }
};



template <class _Ty = void>
struct logical_and {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left && _Right;
    }
};

template <class _Ty = void>
struct logical_or {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left || _Right;
    }
};

template <class _Ty = void>
struct logical_not {
     typedef _Ty argument_type;
     typedef bool result_type;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left) const {
        return !_Left;
    }
};

template <class _Ty = void>
struct bit_and {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left & _Right;
    }
};

template <class _Ty = void>
struct bit_or {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left | _Right;
    }
};

template <class _Ty = void>
struct bit_xor {
     typedef _Ty first_argument_type;
     typedef _Ty second_argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left ^ _Right;
    }
};

template <class _Ty = void>
struct bit_not {
     typedef _Ty argument_type;
     typedef _Ty result_type;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left) const {
        return ~_Left;
    }
};



template <>
struct divides<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right)) {
        return ::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

template <>
struct modulus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right)) {
        return ::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

template <>
struct negate<void> {
    template <class _Ty>
    [[nodiscard]] constexpr auto operator()(_Ty&& _Left) const -> decltype(-::std:: forward<_Ty>(_Left)) {
        return -::std:: forward<_Ty>(_Left);
    }

    using is_transparent = int;
};



template <>
struct logical_and<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right)) {
        return ::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

template <>
struct logical_or<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right)) {
        return ::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

template <>
struct logical_not<void> {
    template <class _Ty>
    [[nodiscard]] constexpr auto operator()(_Ty&& _Left) const -> decltype(!::std:: forward<_Ty>(_Left)) {
        return !::std:: forward<_Ty>(_Left);
    }

    using is_transparent = int;
};

template <>
struct bit_and<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right)) {
        return ::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

template <>
struct bit_or<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right)) {
        return ::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

template <>
struct bit_xor<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right)) {
        return ::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

template <>
struct bit_not<void> {
    template <class _Ty>
    [[nodiscard]] constexpr auto operator()(_Ty&& _Left) const -> decltype(~::std:: forward<_Ty>(_Left)) {
        return ~::std:: forward<_Ty>(_Left);
    }

    using is_transparent = int;
};


__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Fn>
class  unary_negate {
public:
    using argument_type = typename _Fn::argument_type;
    using result_type   = bool;

    constexpr explicit unary_negate(const _Fn& _Func) : _Functor(_Func) {}

    [[nodiscard]] constexpr bool operator()(const argument_type& _Left) const {
        return !_Functor(_Left);
    }

private:
    _Fn _Functor;
};

template <class _Fn>
 [[nodiscard]] constexpr unary_negate<_Fn> not1(const _Fn& _Func) {
    return unary_negate<_Fn>(_Func);
}

template <class _Fn>
class  binary_negate {
public:
    using first_argument_type  = typename _Fn::first_argument_type;
    using second_argument_type = typename _Fn::second_argument_type;
    using result_type          = bool;

    constexpr explicit binary_negate(const _Fn& _Func) : _Functor(_Func) {}

    [[nodiscard]] constexpr bool operator()(const first_argument_type& _Left, const second_argument_type& _Right) const {
        return !_Functor(_Left, _Right);
    }

private:
    _Fn _Functor;
};

template <class _Fn>
 [[nodiscard]] constexpr binary_negate<_Fn> not2(const _Fn& _Func) {
    return binary_negate<_Fn>(_Func);
}
__pragma(warning(pop))
#line 300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"


__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Fn>
class binder1st : public unary_function<typename _Fn::second_argument_type,
                      typename _Fn::result_type> { 
public:
    using _Base         = unary_function<typename _Fn::second_argument_type, typename _Fn::result_type>;
    using argument_type = typename _Base::argument_type;
    using result_type   = typename _Base::result_type;

    binder1st(const _Fn& _Func, const typename _Fn::first_argument_type& _Left) : op(_Func), value(_Left) {}

    result_type operator()(const argument_type& _Right) const {
        return op(value, _Right);
    }

    result_type operator()(argument_type& _Right) const {
        return op(value, _Right);
    }

protected:
    _Fn op;
    typename _Fn::first_argument_type value; 
};

template <class _Fn, class _Ty>
[[nodiscard]] binder1st<_Fn> bind1st(const _Fn& _Func, const _Ty& _Left) {
    typename _Fn::first_argument_type _Val(_Left);
    return binder1st<_Fn>(_Func, _Val);
}

template <class _Fn>
class binder2nd : public unary_function<typename _Fn::first_argument_type,
                      typename _Fn::result_type> { 
public:
    using _Base         = unary_function<typename _Fn::first_argument_type, typename _Fn::result_type>;
    using argument_type = typename _Base::argument_type;
    using result_type   = typename _Base::result_type;

    binder2nd(const _Fn& _Func, const typename _Fn::second_argument_type& _Right) : op(_Func), value(_Right) {}

    result_type operator()(const argument_type& _Left) const {
        return op(_Left, value);
    }

    result_type operator()(argument_type& _Left) const {
        return op(_Left, value);
    }

protected:
    _Fn op;
    typename _Fn::second_argument_type value; 
};

template <class _Fn, class _Ty>
[[nodiscard]] binder2nd<_Fn> bind2nd(const _Fn& _Func, const _Ty& _Right) {
    typename _Fn::second_argument_type _Val(_Right);
    return binder2nd<_Fn>(_Func, _Val);
}
__pragma(warning(pop))

template <class _Arg, class _Result, class _Fn = _Result (*)(_Arg)>
class pointer_to_unary_function : public unary_function<_Arg, _Result> { 
public:
    explicit pointer_to_unary_function(_Fn _Left) : _Pfun(_Left) {}

    _Result operator()(_Arg _Left) const {
        return _Pfun(_Left);
    }

protected:
    _Fn _Pfun; 
};

template <class _Arg1, class _Arg2, class _Result, class _Fn = _Result (*)(_Arg1, _Arg2)>
class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result> { 
public:
    explicit pointer_to_binary_function(_Fn _Left) : _Pfun(_Left) {}

    _Result operator()(_Arg1 _Left, _Arg2 _Right) const {
        return _Pfun(_Left, _Right);
    }

protected:
    _Fn _Pfun; 
};













template <class _Arg, class _Result> [[nodiscard]] pointer_to_unary_function<_Arg, _Result, _Result(__cdecl*)(_Arg)> ptr_fun( _Result(__cdecl* _Left)(_Arg)) { return pointer_to_unary_function<_Arg, _Result, _Result(__cdecl*)(_Arg)>(_Left); } template <class _Arg1, class _Arg2, class _Result> [[nodiscard]] pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__cdecl*)(_Arg1, _Arg2)> ptr_fun( _Result(__cdecl* _Left)(_Arg1, _Arg2)) { return pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__cdecl*)(_Arg1, _Arg2)>(_Left); }    template <class _Arg, class _Result> [[nodiscard]] pointer_to_unary_function<_Arg, _Result, _Result(__vectorcall*)(_Arg)> ptr_fun( _Result(__vectorcall* _Left)(_Arg)) { return pointer_to_unary_function<_Arg, _Result, _Result(__vectorcall*)(_Arg)>(_Left); } template <class _Arg1, class _Arg2, class _Result> [[nodiscard]] pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__vectorcall*)(_Arg1, _Arg2)> ptr_fun( _Result(__vectorcall* _Left)(_Arg1, _Arg2)) { return pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__vectorcall*)(_Arg1, _Arg2)>(_Left); }


template <class _Result, class _Ty>
class mem_fun_t : public unary_function<_Ty*, _Result> { 
public:
    explicit mem_fun_t(_Result (_Ty::*_Pm)()) : _Pmemfun(_Pm) {}

    _Result operator()(_Ty* _Pleft) const {
        return (_Pleft->*_Pmemfun)();
    }

private:
    _Result (_Ty::*_Pmemfun)(); 
};

template <class _Result, class _Ty, class _Arg>
class mem_fun1_t : public binary_function<_Ty*, _Arg, _Result> { 
public:
    explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg)) : _Pmemfun(_Pm) {}

    _Result operator()(_Ty* _Pleft, _Arg _Right) const {
        return (_Pleft->*_Pmemfun)(_Right);
    }

private:
    _Result (_Ty::*_Pmemfun)(_Arg); 
};

template <class _Result, class _Ty>
class const_mem_fun_t : public unary_function<const _Ty*, _Result> { 
public:
    explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const) : _Pmemfun(_Pm) {}

    _Result operator()(const _Ty* _Pleft) const {
        return (_Pleft->*_Pmemfun)();
    }

private:
    _Result (_Ty::*_Pmemfun)() const; 
};

template <class _Result, class _Ty, class _Arg>
class const_mem_fun1_t
    : public binary_function<const _Ty*, _Arg, _Result> { 
public:
    explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const) : _Pmemfun(_Pm) {}

    _Result operator()(const _Ty* _Pleft, _Arg _Right) const {
        return (_Pleft->*_Pmemfun)(_Right);
    }

private:
    _Result (_Ty::*_Pmemfun)(_Arg) const; 
};

template <class _Result, class _Ty>
[[nodiscard]] mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)()) {
    return mem_fun_t<_Result, _Ty>(_Pm);
}

template <class _Result, class _Ty, class _Arg>
[[nodiscard]] mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg)) {
    return mem_fun1_t<_Result, _Ty, _Arg>(_Pm);
}

template <class _Result, class _Ty>
[[nodiscard]] const_mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)() const) {
    return const_mem_fun_t<_Result, _Ty>(_Pm);
}

template <class _Result, class _Ty, class _Arg>
[[nodiscard]] const_mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg) const) {
    return const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm);
}

template <class _Result, class _Ty>
class mem_fun_ref_t : public unary_function<_Ty, _Result> { 
public:
    explicit mem_fun_ref_t(_Result (_Ty::*_Pm)()) : _Pmemfun(_Pm) {}

    _Result operator()(_Ty& _Left) const {
        return (_Left.*_Pmemfun)();
    }

private:
    _Result (_Ty::*_Pmemfun)(); 
};

template <class _Result, class _Ty, class _Arg>
class mem_fun1_ref_t
    : public binary_function<_Ty, _Arg, _Result> { 
public:
    explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg)) : _Pmemfun(_Pm) {}

    _Result operator()(_Ty& _Left, _Arg _Right) const {
        return (_Left.*_Pmemfun)(_Right);
    }

private:
    _Result (_Ty::*_Pmemfun)(_Arg); 
};

template <class _Result, class _Ty>
class const_mem_fun_ref_t : public unary_function<_Ty, _Result> { 
public:
    explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const) : _Pmemfun(_Pm) {}

    _Result operator()(const _Ty& _Left) const {
        return (_Left.*_Pmemfun)();
    }

private:
    _Result (_Ty::*_Pmemfun)() const; 
};

template <class _Result, class _Ty, class _Arg>
class const_mem_fun1_ref_t
    : public binary_function<_Ty, _Arg, _Result> { 
public:
    explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const) : _Pmemfun(_Pm) {}

    _Result operator()(const _Ty& _Left, _Arg _Right) const {
        return (_Left.*_Pmemfun)(_Right);
    }

private:
    _Result (_Ty::*_Pmemfun)(_Arg) const; 
};

template <class _Result, class _Ty>
[[nodiscard]] mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)()) {
    return mem_fun_ref_t<_Result, _Ty>(_Pm);
}

template <class _Result, class _Ty, class _Arg>
[[nodiscard]] mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun_ref(_Result (_Ty::*_Pm)(_Arg)) {
    return mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm);
}

template <class _Result, class _Ty>
[[nodiscard]] const_mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)() const) {
    return const_mem_fun_ref_t<_Result, _Ty>(_Pm);
}

template <class _Result, class _Ty, class _Arg>
[[nodiscard]] const_mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const) {
    return const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm);
}
#line 551 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

template <class _Memptr>
class _Mem_fn : public _Weak_types<_Memptr> {
private:
    _Memptr _Pm;

public:
    constexpr explicit _Mem_fn(_Memptr _Val) noexcept : _Pm(_Val) {}

    template <class... _Types>
    inline auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...)))
            -> decltype(::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...)) {
        return ::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...);
    }
};

template <class _Rx, class _Ty>
[[nodiscard]] inline _Mem_fn<_Rx _Ty::*> mem_fn(_Rx _Ty::*_Pm) noexcept {
    return _Mem_fn<_Rx _Ty::*>(_Pm);
}























































#line 628 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

class bad_function_call : public exception { 
public:
    bad_function_call() noexcept {}

    [[nodiscard]] const char*  what() const noexcept override {
        
        return "bad function call";
    }
};

[[noreturn]]  void __cdecl _Xbad_function_call();

struct _Unforced { 
    explicit _Unforced() = default;
};


template <class _Rx, bool = is_void_v<_Rx>>
struct _Invoker_ret { 
    template <class _Fx, class... _Valtys>
    static inline void _Call(_Fx&& _Func, _Valtys&&... _Vals) noexcept(_Select_invoke_traits<_Fx,
        _Valtys...>::_Is_nothrow_invocable::value) { 
        ::std:: invoke(static_cast<_Fx&&>(_Func), static_cast<_Valtys&&>(_Vals)...);
    }
};

template <class _Rx>
struct _Invoker_ret<_Rx, false> { 
    template <class _Fx, class... _Valtys>
    static inline _Rx _Call(_Fx&& _Func, _Valtys&&... _Vals) noexcept(_Select_invoke_traits<_Fx,
        _Valtys...>::template _Is_nothrow_invocable_r<_Rx>::value) { 
        return ::std:: invoke(static_cast<_Fx&&>(_Func), static_cast<_Valtys&&>(_Vals)...);
    }
};

template <>
struct _Invoker_ret<_Unforced, false> { 
    template <class _Fx, class... _Valtys>
    static inline auto _Call(_Fx&& _Func, _Valtys&&... _Vals) noexcept(
        _Select_invoke_traits<_Fx, _Valtys...>::_Is_nothrow_invocable::value)
        -> decltype(::std:: invoke(static_cast<_Fx&&>(_Func), static_cast<_Valtys&&>(_Vals)...)) { 
        return ::std:: invoke(static_cast<_Fx&&>(_Func), static_cast<_Valtys&&>(_Vals)...);
    }
};

template <class _Fty>
class function;

template <class _Ty>
 constexpr bool _Testable_callable_v =
    disjunction_v<is_pointer<_Ty>, _Is_specialization<_Ty, function>, is_member_pointer<_Ty>>;

template <class _Ty>
bool _Test_callable(const _Ty& _Arg) noexcept { 
    if constexpr (_Testable_callable_v<_Ty>) {
        return !!_Arg;
    } else {
        return true;
    }
}

template <class _Rx, class... _Types>
class __declspec(novtable) _Func_base { 
public:
    virtual _Func_base* _Copy(void*) const                 = 0;
    virtual _Func_base* _Move(void*) noexcept              = 0;
    virtual _Rx _Do_call(_Types&&...)                      = 0;
    virtual const type_info& _Target_type() const noexcept = 0;
    virtual void _Delete_this(bool) noexcept               = 0;


    const void* _Target(const type_info& _Info) const noexcept {
        return _Target_type() == _Info ? _Get() : nullptr;
    }
#line 704 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

    _Func_base()                  = default;
    _Func_base(const _Func_base&) = delete;
    _Func_base& operator=(const _Func_base&) = delete;
    

private:
    virtual const void* _Get() const noexcept = 0;
};

constexpr size_t _Space_size = (_Small_object_num_ptrs - 1) * sizeof(void*);

template <class _Impl> 
 constexpr bool _Is_large = sizeof(_Impl) > _Space_size || alignof(_Impl) > alignof(max_align_t)
                                    || !_Impl::_Nothrow_move::value;


template <class _Callable, class _Alloc, class _Rx, class... _Types>
class _Func_impl final : public _Func_base<_Rx, _Types...> {
    
public:
    using _Mybase        = _Func_base<_Rx, _Types...>;
    using _Myalty        = _Rebind_alloc_t<_Alloc, _Func_impl>;
    using _Myalty_traits = allocator_traits<_Myalty>;
    using _Nothrow_move  = is_nothrow_move_constructible<_Callable>;

    template <class _Other1, class _Other2>
    _Func_impl(_Other1&& _Val, _Other2&& _Ax)
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Other2>(_Ax), ::std:: forward<_Other1>(_Val)) {}

    

private:
    _Mybase* _Copy(void* _Where) const override {
        auto& _Myax = _Mypair._Get_first();
        if constexpr (_Is_large<_Func_impl>) {
            _Myalty _Rebound(_Myax);
            _Alloc_construct_ptr<_Myalty> _Constructor{_Rebound};
            _Constructor._Allocate();
            _Construct_in_place(*_Constructor._Ptr, _Mypair._Myval2, _Myax);
            return _Constructor._Release();
        } else {
            const auto _Ptr = static_cast<_Func_impl*>(_Where);
            _Construct_in_place(*_Ptr, _Mypair._Myval2, _Myax);
            return _Ptr;
        }
    }

    _Mybase* _Move(void* _Where) noexcept override {
        if constexpr (_Is_large<_Func_impl>) {
            return nullptr;
        } else {
            const auto _Ptr = static_cast<_Func_impl*>(_Where);
            _Construct_in_place(*_Ptr, ::std:: move(_Mypair._Myval2), ::std:: move(_Mypair._Get_first()));
            return _Ptr;
        }
    }

    _Rx _Do_call(_Types&&... _Args) override { 
        return _Invoker_ret<_Rx>::_Call(_Mypair._Myval2, ::std:: forward<_Types>(_Args)...);
    }

    const type_info& _Target_type() const noexcept override {

        return typeid(_Callable);


#line 772 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
    }

    const void* _Get() const noexcept override {
        return ::std:: addressof(_Mypair._Myval2);
    }

    void _Delete_this(bool _Deallocate) noexcept override { 
        _Myalty _Al(_Mypair._Get_first());
        _Destroy_in_place(*this);
        if (_Deallocate) {
            _Deallocate_plain(_Al, this);
        }
    }

    _Compressed_pair<_Alloc, _Callable> _Mypair;
};
#line 789 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

template <class _Callable, class _Rx, class... _Types>
class _Func_impl_no_alloc final : public _Func_base<_Rx, _Types...> {
    
public:
    using _Mybase       = _Func_base<_Rx, _Types...>;
    using _Nothrow_move = is_nothrow_move_constructible<_Callable>;

    template <class _Other, enable_if_t<!is_same_v<_Func_impl_no_alloc, decay_t<_Other>>, int> = 0>
    explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(::std:: forward<_Other>(_Val)) {}

    

private:
    _Mybase* _Copy(void* _Where) const override {
        if constexpr (_Is_large<_Func_impl_no_alloc>) {
            (void) _Where; 
            return _Global_new<_Func_impl_no_alloc>(_Callee);
        } else {
            return ::new (_Where) _Func_impl_no_alloc(_Callee);
        }
    }

    _Mybase* _Move(void* _Where) noexcept override {
        if constexpr (_Is_large<_Func_impl_no_alloc>) {
            (void) _Where; 
            return nullptr;
        } else {
            return ::new (_Where) _Func_impl_no_alloc(::std:: move(_Callee));
        }
    }

    _Rx _Do_call(_Types&&... _Args) override { 
        return _Invoker_ret<_Rx>::_Call(_Callee, ::std:: forward<_Types>(_Args)...);
    }

    const type_info& _Target_type() const noexcept override {

        return typeid(_Callable);


#line 831 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
    }

    const void* _Get() const noexcept override {
        return ::std:: addressof(_Callee);
    }

    void _Delete_this(bool _Dealloc) noexcept override { 
        this->~_Func_impl_no_alloc();
        if (_Dealloc) {
            _Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));
        }
    }

    _Callable _Callee;
};





#line 852 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

template <class _Ret, class... _Types>
class _Func_class : public _Arg_types<_Types...> {
public:
    using result_type = _Ret;

    using _Ptrt = _Func_base<_Ret, _Types...>;

    _Func_class() noexcept {
        _Set(nullptr);
    }

    _Ret operator()(_Types... _Args) const {
        if (_Empty()) {
            _Xbad_function_call();
        }
        const auto _Impl = _Getimpl();
        return _Impl->_Do_call(::std:: forward<_Types>(_Args)...);
    }

    ~_Func_class() noexcept {
        _Tidy();
    }

protected:
    template <class _Fx, class _Function>
    using _Enable_if_callable_t =
        enable_if_t<conjunction_v<negation<is_same<decay_t<_Fx>, _Function>>, _Is_invocable_r<_Ret, _Fx, _Types...>>,
            int>;

    bool _Empty() const noexcept {
        return !_Getimpl();
    }

    void _Reset_copy(const _Func_class& _Right) { 
        if (!_Right._Empty()) {
            _Set(_Right._Getimpl()->_Copy(&_Mystorage));
        }
    }

    void _Reset_move(_Func_class&& _Right) noexcept { 
        if (!_Right._Empty()) {
            if (_Right._Local()) { 
                _Set(_Right._Getimpl()->_Move(&_Mystorage));
                _Right._Tidy();
            } else { 
                _Set(_Right._Getimpl());
                _Right._Set(nullptr);
            }
        }
    }

    template <class _Fx>
    void _Reset(_Fx&& _Val) { 
        if (!_Test_callable(_Val)) { 
            return; 
        }

        using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
        if constexpr (_Is_large<_Impl>) {
            
            _Set(_Global_new<_Impl>(::std:: forward<_Fx>(_Val)));
        } else {
            
            _Set(::new (static_cast<void*>(&_Mystorage)) _Impl(::std:: forward<_Fx>(_Val)));
        }
    }


    template <class _Fx, class _Alloc>
    void _Reset_alloc(_Fx&& _Val, const _Alloc& _Ax) { 
        if (!_Test_callable(_Val)) { 
            return; 
        }

        using _Myimpl = _Func_impl<decay_t<_Fx>, _Alloc, _Ret, _Types...>;
        if constexpr (_Is_large<_Myimpl>) {
            
            using _Alimpl = _Rebind_alloc_t<_Alloc, _Myimpl>;
            _Alimpl _Al(_Ax);
            _Alloc_construct_ptr<_Alimpl> _Constructor{_Al};
            _Constructor._Allocate();
            _Construct_in_place(*_Constructor._Ptr, ::std:: forward<_Fx>(_Val), _Ax);
            _Set(_Unfancy(_Constructor._Release()));
        } else {
            
            const auto _Ptr = reinterpret_cast<_Myimpl*>(&_Mystorage);
            _Construct_in_place(*_Ptr, ::std:: forward<_Fx>(_Val), _Ax);
            _Set(_Ptr);
        }
    }
#line 944 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

    void _Tidy() noexcept {
        if (!_Empty()) { 
            _Getimpl()->_Delete_this(!_Local());
            _Set(nullptr);
        }
    }

    void _Swap(_Func_class& _Right) noexcept { 
        if (!_Local() && !_Right._Local()) { 
            _Ptrt* _Temp = _Getimpl();
            _Set(_Right._Getimpl());
            _Right._Set(_Temp);
        } else { 
            _Func_class _Temp;
            _Temp._Reset_move(::std:: move(*this));
            _Reset_move(::std:: move(_Right));
            _Right._Reset_move(::std:: move(_Temp));
        }
    }


    const type_info& _Target_type() const noexcept {
        return _Getimpl() ? _Getimpl()->_Target_type() : typeid(void);
    }

    const void* _Target(const type_info& _Info) const noexcept {
        return _Getimpl() ? _Getimpl()->_Target(_Info) : nullptr;
    }
#line 974 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

private:
    bool _Local() const noexcept { 
        return _Getimpl() == static_cast<const void*>(&_Mystorage);
    }

    union _Storage { 
        max_align_t _Dummy1; 
        char _Dummy2[_Space_size]; 
        _Ptrt* _Ptrs[_Small_object_num_ptrs]; 
    };

    _Storage _Mystorage;
    enum { _EEN_IMPL = _Small_object_num_ptrs - 1 }; 
    _Ptrt* _Getimpl() const noexcept { 
        return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];
    }

    void _Set(_Ptrt* _Ptr) noexcept { 
        _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;
    }
};

template <class _Tx>
struct _Get_function_impl {
    static_assert(_Always_false<_Tx>, "std::function does not accept non-function types as template arguments.");
};







template <class _Ret, class... _Types> struct _Get_function_impl<_Ret __cdecl(_Types...)> { using type = _Func_class<_Ret, _Types...>; };    template <class _Ret, class... _Types> struct _Get_function_impl<_Ret __vectorcall(_Types...)> { using type = _Func_class<_Ret, _Types...>; };













template <class _Fty>
class function : public _Get_function_impl<_Fty>::type { 
private:
    using _Mybase = typename _Get_function_impl<_Fty>::type;

public:
    function() noexcept {}

    function(nullptr_t) noexcept {}

    function(const function& _Right) {
        this->_Reset_copy(_Right);
    }


    template <class _Fx, typename _Mybase::template _Enable_if_callable_t<_Fx&, function> = 0>


#line 1041 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
    function(_Fx _Func) {
        this->_Reset(::std:: move(_Func));
    }


    template <class _Alloc>
    function(allocator_arg_t, const _Alloc&) noexcept {}

    template <class _Alloc>
    function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept {}

    template <class _Alloc>
    function(allocator_arg_t, const _Alloc& _Ax, const function& _Right) {
        this->_Reset_alloc(_Right, _Ax);
    }


    template <class _Fx, class _Alloc, typename _Mybase::template _Enable_if_callable_t<_Fx&, function> = 0>


#line 1062 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
    function(allocator_arg_t, const _Alloc& _Ax, _Fx _Func) {
        this->_Reset_alloc(::std:: move(_Func), _Ax);
    }
#line 1066 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

    function& operator=(const function& _Right) {
        function(_Right).swap(*this);
        return *this;
    }

    function(function&& _Right) noexcept {
        this->_Reset_move(::std:: move(_Right));
    }


    template <class _Alloc>
    function(allocator_arg_t, const _Alloc& _Al, function&& _Right) {
        this->_Reset_alloc(::std:: move(_Right), _Al);
    }
#line 1082 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

    function& operator=(function&& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            this->_Tidy();
            this->_Reset_move(::std:: move(_Right));
        }
        return *this;
    }


    template <class _Fx, typename _Mybase::template _Enable_if_callable_t<decay_t<_Fx>&, function> = 0>


#line 1096 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
    function& operator=(_Fx&& _Func) {
        function(::std:: forward<_Fx>(_Func)).swap(*this);
        return *this;
    }


    template <class _Fx, class _Alloc>
    void assign(_Fx&& _Func, const _Alloc& _Ax) {
        function(allocator_arg, _Ax, ::std:: forward<_Fx>(_Func)).swap(*this);
    }
#line 1107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

    function& operator=(nullptr_t) noexcept {
        this->_Tidy();
        return *this;
    }

    template <class _Fx>
    function& operator=(reference_wrapper<_Fx> _Func) noexcept {
        this->_Tidy();
        this->_Reset(_Func);
        return *this;
    }

    void swap(function& _Right) noexcept {
        this->_Swap(_Right);
    }

    explicit operator bool() const noexcept {
        return !this->_Empty();
    }


    [[nodiscard]] const type_info& target_type() const noexcept {
        return this->_Target_type();
    }

    template <class _Fx>
    [[nodiscard]] _Fx* target() noexcept {
        return reinterpret_cast<_Fx*>(const_cast<void*>(this->_Target(typeid(_Fx))));
    }

    template <class _Fx>
    [[nodiscard]] const _Fx* target() const noexcept {
        return reinterpret_cast<const _Fx*>(this->_Target(typeid(_Fx)));
    }








#line 1151 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
};


















#line 1171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

template <class _Fty>
void swap(function<_Fty>& _Left, function<_Fty>& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _Fty>
[[nodiscard]] bool operator==(const function<_Fty>& _Other, nullptr_t) noexcept {
    return !_Other;
}


template <class _Fty>
[[nodiscard]] bool operator==(nullptr_t, const function<_Fty>& _Other) noexcept {
    return !_Other;
}

template <class _Fty>
[[nodiscard]] bool operator!=(const function<_Fty>& _Other, nullptr_t) noexcept {
    return static_cast<bool>(_Other);
}

template <class _Fty>
[[nodiscard]] bool operator!=(nullptr_t, const function<_Fty>& _Other) noexcept {
    return static_cast<bool>(_Other);
}
#line 1198 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

template <int _Nx>
struct _Ph { 
    static_assert(_Nx > 0, "invalid placeholder index");
};

template <class _Tx>
struct is_placeholder : integral_constant<int, 0> {}; 

template <int _Nx>
struct is_placeholder<_Ph<_Nx>> : integral_constant<int, _Nx> {}; 

template <class _Tx>
struct is_placeholder<const _Tx> : is_placeholder<_Tx>::type {}; 

template <class _Tx>
struct is_placeholder<volatile _Tx> : is_placeholder<_Tx>::type {}; 

template <class _Tx>
struct is_placeholder<const volatile _Tx> : is_placeholder<_Tx>::type {}; 

template <class _Ty>
 constexpr int is_placeholder_v = is_placeholder<_Ty>::value;

template <class _Ret, class _Fx, class... _Types>
class _Binder;

template <class _Tx>
struct is_bind_expression : false_type {}; 

template <class _Ret, class _Fx, class... _Types>
struct is_bind_expression<_Binder<_Ret, _Fx, _Types...>> : true_type {}; 

template <class _Tx>
struct is_bind_expression<const _Tx> : is_bind_expression<_Tx>::type {}; 

template <class _Tx>
struct is_bind_expression<volatile _Tx> : is_bind_expression<_Tx>::type {}; 

template <class _Tx>
struct is_bind_expression<const volatile _Tx> : is_bind_expression<_Tx>::type {}; 

template <class _Ty>
 constexpr bool is_bind_expression_v = is_bind_expression<_Ty>::value;

template <class _Cv_TiD, bool = _Is_specialization_v<remove_cv_t<_Cv_TiD>, reference_wrapper>,
    bool = is_bind_expression_v<_Cv_TiD>, int = is_placeholder_v<_Cv_TiD>>
struct _Select_fixer;

template <class _Cv_TiD>
struct _Select_fixer<_Cv_TiD, true, false, 0> { 
    template <class _Untuple>
    static constexpr auto _Fix(_Cv_TiD& _Tid, _Untuple&&) noexcept -> typename _Cv_TiD::type& {
        
        return _Tid.get();
    }
};

template <class _Cv_TiD>
struct _Select_fixer<_Cv_TiD, false, true, 0> { 
    template <class _Untuple, size_t... _Jx>
    static constexpr auto _Apply(_Cv_TiD& _Tid, _Untuple&& _Ut, index_sequence<_Jx...>) noexcept(
        noexcept(_Tid(::std:: get<_Jx>(::std:: move(_Ut))...))) -> decltype(_Tid(::std:: get<_Jx>(::std:: move(_Ut))...)) {
        
        return _Tid(::std:: get<_Jx>(::std:: move(_Ut))...);
    }

    template <class _Untuple>
    static constexpr auto _Fix(_Cv_TiD& _Tid, _Untuple&& _Ut) noexcept(
        noexcept(_Apply(_Tid, ::std:: move(_Ut), make_index_sequence<tuple_size_v<_Untuple>>{})))
        -> decltype(_Apply(_Tid, ::std:: move(_Ut), make_index_sequence<tuple_size_v<_Untuple>>{})) {
        
        return _Apply(_Tid, ::std:: move(_Ut), make_index_sequence<tuple_size_v<_Untuple>>{});
    }
};

template <class _Cv_TiD>
struct _Select_fixer<_Cv_TiD, false, false, 0> { 
    template <class _Untuple>
    static constexpr _Cv_TiD& _Fix(_Cv_TiD& _Tid, _Untuple&&) noexcept {
        
        return _Tid;
    }
};

template <class _Cv_TiD, int _Jx>
struct _Select_fixer<_Cv_TiD, false, false, _Jx> { 
    static_assert(_Jx > 0, "invalid is_placeholder value");

    template <class _Untuple>
    static constexpr auto _Fix(_Cv_TiD&, _Untuple&& _Ut) noexcept
        -> decltype(::std:: get<_Jx - 1>(::std:: move(_Ut))) { 
        return ::std:: get<_Jx - 1>(::std:: move(_Ut));
    }
};

template <class _Cv_TiD, class _Untuple>
constexpr auto _Fix_arg(_Cv_TiD& _Tid, _Untuple&& _Ut) noexcept(
    noexcept(_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut))))
    -> decltype(_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut))) { 
    return _Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut));
}

template <class _Ret, size_t... _Ix, class _Cv_FD, class _Cv_tuple_TiD, class _Untuple>
inline auto _Call_binder(_Invoker_ret<_Ret>, index_sequence<_Ix...>, _Cv_FD& _Obj, _Cv_tuple_TiD& _Tpl,
    _Untuple&& _Ut) noexcept(noexcept(_Invoker_ret<_Ret>::_Call(_Obj,
    _Fix_arg(::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...)))
    -> decltype(_Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...)) {
    
    return _Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...);
}

template <class _Ret>
struct _Forced_result_type { 
     typedef _Ret result_type;
};

template <class _Ret, class _Fx>
struct _Binder_result_type { 
    using _Decayed = decay_t<_Fx>;

    using _All_weak_types = _Weak_types<_Decayed>;

    using type =
        conditional_t<is_same_v<_Ret, _Unforced>, _Weak_result_type<_All_weak_types>, _Forced_result_type<_Ret>>;
};

template <class _Ret, class _Fx, class... _Types>
class _Binder : public _Binder_result_type<_Ret, _Fx>::type { 
private:
    using _Seq    = index_sequence_for<_Types...>;
    using _First  = decay_t<_Fx>;
    using _Second = tuple<decay_t<_Types>...>;

    _Compressed_pair<_First, _Second> _Mypair;

public:
    constexpr explicit _Binder(_Fx&& _Func, _Types&&... _Args)
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...) {}





    template <class... _Unbound>
    inline auto operator()(_Unbound&&... _Unbargs) noexcept(noexcept(_Call_binder(_Invoker_ret<_Ret>{}, _Seq{}, _Mypair._Get_first(), _Mypair._Myval2, ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...)))) -> decltype(_Call_binder(_Invoker_ret<_Ret>{}, _Seq{}, _Mypair._Get_first(), _Mypair._Myval2, ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) {
        return _Call_binder(_Invoker_ret<_Ret>{}, _Seq{}, _Mypair._Get_first(), _Mypair._Myval2, ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...));
    }

    template <class... _Unbound>
    inline auto operator()(_Unbound&&... _Unbargs) const noexcept(noexcept(_Call_binder(_Invoker_ret<_Ret>{}, _Seq{}, _Mypair._Get_first(), _Mypair._Myval2, ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))))
        -> decltype(_Call_binder(_Invoker_ret<_Ret>{}, _Seq{}, _Mypair._Get_first(), _Mypair._Myval2, ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) {
        return _Call_binder(_Invoker_ret<_Ret>{}, _Seq{}, _Mypair._Get_first(), _Mypair._Myval2, ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...));
    }


};

template <class _Fx, class... _Types>
[[nodiscard]] inline _Binder<_Unforced, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args) {
    return _Binder<_Unforced, _Fx, _Types...>(::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...);
}

template <class _Ret, class _Fx, class... _Types>
[[nodiscard]] inline _Binder<_Ret, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args) {
    return _Binder<_Ret, _Fx, _Types...>(::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...);
}

namespace placeholders {
     constexpr _Ph<1> _1{};
     constexpr _Ph<2> _2{};
     constexpr _Ph<3> _3{};
     constexpr _Ph<4> _4{};
     constexpr _Ph<5> _5{};
     constexpr _Ph<6> _6{};
     constexpr _Ph<7> _7{};
     constexpr _Ph<8> _8{};
     constexpr _Ph<9> _9{};
     constexpr _Ph<10> _10{};
     constexpr _Ph<11> _11{};
     constexpr _Ph<12> _12{};
     constexpr _Ph<13> _13{};
     constexpr _Ph<14> _14{};
     constexpr _Ph<15> _15{};
     constexpr _Ph<16> _16{};
     constexpr _Ph<17> _17{};
     constexpr _Ph<18> _18{};
     constexpr _Ph<19> _19{};
     constexpr _Ph<20> _20{};
} 












































































#line 1465 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"


template <class _Fty, class _Alloc>
struct uses_allocator<function<_Fty>, _Alloc> : true_type {}; 
#line 1470 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"










































































































































































































































































































































































































































































































































































































































#line 2089 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"













































namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
    using ::std:: bad_function_call;
    using ::std:: bind;
    using ::std:: function;
    using ::std:: is_bind_expression;
    using ::std:: is_placeholder;
    using ::std:: mem_fn;
    using ::std:: swap;
    namespace placeholders {
        using namespace ::std:: placeholders;
    }
} 
#line 2147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"

}



#pragma warning(pop)
#pragma pack(pop)
#line 2155 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
#line 2156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\functional"
#pragma external_header(pop)
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <class _Container>
class back_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;




    using difference_type = void;
#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

    inline explicit back_insert_iterator(_Container& _Cont) noexcept 
        : container(::std:: addressof(_Cont)) {}

    inline back_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        container->push_back(_Val);
        return *this;
    }

    inline back_insert_iterator& operator=(typename _Container::value_type&& _Val) {
        container->push_back(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] inline back_insert_iterator& operator*() noexcept  {
        return *this;
    }

    inline back_insert_iterator& operator++() noexcept  {
        return *this;
    }

    inline back_insert_iterator operator++(int) noexcept  {
        return *this;
    }

protected:
    _Container* container;
};

template <class _Container>
[[nodiscard]] inline back_insert_iterator<_Container> back_inserter(_Container& _Cont) noexcept  {
    
    return back_insert_iterator<_Container>(_Cont);
}

template <class _Container>
class front_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;




    using difference_type = void;
#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

    inline explicit front_insert_iterator(_Container& _Cont) : container(::std:: addressof(_Cont)) {}

    inline front_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        container->push_front(_Val);
        return *this;
    }

    inline front_insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        container->push_front(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] inline front_insert_iterator& operator*() { 
        return *this;
    }

    inline front_insert_iterator& operator++() { 
        return *this;
    }

    inline front_insert_iterator operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
};

template <class _Container>
[[nodiscard]] inline front_insert_iterator<_Container> front_inserter(_Container& _Cont) {
    return front_insert_iterator<_Container>(_Cont);
}

template <class _Container>
class insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;




    using difference_type = void;
    using _Wrapped_iter   = typename _Container::iterator;
#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

    inline insert_iterator(_Container& _Cont, _Wrapped_iter _Where)
        : container(::std:: addressof(_Cont)), iter(::std:: move(_Where)) {}

    inline insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        iter = container->insert(iter, _Val);
        ++iter;
        return *this;
    }

    inline insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        iter = container->insert(iter, ::std:: move(_Val));
        ++iter;
        return *this;
    }

    [[nodiscard]] inline insert_iterator& operator*() { 
        return *this;
    }

    inline insert_iterator& operator++() { 
        return *this;
    }

    inline insert_iterator& operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
    _Wrapped_iter iter;
};

template <class _Container>
[[nodiscard]] inline insert_iterator<_Container> inserter(_Container& _Cont, typename _Container::iterator _Where) {
    return insert_iterator<_Container>(_Cont, _Where);
}







































template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>, class _Diff = ptrdiff_t>
class istream_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = const _Ty*;
    using reference         = const _Ty&;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using istream_type      = basic_istream<_Elem, _Traits>;

    static_assert(conjunction_v<is_default_constructible<_Ty>, is_copy_constructible<_Ty>, is_copy_assignable<_Ty>>,
        "istream_iterator<T> requires T to be default constructible, copy constructible, and copy assignable. "
        "(N4835 [istream.iterator]/2)");

    constexpr istream_iterator() noexcept(is_nothrow_default_constructible_v<_Ty>)  {}






    istream_iterator(istream_type& _Istr) : _Myistr(::std:: addressof(_Istr)) {
        _Getval();
    }

    [[nodiscard]] const _Ty& operator*() const noexcept  {
        do { if (_Myistr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 244, 0, "%s", "The stored stream pointer in_stream must be non-null")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"The stored stream pointer in_stream must be non-null\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 244, 0); } while (false); } ; } while (false);
        return _Myval;
    }

    [[nodiscard]] const _Ty* operator->() const noexcept  {
        do { if (_Myistr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 249, 0, "%s", "The stored stream pointer in_stream must be non-null")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"The stored stream pointer in_stream must be non-null\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 249, 0); } while (false); } ; } while (false);
        return ::std:: addressof(_Myval);
    }

    istream_iterator& operator++() {
        _Getval();
        return *this;
    }

    istream_iterator operator++(int) {
        istream_iterator _Tmp = *this;
        _Getval();
        return _Tmp;
    }

    [[nodiscard]] bool _Equal(const istream_iterator& _Right) const noexcept {
        return _Myistr == _Right._Myistr;
    }







private:
    void _Getval() { 
        do { if (_Myistr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 276, 0, "%s", "The stored stream pointer in_stream must be non-null")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"The stored stream pointer in_stream must be non-null\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 276, 0); } while (false); } ; } while (false);
        if (!(*_Myistr >> _Myval)) {
            _Myistr = nullptr;
        }
    }

    istream_type* _Myistr{nullptr}; 
    _Ty _Myval{}; 
};

template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept  {
    return _Left._Equal(_Right);
}


template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] bool operator!=(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept  {
    return !(_Left == _Right);
}
#line 299 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>>
class ostream_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;



    using difference_type = void;
#line 310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
    using pointer      = void;
    using reference    = void;
    using char_type    = _Elem;
    using traits_type  = _Traits;
    using ostream_type = basic_ostream<_Elem, _Traits>;

    ostream_iterator(ostream_type& _Ostr, const _Elem* const _Delim = nullptr) noexcept 
        : _Mydelim(_Delim), _Myostr(::std:: addressof(_Ostr)) {}

    ostream_iterator& operator=(const _Ty& _Val) { 
        *_Myostr << _Val;
        if (_Mydelim) {
            *_Myostr << _Mydelim;
        }

        return *this;
    }

    [[nodiscard]] ostream_iterator& operator*() noexcept  {
        return *this;
    }

    ostream_iterator& operator++() noexcept  {
        return *this;
    }

    ostream_iterator& operator++(int) noexcept  {
        return *this;
    }

private:
    const _Elem* _Mydelim; 
    ostream_type* _Myostr; 
};

template <class _Elem, class _Traits>
class istreambuf_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Elem;
    using difference_type   = typename _Traits::off_type;
    using pointer           = const _Elem*;
    using reference         = _Elem;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using int_type          = typename traits_type::int_type;
    using streambuf_type    = basic_streambuf<_Elem, _Traits>;
    using istream_type      = basic_istream<_Elem, _Traits>;

    constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}




    istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

    istreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb), _Got(!_Sb), _Val() {}

private:
    class _Istreambuf_proxy {
    public:
        [[nodiscard]] _Elem operator*() const noexcept(is_nothrow_copy_constructible_v<_Elem>)  {
            return _Keep;
        }

    private:
        friend istreambuf_iterator;
        _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) noexcept(
            is_nothrow_copy_constructible_v<_Elem>) 
            : _Strbuf(_Strbuf_), _Keep(_Keep_) {}

        streambuf_type* _Strbuf;
        _Elem _Keep;
    };

public:
    istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept : _Strbuf(_Px._Strbuf), _Got(!_Strbuf), _Val() {}

    [[nodiscard]] _Elem operator*() const {
        if (!_Got) {
            _Peek();
        }


        do { if (_Strbuf) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 394, 0, "%s", "istreambuf_iterator is not dereferenceable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not dereferenceable\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 394, 0); } while (false); } ; } while (false);
#line 396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

        return _Val;
    }

    istreambuf_iterator& operator++() {

        do { if (_Strbuf) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 402, 0, "%s", "istreambuf_iterator is not incrementable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not incrementable\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 402, 0); } while (false); } ; } while (false);
#line 404 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

        _Inc();
        return *this;
    }

    _Istreambuf_proxy operator++(int) {
        if (!_Got) {
            _Peek();
        }

        _Istreambuf_proxy _Tmp{_Strbuf, _Val};
        ++*this;
        return _Tmp;
    }

    [[nodiscard]] bool equal(const istreambuf_iterator& _Right) const {
        if (!_Got) {
            _Peek();
        }

        if (!_Right._Got) {
            _Right._Peek();
        }

        return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);
    }











private:
    void _Inc() { 
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {
            _Strbuf = nullptr;
            _Got    = true;
        } else {
            _Got = false;
        }
    }

    _Elem _Peek() const { 
        int_type _Meta;
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type::to_char_type(_Meta);
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type* _Strbuf; 
    mutable bool _Got; 
    mutable _Elem _Val; 
};

template <class _Elem, class _Traits>
[[nodiscard]] bool operator==(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return _Left.equal(_Right);
}


template <class _Elem, class _Traits>
[[nodiscard]] bool operator!=(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return !(_Left == _Right);
}
#line 481 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

template <class _Elem, class _Traits>
class ostreambuf_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;



    using difference_type = void;
#line 492 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
    using pointer        = void;
    using reference      = void;
    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using ostream_type   = basic_ostream<_Elem, _Traits>;

    ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

    ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}

    ostreambuf_iterator& operator=(_Elem _Right) { 
        if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
            _Failed = true;
        }

        return *this;
    }

    [[nodiscard]] ostreambuf_iterator& operator*() noexcept  {
        return *this;
    }

    ostreambuf_iterator& operator++() noexcept  {
        return *this;
    }

    ostreambuf_iterator& operator++(int) noexcept  {
        return *this;
    }

    [[nodiscard]] bool failed() const noexcept {
        return _Failed;
    }

private:
    bool _Failed = false; 
    streambuf_type* _Strbuf;
};

























































































































































































































































































































































































































































































































































































































































































































































































































































}

namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;

template <class _Ptr>
class checked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "checked_array_iterator requires pointers");

public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;

    constexpr checked_array_iterator() noexcept : _Myarray(nullptr), _Mysize(0), _Myindex(0) {}

    constexpr checked_array_iterator(const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept
        : _Myarray(_Array), _Mysize(_Size), _Myindex(_Index) {
        do { if (_Index <= _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1377, 0, "%s", "checked_array_iterator construction index out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"checked_array_iterator construction index out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1377, 0); } while (false); } ; } while (false);
    }

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myarray + _Myindex;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1389, 0, "%s", "cannot dereference value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized or null checked_array_iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1389, 0); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1390, 0, "%s", "cannot dereference end checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference end checked_array_iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1390, 0); } while (false); } ; } while (false);
        return _Myarray + _Myindex;
    }

    constexpr checked_array_iterator& operator++() noexcept {
        do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1395, 0, "%s", "cannot increment value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized or null checked_array_iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1395, 0); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1396, 0, "%s", "cannot increment checked_array_iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment checked_array_iterator past end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1396, 0); } while (false); } ; } while (false);
        ++_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator++(int) noexcept {
        checked_array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator--() noexcept {
        do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1408, 0, "%s", "cannot decrement value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized or null checked_array_iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1408, 0); } while (false); } ; } while (false);
        do { if (_Myindex != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1409, 0, "%s", "cannot decrement checked_array_iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement checked_array_iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1409, 0); } while (false); } ; } while (false);
        --_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator--(int) noexcept {
        checked_array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator+=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1422, 0, "%s", "cannot seek value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized or null checked_array_iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1422, 0); } while (false); } ; } while (false);
        }

        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1427, 0, "%s", "cannot seek checked_array_iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1427, 0); } while (false); } ; } while (false);
#line 1428 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1432, 0, "%s", "cannot seek checked_array_iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator after end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1432, 0); } while (false); } ; } while (false);
#line 1433 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        }

        _Myindex += _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator+(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }


    [[nodiscard]]
#line 1448 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
    friend constexpr checked_array_iterator operator+(
        const difference_type _Off, const checked_array_iterator<_Ptr>& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr checked_array_iterator& operator-=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1455, 0, "%s", "cannot seek value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized or null checked_array_iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1455, 0); } while (false); } ; } while (false);
        }

        if (_Off > 0) {
            do { if (_Myindex >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1459, 0, "%s", "cannot seek checked_array_iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1459, 0); } while (false); } ; } while (false);
        }

        if (_Off < 0) {
            do { if (_Mysize - _Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1464, 0, "%s", "cannot seek checked_array_iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator after end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1464, 0); } while (false); } ; } while (false);
#line 1465 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        }

        _Myindex -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator-(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1479, 0, "%s", "cannot subtract incompatible checked_array_iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot subtract incompatible checked_array_iterators\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1479, 0); } while (false); } ; } while (false);
#line 1480 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        return static_cast<difference_type>(_Myindex - _Right._Myindex);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1489, 0, "%s", "cannot compare incompatible checked_array_iterators for equality")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot compare incompatible checked_array_iterators for equality\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1489, 0); } while (false); } ; } while (false);
#line 1490 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        return _Myindex == _Right._Myindex;
    }







#line 1500 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
    [[nodiscard]] constexpr bool operator!=(const checked_array_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] constexpr bool operator<(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1506, 0, "%s", "cannot compare incompatible checked_array_iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot compare incompatible checked_array_iterators\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1506, 0); } while (false); } ; } while (false);
#line 1507 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        return _Myindex < _Right._Myindex;
    }

    [[nodiscard]] constexpr bool operator>(const checked_array_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] constexpr bool operator<=(const checked_array_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] constexpr bool operator>=(const checked_array_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 1522 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

    friend constexpr void _Verify_range(
        const checked_array_iterator& _First, const checked_array_iterator& _Last) noexcept {
        do { if (_First._Myarray == _Last._Myarray && _First._Mysize == _Last._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1526, 0, "%s", "mismatching checked_array_iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"mismatching checked_array_iterators\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1526, 0); } while (false); } ; } while (false);
#line 1527 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        do { if (_First._Myindex <= _Last._Myindex) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1527, 0, "%s", "transposed checked_array_iterator range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"transposed checked_array_iterator range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1527, 0); } while (false); } ; } while (false);
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1533, 0, "%s", "cannot seek checked_array_iterator iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1533, 0); } while (false); } ; } while (false);
#line 1534 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1538, 0, "%s", "cannot seek checked_array_iterator iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator iterator after end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator", 1538, 0); } while (false); } ; } while (false);
#line 1539 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
        }
    }

    using _Prevent_inheriting_unwrap = checked_array_iterator;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myarray + _Myindex;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myindex = static_cast<size_t>(_It - _Myarray);
    }

private:
    _Ptr _Myarray; 
    size_t _Mysize; 
    size_t _Myindex; 
};

template <class _Ptr>
[[nodiscard]] constexpr checked_array_iterator<_Ptr> make_checked_array_iterator(
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0) {
    return checked_array_iterator<_Ptr>(_Array, _Size, _Index);
}

template <class _Ptr>
class unchecked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "unchecked_array_iterator requires pointers");

public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;

    constexpr unchecked_array_iterator() noexcept : _Myptr(nullptr) {}

    constexpr explicit unchecked_array_iterator(const _Ptr _Src) noexcept : _Myptr(_Src) {}

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myptr;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *_Myptr;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return _Myptr;
    }

    constexpr unchecked_array_iterator& operator++() noexcept {
        ++_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator++(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        ++_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator--() noexcept {
        --_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator--(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        --_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator+=(const difference_type _Off) noexcept {
        _Myptr += _Off;
        return *this;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator+(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }


    [[nodiscard]]
#line 1627 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
    friend constexpr unchecked_array_iterator operator+(
        const difference_type _Off, const unchecked_array_iterator& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr unchecked_array_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator-(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr - _Right._Myptr;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr == _Right._Myptr;
    }





#line 1659 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
    [[nodiscard]] constexpr bool operator!=(const unchecked_array_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] constexpr bool operator<(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr < _Right._Myptr;
    }

    [[nodiscard]] constexpr bool operator>(const unchecked_array_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] constexpr bool operator<=(const unchecked_array_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] constexpr bool operator>=(const unchecked_array_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 1679 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"


    friend constexpr void _Verify_range(
        const unchecked_array_iterator _First, const unchecked_array_iterator _Last) noexcept {
        ::std:: _Verify_range(_First._Myptr, _Last._Myptr);
    }
#line 1686 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"

    using _Prevent_inheriting_unwrap = unchecked_array_iterator;

    static constexpr bool _Unwrap_when_unverified = true;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myptr;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myptr = _It;
    }

private:
    _Ptr _Myptr; 
};

template <class _Ptr>
[[nodiscard]] unchecked_array_iterator<_Ptr> make_unchecked_array_iterator(const _Ptr _It) noexcept {
    return unchecked_array_iterator<_Ptr>(_It);
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 1714 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
#line 1715 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\iterator"
#pragma external_header(pop)
#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"





#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"







#pragma once









#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )








#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

namespace std {
template <class _Elem, class _Int_type>
struct _Char_traits { 
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;


#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    

    static inline _Elem* copy(  _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"









#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return _First1;
    }

      static inline _Elem* _Copy_s( 
                                                                                 _Elem* const _First1,
        const size_t _Dest_size,   const _Elem* const _First2, const size_t _Count) noexcept {
        
        do { if (_Count <= _Dest_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 74, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 74, 0); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }

    static inline _Elem* move(  _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"































#line 116 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        :: memmove(_First1, _First2, _Count * sizeof(_Elem));
#line 119 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return _First1;
    }

    
    

    [[nodiscard]] static inline int compare(  const _Elem* _First1,
          const _Elem* _First2, size_t _Count) noexcept  {
        
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }

        return 0;
    }

    [[nodiscard]] static inline size_t length(  const _Elem* _First) noexcept  {
        
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }

        return _Count;
    }

    [[nodiscard]] static inline const _Elem* find(
          const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept  {
        
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }

        return nullptr;
    }

    static inline _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        






#line 171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                *_Next = _Ch;
            }
        }

        return _First;
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept {




#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        {
            _Left = _Right;
        }
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return static_cast<int_type>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1));
    }
};

template <class _Elem>
struct _WChar_traits : private _Char_traits<_Elem, unsigned short> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, unsigned short>;

public:
    using char_type  = _Elem;
    using int_type   = unsigned short;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;


#line 235 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static inline int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        






#line 250 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return :: wmemcmp(
            reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
#line 253 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    [[nodiscard]] static inline size_t length(  const _Elem* _First) noexcept  {
        






#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return :: wcslen(reinterpret_cast<const wchar_t*>(_First));
#line 266 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    [[nodiscard]] static inline const _Elem* find(
          const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept  {
        






#line 278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return reinterpret_cast<const _Elem*>(:: wmemchr(reinterpret_cast<const wchar_t*>(_First), _Ch, _Count));
#line 280 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    static inline _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        




#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return reinterpret_cast<_Elem*>(:: wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept {
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return _Meta;
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return _Ch;
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return ((wint_t)(0xFFFF));
    }
};

template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> {}; 

template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> {};

using u16streampos = streampos;

template <>
struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {};

using u32streampos = streampos;

template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> {};


template <>
struct char_traits<unsigned short> : _WChar_traits<unsigned short> {};
#line 347 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"



#line 351 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

#line 353 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

template <class _Elem, class _Int_type>
struct _Narrow_char_traits : private _Char_traits<_Elem, _Int_type> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, _Int_type>;

public:
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;


#line 369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static inline int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 380 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return :: memcmp(_First1, _First2, _Count);
#line 382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    [[nodiscard]] static inline size_t length(  const _Elem* const _First) noexcept  {
        













#line 400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return :: strlen(reinterpret_cast<const char*>(_First));
#line 402 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    [[nodiscard]] static inline const _Elem* find(  const _Elem* const _First, const size_t _Count,
        const _Elem& _Ch) noexcept  {
        













#line 421 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return static_cast<const _Elem*>(:: memchr(_First, _Ch, _Count));
#line 423 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    static inline _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        




#line 433 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return static_cast<_Elem*>(:: memset(_First, _Ch, _Count));
    }

    static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept {
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept {
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {
        return static_cast<unsigned char>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1));
    }
};




template <>
struct char_traits<char> : _Narrow_char_traits<char, int> {}; 










template <class _Elem, class _Traits, class _SizeT>
basic_ostream<_Elem, _Traits>& _Insert_string(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
    
    using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

    _SizeT _Pad;
    if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
        _Pad = 0;
    } else {
        _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
    }

    const typename _Ostr_t::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        if (_State == _Ostr_t::goodbit
            && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
            _State |= _Ostr_t::badbit;
        } else {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(_Ostr_t::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
struct _Char_traits_eq {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const noexcept {
        return _Traits::eq(_Left, _Right);
    }
};

template <class _Traits>
struct _Char_traits_lt {
    using _Elem = typename _Traits::char_type;

    bool operator()(_Elem _Left, _Elem _Right) const noexcept {
        return _Traits::lt(_Left, _Right);
    }
};



template <class _Elem>
 constexpr bool _Pred_is_consistent_with_memcmp<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>> = true;

template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;

template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;

template <class _Traits>
constexpr bool _Traits_equal(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}

template <class _Traits>
constexpr int _Traits_compare(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    const int _Ans = _Traits::compare(_Left, _Right, (::std:: min) (_Left_size, _Right_size));

    if (_Ans != 0) {
        return _Ans;
    }

    if (_Left_size < _Right_size) {
        return -1;
    }

    if (_Left_size > _Right_size) {
        return 1;
    }

    return 0;
}

template <class _Traits>
constexpr size_t _Traits_find(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
        
        
        
        
        
        
        
        
        return static_cast<size_t>(-1);
    }

    if (_Needle_size == 0) { 
        return _Start_at;
    }

    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) { 
            return static_cast<size_t>(-1);
        }

        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { 
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}

template <class _Traits>
constexpr size_t _Traits_find_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size == 0) {
        return (::std:: min) (_Start_at, _Hay_size); 
    }

    if (_Needle_size <= _Hay_size) { 
        for (auto _Match_try = _Haystack + (::std:: min) (_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min) (_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Elem, bool = _Is_character<_Elem>::value>
class _String_bitmap { 
public:
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        
        
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { 
        return _Matches[static_cast<unsigned char>(_Ch)];
    }

private:
    bool _Matches[256] = {};
};

template <class _Elem>
class _String_bitmap<_Elem, false> { 
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");

    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        
        
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }

            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { 
        return _Ch < 256U && _Matches[_Ch];
    }

private:
    bool _Matches[256] = {};
};

template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Needle_size != 0 && _Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min) (_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Needle_size != 0 && _Hay_size != 0) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        for (auto _Match_try = _Haystack + (::std:: min) (_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Start_at < _Hay_size) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_first_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, false_type) noexcept {
    
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min) (_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size, true_type) noexcept {
    
    
    if (_Hay_size != 0) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                
            return _Traits_find_last_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }

        for (auto _Match_try = _Haystack + (::std:: min) (_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min) (_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1911 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

template <class _Mystr>
class _String_const_iterator : public _Iterator_base {
public:



    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::const_pointer;
    using reference         = const value_type&;

    inline _String_const_iterator() noexcept : _Ptr() {}

    inline _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pstring);
    }

    
    inline _String_const_iterator& operator=(const _String_const_iterator&) noexcept = default;

    [[nodiscard]] inline reference operator*() const noexcept {

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1935, 0, "%s", "cannot dereference value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1935, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1938, 0, "%s", "cannot dereference string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1938, 0); } while (false); } ; } while (false);
#line 1939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr  = _Unfancy(_Ptr);
        do { if (_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1942, 0, "%s", "cannot dereference string iterator because it is out of range (e.g. an end iterator)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because it is out of range (e.g. an end iterator)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1942, 0); } while (false); } ; } while (false);
#line 1943 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
#line 1944 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        ;
        return *_Ptr;
    }

    [[nodiscard]] inline pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    inline _String_const_iterator& operator++() noexcept {

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1955, 0, "%s", "cannot increment value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1955, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1958, 0, "%s", "cannot increment string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1958, 0); } while (false); } ; } while (false);
#line 1959 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        do { if (_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1959, 0, "%s", "cannot increment string iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator past end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1959, 0); } while (false); } ; } while (false);
#line 1961 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        ++_Ptr;
        return *this;
    }

    inline _String_const_iterator operator++(int) noexcept {
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    inline _String_const_iterator& operator--() noexcept {

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1974, 0, "%s", "cannot decrement value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1974, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1977, 0, "%s", "cannot decrement string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1977, 0); } while (false); } ; } while (false);
#line 1978 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        do { if (_Mycont->_Myptr() < _Unfancy(_Ptr)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1978, 0, "%s", "cannot decrement string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1978, 0); } while (false); } ; } while (false);
#line 1980 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        --_Ptr;
        return *this;
    }

    inline _String_const_iterator operator--(int) noexcept {
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    inline void _Verify_offset(const difference_type _Off) const noexcept {

        if (_Off == 0) {
            return;
        }

        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1997, 0, "%s", "cannot seek value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized string iterator\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 1997, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2000, 0, "%s", "cannot seek string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2000, 0); } while (false); } ; } while (false);
#line 2001 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr  = _Unfancy(_Ptr);

        if (_Off < 0) {
            do { if (_Contptr - _Rawptr <= _Off) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2005, 0, "%s", "cannot seek string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator before begin\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2005, 0); } while (false); } ; } while (false);
        }

        if (_Off > 0) {
            using _Size_type = typename _Mystr::size_type;
            const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
            do { if (static_cast<_Size_type>(_Off) <= _Left) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2011, 0, "%s", "cannot seek string iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator after end\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2011, 0); } while (false); } ; } while (false);
        }


#line 2016 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    inline _String_const_iterator& operator+=(const difference_type _Off) noexcept {

        _Verify_offset(_Off);
#line 2022 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] inline _String_const_iterator operator+(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _String_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _String_const_iterator operator-(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }






#line 2062 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    [[nodiscard]] bool operator!=(const _String_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

    [[nodiscard]] bool operator>(const _String_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _String_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _String_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 2083 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline void _Compat(const _String_const_iterator& _Right) const noexcept {
        

        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2088, 0, "%s", "string iterators incompatible (e.g." " point to different string instances)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible (e.g.\" \" point to different string instances)\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2088, 0); } while (false); } ; } while (false);
#line 2089 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"


#line 2092 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }


    friend inline void _Verify_range(
        const _String_const_iterator& _First, const _String_const_iterator& _Last) noexcept {
        do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2097, 0, "%s", "string iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators in range are from different containers\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2097, 0); } while (false); } ; } while (false);
        do { if (_First._Ptr <= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2098, 0, "%s", "string iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator range transposed\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2098, 0); } while (false); } ; } while (false);
    }
#line 2101 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    using _Prevent_inheriting_unwrap = _String_const_iterator;

    [[nodiscard]] inline const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    inline void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
    }

    pointer _Ptr; 
};

template <class _Mystr>
[[nodiscard]] inline _String_const_iterator<_Mystr> operator+(
    typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next) noexcept {
    _Next += _Off;
    return _Next;
}






























#line 2152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> {
public:
    using _Mybase = _String_const_iterator<_Mystr>;




    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    
    inline _String_iterator& operator=(const _String_iterator&) noexcept = default;

    [[nodiscard]] inline reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] inline pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    inline _String_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _String_iterator operator++(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _String_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _String_iterator operator--(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _String_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _String_iterator operator+(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    inline _String_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _String_iterator operator-(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

    [[nodiscard]] inline value_type* _Unwrapped() const noexcept {
        return const_cast<value_type*>(_Unfancy(this->_Ptr));
    }
};

template <class _Mystr>
[[nodiscard]] inline _String_iterator<_Mystr> operator+(
    typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next) noexcept {
    _Next += _Off;
    return _Next;
}






























#line 2274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _String_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

template <class _Val_types>
class _String_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    inline _String_val() noexcept : _Bx() {}

    
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    
    static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
                                           : sizeof(value_type) <= 2 ? 7
                                           : sizeof(value_type) <= 4 ? 3
                                           : sizeof(value_type) <= 8 ? 1
                                                                     : 0;

    inline value_type* _Myptr() noexcept {
        value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    inline const value_type* _Myptr() const noexcept {
        const value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    inline bool _Large_string_engaged() const noexcept {




#line 2331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return _BUF_SIZE <= _Myres;
    }

    inline void _Check_offset(const size_type _Off) const {
        
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    inline void _Check_offset_exclusive(const size_type _Off) const {
        
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string position");
    }

    inline size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        
        return (::std:: min) (_Size, _Mysize - _Off);
    }

    union _Bxty { 
        inline _Bxty() noexcept : _Ptr() {} 

        inline ~_Bxty() noexcept {} 

        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE]; 
    } _Bx;

    size_type _Mysize = 0; 
    size_type _Myres  = 0; 
};

template <class _Ty>
constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); 

struct _String_constructor_concat_tag {
    
    explicit _String_constructor_concat_tag() = default;
};

struct _String_constructor_rvalue_allocator_tag {
    
    explicit _String_constructor_rvalue_allocator_tag() = default;
};

[[noreturn]] inline void _Xlen_string() {
    _Xlength_error("string too long");
}

template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string { 
private:
    friend _Tidy_deallocate_guard<basic_string>;
    friend basic_stringbuf<_Elem, _Traits, _Alloc>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;

    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;

    static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>,
        "basic_string<T, Traits, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");

    static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
        "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
        "[strings.general]/1.");

public:
    using traits_type    = _Traits;
    using allocator_type = _Alloc;

    using value_type      = _Elem;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    using iterator       = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;

    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

private:
    static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
    static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;

    
    
    
    
    
    
    
    
    
    
    static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
    
    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;

    template <class _Iter>
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;







#line 2459 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

public:
    inline basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }

    inline basic_string(const basic_string& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }

    inline basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }

    inline explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }

    inline basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Right, _Roff, npos);
        _Proxy._Release();
    }

    inline basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Right, _Roff, _Count);
        _Proxy._Release();
    }

    inline basic_string(  const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }

    inline basic_string(
          const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }

    inline basic_string(  const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }



#line 2537 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"



#line 2541 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    inline basic_string(  const _Elem* const _Ptr, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }

    inline basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }



#line 2563 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    inline basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        _Adl_verify_range(_First, _Last);
        _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        _Proxy._Release();
    }

    template <class _Iter>
    inline void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
        
        _Tidy_deallocate_guard<basic_string> _Guard{this};
        for (; _First != _Last; ++_First) {
            push_back(*_First);
        }

        _Guard._Target = nullptr;
    }

    template <class _Iter>
    inline void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
        
        const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        reserve(_Count);
        _Construct(_First, _Last, input_iterator_tag{});
    }

    inline void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
        
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }

    inline void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
        
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }

    inline basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal())) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Take_contents(_Right);
    }

    inline basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
        _Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                _Construct_lv_contents(_Right);
                _Proxy._Release();
                return;
            }
        }

        _Take_contents(_Right);
        _Proxy._Release();
    }

    inline basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al,
        const _Elem* const _Left_ptr, const size_type _Left_size, const _Elem* const _Right_ptr,
        const size_type _Right_size)
        : _Mypair(
            _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
        ;
        ;
        ;
        const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
        size_type _New_capacity = _BUF_SIZE - 1;
        auto& _My_data          = _Mypair._Myval2;
        _Elem* _Ptr             = _My_data._Bx._Buf;
        auto&& _Alproxy         = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 



#line 2657 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const bool _Activate_large_mode = _New_capacity < _New_size;
#line 2659 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        if (_Activate_large_mode) {
            
            const size_type _Requested_size = (::std:: max) (_New_size, _BUF_SIZE);
            _New_capacity                   = _Calculate_growth(_Requested_size, _BUF_SIZE - 1, max_size());
            const pointer _Fancyptr         = _Getal().allocate(_New_capacity + 1); 
            _Ptr                            = _Unfancy(_Fancyptr);
            _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        }





#line 2674 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        _Traits::copy(_Ptr, _Left_ptr, _Left_size);
        _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
        _Traits::assign(_Ptr[_New_size], _Elem());
        _Proxy._Release();
    }

    inline basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {
        auto& _My_data    = _Mypair._Myval2;
        auto& _Left_data  = _Left._Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Left_data._Orphan_all();
        _Right_data._Orphan_all();
        const auto _Left_size  = _Left_data._Mysize;
        const auto _Right_size = _Right_data._Mysize;

        const auto _Left_capacity  = _Left_data._Myres;
        const auto _Right_capacity = _Right_data._Myres;
        
        const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
            
            _My_data._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal())); 
            _Take_contents(_Left);
            const auto _Ptr = _My_data._Myptr();
            _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
            _My_data._Mysize = _New_size;
            return;
        }

        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
            
            
            
            
            
            
            
            
            
            ;
            _My_data._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal())); 
            _Take_contents(_Right);
            const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
            _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
            _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
            _My_data._Mysize = _New_size;
            return;
        }

        
        const auto _Max = max_size();
        if (_Max - _Left_size < _Right_size) { 
            _Xlen_string();
        }

        const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
        auto&& _Alproxy          = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 
        const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); 
        




#line 2745 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        const auto _Ptr  = _Unfancy(_Fancyptr);
        _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
        _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
        _Proxy._Release();
    }






















#line 2776 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"








#line 2785 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

private:
    inline void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
        _Tidy_deallocate();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }

    inline void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            
            _Mypair._Myval2._Orphan_all();
            _Mypair._Myval2._Reload_proxy(
                static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
            _Pocma(_Getal(), _Right._Getal());
            _Take_contents(_Right);
        }
    }

    inline void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

public:











































#line 2859 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& operator=(basic_string&& _Right) noexcept(
        noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }

        return *this;
    }

    inline basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = ::std:: move(_Right))) {
        *this = ::std:: move(_Right);
        return *this;
    }

private:
    void _Memcpy_val_from(const basic_string& _Right) noexcept {
        ; 
        const auto _My_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
        const auto _Right_data_mem =
            reinterpret_cast<const unsigned char*>(::std:: addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    }

    inline void _Take_contents(basic_string& _Right) noexcept {
        
        
        
        
        
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        if constexpr (_Can_memcpy_val) {


#line 2897 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
            {

                if (_Right_data._Large_string_engaged()) {
                    
                    _Swap_proxy_and_iterators(_Right);
                } else {
                    _Right_data._Orphan_all();
                }
#line 2906 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

                _Memcpy_val_from(_Right);
                _Right._Tidy_init();
                return;
            }
        }

        if (_Right_data._Large_string_engaged()) { 
            _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            _Right_data._Bx._Ptr = nullptr;
            _Swap_proxy_and_iterators(_Right);
        } else { 
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Right_data._Orphan_all();
        }

        _My_data._Mysize = _Right_data._Mysize;
        _My_data._Myres  = _Right_data._Myres;
        _Right._Tidy_init();
    }

    inline void _Construct_lv_contents(const basic_string& _Right) {
        
        
        
        
        auto& _Right_data             = _Right._Mypair._Myval2;
        const size_type _Right_size   = _Right_data._Mysize;
        const _Elem* const _Right_ptr = _Right_data._Myptr();
        auto& _My_data                = _Mypair._Myval2;



#line 2940 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const bool _Stay_small = _Right_size < _BUF_SIZE;
#line 2942 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        
        
        if (_Stay_small) { 
            _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
            _My_data._Mysize = _Right_size;
            _My_data._Myres  = _BUF_SIZE - 1;
            return;
        }

        auto& _Al                     = _Getal();
        const size_type _New_capacity = (::std:: min) (_Right_size | _ALLOC_MASK, max_size());
        const pointer _New_array      = _Al.allocate(_New_capacity + 1); 
        _Construct_in_place(_My_data._Bx._Ptr, _New_array);





#line 2962 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
        _My_data._Mysize = _Right_size;
        _My_data._Myres  = _New_capacity;
    }

public:
    inline basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        _Proxy._Release();
    }

    inline basic_string& operator=(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline basic_string& operator+=(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline basic_string& assign(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline basic_string& append(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2995, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 2995, 0); } while (false); } ; } while (false);
#line 2997 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + static_cast<difference_type>(_Off);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
        
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3007, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3007, 0); } while (false); } ; } while (false);
#line 3009 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    inline ~basic_string() noexcept {
        _Tidy_deallocate();

        auto&& _Alproxy          = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        const auto _To_delete    = _Mypair._Myval2._Myproxy;
        _Mypair._Myval2._Myproxy = nullptr;
        _Delete_plain_internal(_Alproxy, _To_delete);
#line 3022 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    }

    static constexpr auto npos{static_cast<size_type>(-1)};

private:
    void _Copy_assign_val_from_small(const basic_string& _Right) {
        


#line 3032 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        _Tidy_deallocate();
        if constexpr (_Can_memcpy_val) {
            _Memcpy_val_from(_Right);
        } else {
            auto& _My_data    = _Mypair._Myval2;
            auto& _Right_data = _Right._Mypair._Myval2;

            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _My_data._Mysize = _Right_data._Mysize;
            _My_data._Myres  = _Right_data._Myres;
        }
    }

    inline void _Copy_assign(const basic_string& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline void _Copy_assign(const basic_string& _Right, true_type) {
        auto& _Al             = _Getal();
        const auto& _Right_al = _Right._Getal();
        if (_Al == _Right_al) {
            _Copy_assign(_Right, false_type{});
            return;
        }

        auto&& _Alproxy       = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        auto&& _Right_alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right_al);
        _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); 

        if (_Right._Mypair._Myval2._Large_string_engaged()) {
            const auto _New_size     = _Right._Mypair._Myval2._Mysize;
            const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
            auto _Right_al_non_const = _Right_al;
            const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity); 





#line 3073 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
            _Tidy_deallocate();
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
            _Mypair._Myval2._Mysize  = _New_size;
            _Mypair._Myval2._Myres   = _New_capacity;
        } else {
            _Copy_assign_val_from_small(_Right);
        }

        _Pocca(_Al, _Right_al);
        _New_proxy._Bind(_Alproxy, ::std:: addressof(_Mypair._Myval2));
    }

public:
    inline basic_string& operator=(const basic_string& _Right) {
        if (this != ::std:: addressof(_Right)) {
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }

        return *this;
    }






#line 3102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& operator=(  const _Elem* const _Ptr) {
        return assign(_Ptr);
    }



#line 3110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& operator=(const _Elem _Ch) { 
        _Mypair._Myval2._Mysize = 1;
        _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }

    inline basic_string& operator+=(const basic_string& _Right) {
        return append(_Right);
    }






#line 3129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& operator+=(  const _Elem* const _Ptr) { 
        return append(_Ptr);
    }

    inline basic_string& operator+=(_Elem _Ch) {
        push_back(_Ch);
        return *this;
    }

    inline basic_string& append(const basic_string& _Right) {
        return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }















#line 3165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& append(
          const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }

    inline basic_string& append(  const _Elem* const _Ptr) { 
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& append(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& append(const _Iter _First, const _Iter _Last) {
        
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

    inline basic_string& assign(const basic_string& _Right) {
        *this = _Right;
        return *this;
    }

    inline basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }















#line 3256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& assign(
          const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }

    inline basic_string& assign(  const _Elem* const _Ptr) {
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& assign(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& assign(const _Iter _First, const _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            basic_string _Right(_UFirst, _ULast, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            } else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }

    inline basic_string& insert(const size_type _Off, const basic_string& _Right) {
        
        return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline basic_string& insert(
        const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
















#line 3348 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& insert(
        const size_type _Off,   const _Elem* const _Ptr, __declspec(guard(overflow)) const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;

        
        


#line 3360 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
#line 3362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        if (_Check_overlap) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            
            
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                
                _Ptr_shifted_after = _Count; 
            } else if (_Insert_at <= _Ptr) { 
                _Ptr_shifted_after = 0;
            } else { 
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }

            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }

    inline basic_string& insert(const size_type _Off,   const _Elem* const _Ptr) {
        
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& insert(
        const size_type _Off, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::assign(_Insert_at, _Count, _Ch); 
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }

    inline iterator insert(const const_iterator _Where, const _Elem _Ch) { 

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3429, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3429, 0); } while (false); } ; } while (false);
#line 3431 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, 1, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    inline iterator insert(
        const const_iterator _Where, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch) {
        

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3440, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3440, 0); } while (false); } ; } while (false);
#line 3442 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Count, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
        

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3451, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3451, 0); } while (false); } ; } while (false);
#line 3453 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }

    inline basic_string& erase(const size_type _Off = 0) { 
        _Mypair._Myval2._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }

private:
    inline basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {
        _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
        _Elem* const _Erase_at    = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Mypair._Myval2._Mysize   = _New_size;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); 
        return *this;
    }

public:
    inline basic_string& erase(const size_type _Off, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Erase_noexcept(_Off, _Count);
    }

    inline iterator erase(const const_iterator _Where) noexcept  {

        do { if (_Where._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3494, 0, "%s", "string iterator incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3494, 0); } while (false); } ; } while (false);
#line 3496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, 1);
        return begin() + static_cast<difference_type>(_Off);
    }

    inline iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
     {
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3505, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3505, 0); } while (false); } ; } while (false);
#line 3507 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
        return begin() + static_cast<difference_type>(_Off);
    }

    inline void clear() noexcept { 
        _Eos(0);
    }

    inline basic_string& replace(const size_type _Off, const size_type _Nx, const basic_string& _Right) {
        
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline basic_string& replace(const size_type _Off, size_type _Nx, const basic_string& _Right,
        const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }
















#line 3545 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& replace(
        const size_type _Off, size_type _Nx,   const _Elem* const _Ptr, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Nx == _Count) { 
            _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }

        const size_type _Old_size    = _Mypair._Myval2._Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if (_Count < _Nx) { 
            _Mypair._Myval2._Mysize = _Old_size - (_Nx - _Count);
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);
            return *this;
        }

        const size_type _Growth = static_cast<size_type>(_Count - _Nx);

        
        


#line 3574 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        {
            if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { 
                _Mypair._Myval2._Mysize = _Old_size + _Growth;
                _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Elem* const _Suffix_at = _Insert_at + _Nx;

                size_type _Ptr_shifted_after; 
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                } else if (_Suffix_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
                }

                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
                
                
                
                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
                
                
                _Traits::copy(
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }
        }

        return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Ptr, _Count);
    }

    inline basic_string& replace(const size_type _Off, const size_type _Nx,   const _Elem* const _Ptr) {
        
        return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    inline basic_string& replace(const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Count == _Nx) {
            _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
            return *this;
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count < _Nx || _Count - _Nx <= _Mypair._Myval2._Myres - _Old_size) {
            
            _Mypair._Myval2._Mysize = _Old_size + _Count - _Nx; 
                                                                
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count - _Nx,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Count, _Ch);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
        
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3656, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3656, 0); } while (false); } ; } while (false);
#line 3658 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }













#line 3675 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline basic_string& replace(const const_iterator _First, const const_iterator _Last,
          const _Elem* const _Ptr, const size_type _Count) {
        
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3681, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3681, 0); } while (false); } ; } while (false);
#line 3683 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last,   const _Elem* const _Ptr) {
        
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3692, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3692, 0); } while (false); } ; } while (false);
#line 3694 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    }

    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
        
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3703, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3703, 0); } while (false); } ; } while (false);
#line 3705 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
        
        _Adl_verify_range(_First, _Last);

        do { if (_First._Getcont() == ::std:: addressof(_Mypair._Myval2)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3715, 0, "%s", "string iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3715, 0); } while (false); } ; } while (false);
#line 3717 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2  = _Get_unwrapped(_Last2);
        if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
            return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
        } else {
            const basic_string _Right(_UFirst2, _ULast2, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

    [[nodiscard]] inline iterator begin() noexcept {
        return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline iterator end() noexcept {
        return iterator(
            _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        return const_iterator(
            _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline _Elem* _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] inline const _Elem* _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] inline _Elem* _Unchecked_end() noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline const _Elem* _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    inline void shrink_to_fit() { 
        auto& _My_data = _Mypair._Myval2;



#line 3804 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        {
            if (!_My_data._Large_string_engaged()) { 
                return;
            }

            if (_My_data._Mysize < _BUF_SIZE) {
                _Become_small();
                return;
            }
        }

        size_type _Target_capacity = (::std:: min) (_My_data._Mysize | _ALLOC_MASK, max_size());



#line 3820 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        if (_Target_capacity < _My_data._Myres) { 
            auto& _Al              = _Getal();
            const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); 





#line 3830 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

            _My_data._Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres   = _Target_capacity;
        }
    }

    [[nodiscard]] inline reference at(const size_type _Off) {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] inline const_reference at(const size_type _Off) const {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] inline reference operator[](const size_type _Off) noexcept  {

        do { if (_Off <= _Mypair._Myval2._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3851, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3851, 0); } while (false); } ; } while (false);
#line 3853 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] inline const_reference operator[](const size_type _Off) const noexcept
     {

        do { if (_Off <= _Mypair._Myval2._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3859, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3859, 0); } while (false); } ; } while (false);
#line 3861 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }






#line 3870 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    inline void push_back(const _Elem _Ch) { 
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Old_size < _Mypair._Myval2._Myres) {
            _Mypair._Myval2._Mysize = _Old_size + 1;
            _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }

        _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }

    inline void pop_back() noexcept  {
        const size_type _Old_size = _Mypair._Myval2._Mysize;

        do { if (_Old_size != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3894, 0, "%s", "invalid to pop_back empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid to pop_back empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3894, 0); } while (false); } ; } while (false);
#line 3896 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        _Eos(_Old_size - 1);
    }

    [[nodiscard]] inline reference front() noexcept  {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3901, 0, "%s", "front() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3901, 0); } while (false); } ; } while (false);
#line 3903 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] inline const_reference front() const noexcept  {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3909, 0, "%s", "front() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3909, 0); } while (false); } ; } while (false);
#line 3911 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] inline reference back() noexcept  {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3917, 0, "%s", "back() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3917, 0); } while (false); } ; } while (false);
#line 3919 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] inline const_reference back() const noexcept  {

        do { if (_Mypair._Myval2._Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3925, 0, "%s", "back() called on empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty string\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 3925, 0); } while (false); } ; } while (false);
#line 3927 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] inline   const _Elem* c_str() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] inline   const _Elem* data() const noexcept {
        return _Mypair._Myval2._Myptr();
    }





#line 3944 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline size_type length() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline size_type size() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = 
            (::std:: max) (_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return (::std:: min) (static_cast<size_type>((numeric_limits<difference_type>::max) ()),
            _Storage_max - 1 
        );
    }

    inline void resize(__declspec(guard(overflow)) const size_type _Newsize, const _Elem _Ch = _Elem()) {
        
        const size_type _Old_size = size();
        if (_Newsize <= _Old_size) {
            _Eos(_Newsize);
        } else {
            append(_Newsize - _Old_size, _Ch);
        }
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        return _Mypair._Myval2._Myres;
    }






















#line 3998 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    void reserve(__declspec(guard(overflow)) const size_type _Newcap = 0) { 
        if (_Mypair._Myval2._Mysize > _Newcap) { 
            return; 
        }

        if (_Mypair._Myval2._Myres == _Newcap) { 
            return; 
        }

        if (_Mypair._Myval2._Myres < _Newcap) { 
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            _Reallocate_grow_by(
                _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                });

            _Mypair._Myval2._Mysize = _Old_size;
            return;
        }

        if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {
            
            _Become_small();
            return;
        }

        
    }
#line 4027 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline bool empty() const noexcept {
        return _Mypair._Myval2._Mysize == 0;
    }

    inline size_type copy(
          _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    inline   size_type
        _Copy_s(  _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) {
        
        

        const pointer _Ptr = _Starts_large._Bx._Ptr;
        _Destroy_in_place(_Starts_large._Bx._Ptr);
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
        _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    }

    inline void _Swap_data(basic_string& _Right) {
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        if constexpr (_Can_memcpy_val) {


#line 4069 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
            {
                const auto _My_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_My_data)) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_Right_data)) + _Memcpy_val_offset;
                unsigned char _Temp_mem[_Memcpy_val_size];
                :: memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
                :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
                :: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);
                return;
            }
        }

        const bool _My_large    = _My_data._Large_string_engaged();
        const bool _Right_large = _Right_data._Large_string_engaged();
        if (_My_large) {
            if (_Right_large) { 
                _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            } else { 
                _Swap_bx_large_with_small(_My_data, _Right_data);
            }
        } else {
            if (_Right_large) { 
                _Swap_bx_large_with_small(_Right_data, _My_data);
            } else {
                _Elem _Temp_buf[_BUF_SIZE];
                _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _BUF_SIZE);
            }
        }

        ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        ::std:: swap(_My_data._Myres, _Right_data._Myres);
    }

    inline void swap(basic_string& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());


            const bool _My_large    = _Mypair._Myval2._Large_string_engaged();
            const bool _Right_large = _Right._Mypair._Myval2._Large_string_engaged();
            if (!_My_large) {
                _Mypair._Myval2._Orphan_all();
            }

            if (!_Right_large) {
                _Right._Mypair._Myval2._Orphan_all();
            }

            if (_My_large || _Right_large) {
                _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
            }
#line 4124 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        }

        _Swap_data(_Right);
    }









#line 4138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] inline size_type find(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] inline size_type find(  const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] inline size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }









#line 4175 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] inline size_type rfind(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] inline size_type rfind(  const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
     {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] inline size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }









#line 4212 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline size_type find_first_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_of(
          const _Elem* const _Ptr, const size_type _Off = 0) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }









#line 4251 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }










#line 4290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline size_type find_first_not_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_not_of(  const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_not_of(
          const _Elem* const _Ptr, size_type _Off = 0) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }











#line 4331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline size_type find_last_not_of(
        const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize,
            _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_not_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }

    [[nodiscard]] inline size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
     {
        
        return static_cast<size_type>(
            _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }






#line 4367 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const {
        
        return basic_string(*this, _Off, _Count, get_allocator());
    }

    inline bool _Equal(const basic_string& _Right) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    inline bool _Equal(  const _Elem* const _Ptr) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }





























#line 4413 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline int compare(const basic_string& _Right) const noexcept {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] inline int compare(size_type _Off, size_type _Nx, const basic_string& _Right) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] inline int compare(const size_type _Off, const size_type _Nx, const basic_string& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Right._Mypair._Myval2._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }

    [[nodiscard]] inline int compare(  const _Elem* const _Ptr) const noexcept  {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] inline int compare(
        const size_type _Off, const size_type _Nx,   const _Elem* const _Ptr) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] inline int compare(const size_type _Off, const size_type _Nx,
          const _Elem* const _Ptr, const size_type _Count) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx), _Ptr, _Count);
    }

























#line 4482 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"













#line 4496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    [[nodiscard]] static inline size_type _Calculate_growth(
        const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {
        const size_type _Masked = _Requested | _ALLOC_MASK;
        if (_Masked > _Max) { 
            return _Max;
        }

        if (_Old > _Max - _Old / 2) { 
            return _Max;
        }

        return (::std:: max) (_Masked, _Old + _Old / 2);
    }

    [[nodiscard]] inline size_type _Calculate_growth(const size_type _Requested) const noexcept {
        return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    }

    template <class _Fty, class... _ArgTys>
    inline basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
        
        
        if (_New_size > max_size()) {
            _Xlen_string(); 
        }

        const size_type _Old_capacity = _Mypair._Myval2._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 





#line 4538 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        _Mypair._Myval2._Orphan_all();
        _Mypair._Myval2._Mysize = _New_size;
        _Mypair._Myval2._Myres  = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_BUF_SIZE <= _Old_capacity) {
            _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
        } else {
            _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
        }

        return *this;
    }

    template <class _Fty, class... _ArgTys>
    inline basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
        
        
        auto& _My_data            = _Mypair._Myval2;
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen_string(); 
        }

        const size_type _New_size     = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 





#line 4573 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        _My_data._Orphan_all();
        _My_data._Mysize      = _New_size;
        _My_data._Myres       = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_BUF_SIZE <= _Old_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Al.deallocate(_Old_ptr, _Old_capacity + 1);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        }

        return *this;
    }

    void _Become_small() {
        
        
        
        

        _Mypair._Myval2._Orphan_all();
        const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
        auto& _Al          = _Getal();
        _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
        _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);
        _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
        _Mypair._Myval2._Myres = _BUF_SIZE - 1;
    }

    inline void _Eos(const size_type _Newsize) { 
        _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());
    }

    inline void _Tidy_init() noexcept { 
        auto& _My_data   = _Mypair._Myval2;
        _My_data._Mysize = 0;











#line 4624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        {
            _My_data._Myres = _BUF_SIZE - 1;
            
            _Traits::assign(_My_data._Bx._Buf[0], _Elem());
        }
    }

    inline void _Tidy_deallocate() noexcept { 
        _Mypair._Myval2._Orphan_all();
        if (_Mypair._Myval2._Large_string_engaged()) {
            const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
            auto& _Al          = _Getal();
            _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
            _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
        }







#line 4647 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
        {
            _Mypair._Myval2._Mysize = 0;
            _Mypair._Myval2._Myres  = _BUF_SIZE - 1;
            
            _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());
        }
    }

public:
    inline void _Orphan_all() noexcept { 
        _Mypair._Myval2._Orphan_all();
    }

private:
    inline void _Swap_proxy_and_iterators(basic_string& _Right) {
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    inline _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    inline const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};
















#line 4692 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

template <class _Elem, class _Traits, class _Alloc>
inline void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Right.size();
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Convert_size<_Size_type>(_Traits::length(_Left));
    const auto _Right_size = _Right.size();
    if (_Right.max_size() - _Right_size < _Left_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Right_size = _Right.size();
    if (_Right_size == _Right.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, ::std:: addressof(_Left), 1, _Right.c_str(), _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem _Right) {
    const auto _Left_size = _Left.size();
    if (_Left_size == _Left.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, ::std:: addressof(_Right), 1};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return ::std:: move(_Left.append(_Right));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

    do { if (::std:: addressof(_Left) != ::std:: addressof(_Right)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 4779, 0, "%s", "You cannot concatenate the same moved string to itself. See " "N4849 [res.on.arguments]/1.3: If a function argument binds to an rvalue reference " "parameter, the implementation may assume that this parameter is a unique reference " "to this argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"You cannot concatenate the same moved string to itself. See \" \"N4849 [res.on.arguments]/1.3: If a function argument binds to an rvalue reference \" \"parameter, the implementation may assume that this parameter is a unique reference \" \"to this argument\"", L"", L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring", 4779, 0); } while (false); } ; } while (false);
#line 4780 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
#line 4781 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
    return {_String_constructor_concat_tag{}, _Left, _Right};
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, 1, _Left));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left,   const _Elem* const _Right) {
    return ::std:: move(_Left.append(_Right));
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {
    _Left.push_back(_Right);
    return ::std:: move(_Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left._Equal(_Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return _Left._Equal(_Right);
}













#line 4834 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator==(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return _Right._Equal(_Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return _Right.compare(_Left) > 0;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(  const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return !(_Left < _Right);
}
#line 4919 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

using string  = basic_string<char, char_traits<char>, allocator<char>>;
using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;



using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

template <class _Elem, class _Traits, class _Alloc>
struct hash<basic_string<_Elem, _Traits, _Alloc>> {
     typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const basic_string<_Elem, _Traits, _Alloc>& _Keyval) const noexcept {
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};

template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    using _Myis   = basic_istream<_Elem, _Traits>;
    using _Ctype  = typename _Myis::_Ctype;
    using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;

    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();

        try {
        _Mysizt _Size;
        if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
            _Size = static_cast<_Mysizt>(_Istr.width());
        } else {
            _Size = _Str.max_size();
        }

        typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

        for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= _Myis::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                break; 
            } else { 
                _Str.push_back(_Traits::to_char_type(_Meta));
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }

    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }

    _Istr.setstate(_State);
    return static_cast<basic_istream<_Elem, _Traits>&>(_Istr);
}

template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    return ::std:: move(_Istr) >> _Str;
}

template <class _Elem, class _Traits, class _Alloc>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

inline namespace literals {
    inline namespace string_literals {





#line 5007 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"

        [[nodiscard]] inline string operator"" s(const char* _Str, size_t _Len) {
            return string(_Str, _Len);
        }

        [[nodiscard]] inline wstring operator"" s(const wchar_t* _Str, size_t _Len) {
            return wstring(_Str, _Len);
        }







        [[nodiscard]] inline u16string operator"" s(const char16_t* _Str, size_t _Len) {
            return u16string(_Str, _Len);
        }

        [[nodiscard]] inline u32string operator"" s(const char32_t* _Str, size_t _Len) {
            return u32string(_Str, _Len);
        }



    } 
} 













#line 5048 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"














#line 5063 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
}



#pragma warning(pop)
#pragma pack(pop)
#line 5070 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
#line 5071 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xstring"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )



namespace std {
class logic_error : public exception { 
public:
    using _Mybase = exception;

    explicit logic_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit logic_error(const char* _Message) : _Mybase(_Message) {}






#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class domain_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit domain_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit domain_error(const char* _Message) : _Mybase(_Message) {}






#line 51 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class invalid_argument : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit invalid_argument(const char* _Message) : _Mybase(_Message) {}






#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class length_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit length_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit length_error(const char* _Message) : _Mybase(_Message) {}






#line 83 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class out_of_range : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit out_of_range(const char* _Message) : _Mybase(_Message) {}






#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class runtime_error : public exception { 
public:
    using _Mybase = exception;

    explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit runtime_error(const char* _Message) : _Mybase(_Message) {}






#line 115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class overflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit overflow_error(const char* _Message) : _Mybase(_Message) {}






#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class underflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit underflow_error(const char* _Message) : _Mybase(_Message) {}






#line 147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

class range_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit range_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit range_error(const char* _Message) : _Mybase(_Message) {}






#line 163 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
};

[[noreturn]] inline void _Throw_range_error(const char* const _Message) {
    throw range_error{_Message};
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
#line 175 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\stdexcept"
#pragma external_header(pop)
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplwin.h"















#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ratio"





#pragma once







#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
template <intmax_t _Val>
struct _Abs : integral_constant<intmax_t, (_Val < 0 ? -_Val : _Val)> {}; 

template <intmax_t _Ax, intmax_t _Bx, bool _Sfinae = false,
    bool _Good = (_Abs<_Ax>::value <= 9223372036854775807i64 / (_Bx == 0 ? 1 : _Abs<_Bx>::value))>
struct _Safe_mult : integral_constant<intmax_t, _Ax * _Bx> {}; 

template <intmax_t _Ax, intmax_t _Bx, bool _Sfinae>
struct _Safe_mult<_Ax, _Bx, _Sfinae, false> { 
    static_assert(_Sfinae, "integer arithmetic overflow");
};

template <intmax_t _Val>
struct _Sign_of : integral_constant<intmax_t, (_Val < 0 ? -1 : 1)> {}; 

template <intmax_t _Ax, intmax_t _Bx, bool _Good, bool _Also_good>
struct _Safe_addX : integral_constant<intmax_t, _Ax + _Bx> {}; 

template <intmax_t _Ax, intmax_t _Bx>
struct _Safe_addX<_Ax, _Bx, false, false> { 
    static_assert(_Always_false<_Safe_addX>, "integer arithmetic overflow");
};

template <intmax_t _Ax, intmax_t _Bx>
struct _Safe_add : _Safe_addX<_Ax, _Bx, _Sign_of<_Ax>::value != _Sign_of<_Bx>::value,
                       (_Abs<_Ax>::value <= 9223372036854775807i64 - _Abs<_Bx>::value)>::type {
    
};

template <intmax_t _Ax, intmax_t _Bx>
struct _GcdX : _GcdX<_Bx, _Ax % _Bx>::type {}; 

template <intmax_t _Ax>
struct _GcdX<_Ax, 0> : integral_constant<intmax_t, _Ax> {}; 

template <intmax_t _Ax, intmax_t _Bx>
struct _Gcd : _GcdX<_Abs<_Ax>::value, _Abs<_Bx>::value>::type {}; 

template <>
struct _Gcd<0, 0> : integral_constant<intmax_t, 1> {
    
};

template <intmax_t _Nx, intmax_t _Dx = 1>
struct ratio { 
    static_assert(_Dx != 0, "zero denominator");
    static_assert(-9223372036854775807i64 <= _Nx, "numerator too negative");
    static_assert(-9223372036854775807i64 <= _Dx, "denominator too negative");

    static constexpr intmax_t num =
        _Sign_of<_Nx>::value * _Sign_of<_Dx>::value * _Abs<_Nx>::value / _Gcd<_Nx, _Dx>::value;

    static constexpr intmax_t den = _Abs<_Dx>::value / _Gcd<_Nx, _Dx>::value;

    using type = ratio<num, den>;
};

template <class _Ty>
 constexpr bool _Is_ratio_v = false; 

template <intmax_t _Rx1, intmax_t _Rx2>
 constexpr bool _Is_ratio_v<ratio<_Rx1, _Rx2>> = true;

template <class _Rx1, class _Rx2>
struct _Ratio_add { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx1 = _Rx1::num;
    static constexpr intmax_t _Dx1 = _Rx1::den;
    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    static constexpr intmax_t _Gx = _Gcd<_Dx1, _Dx2>::value;

    
    using type =
        typename ratio<_Safe_add<_Safe_mult<_Nx1, _Dx2 / _Gx>::value, _Safe_mult<_Nx2, _Dx1 / _Gx>::value>::value,
            _Safe_mult<_Dx1, _Dx2 / _Gx>::value>::type;
};

template <class _Rx1, class _Rx2>
using ratio_add = typename _Ratio_add<_Rx1, _Rx2>::type;

template <class _Rx1, class _Rx2>
struct _Ratio_subtract { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    using type = ratio_add<_Rx1, ratio<-_Nx2, _Dx2>>;
};

template <class _Rx1, class _Rx2>
using ratio_subtract = typename _Ratio_subtract<_Rx1, _Rx2>::type;

template <class _Rx1, class _Rx2>
struct _Ratio_multiply { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx1 = _Rx1::num;
    static constexpr intmax_t _Dx1 = _Rx1::den;
    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    static constexpr intmax_t _Gx = _Gcd<_Nx1, _Dx2>::value;
    static constexpr intmax_t _Gy = _Gcd<_Nx2, _Dx1>::value;

    using _Num = _Safe_mult<_Nx1 / _Gx, _Nx2 / _Gy, true>;
    using _Den = _Safe_mult<_Dx1 / _Gy, _Dx2 / _Gx, true>;
};

template <class _Rx1, class _Rx2, bool _Sfinae = true, class = void>
struct _Ratio_multiply_sfinae { 
    static_assert(_Sfinae, "integer arithmetic overflow");
};

template <class _Rx1, class _Rx2, bool _Sfinae>
struct _Ratio_multiply_sfinae<_Rx1, _Rx2, _Sfinae,
    void_t<typename _Ratio_multiply<_Rx1, _Rx2>::_Num::type,
        typename _Ratio_multiply<_Rx1, _Rx2>::_Den::type>> { 
    using type = ratio<_Ratio_multiply<_Rx1, _Rx2>::_Num::value, _Ratio_multiply<_Rx1, _Rx2>::_Den::value>;
};

template <class _Rx1, class _Rx2>
using ratio_multiply = typename _Ratio_multiply_sfinae<_Rx1, _Rx2, false>::type;

template <class _Rx1, class _Rx2>
struct _Ratio_divide { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

    static constexpr intmax_t _Nx2 = _Rx2::num;
    static constexpr intmax_t _Dx2 = _Rx2::den;

    using _Rx2_inverse = ratio<_Dx2, _Nx2>;
};

template <class _Rx1, class _Rx2, bool _Sfinae = true>
using _Ratio_divide_sfinae =
    typename _Ratio_multiply_sfinae<_Rx1, typename _Ratio_divide<_Rx1, _Rx2>::_Rx2_inverse, _Sfinae>::type;

template <class _Rx1, class _Rx2>
using ratio_divide = _Ratio_divide_sfinae<_Rx1, _Rx2, false>;

template <class _Rx1, class _Rx2>
struct ratio_equal : bool_constant<_Rx1::num == _Rx2::num && _Rx1::den == _Rx2::den> { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_equal_v = ratio_equal<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_not_equal : bool_constant<!ratio_equal_v<_Rx1, _Rx2>> { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_not_equal_v = ratio_not_equal<_Rx1, _Rx2>::value;

struct _Big_uint128 {
    uint64_t _Upper;
    uint64_t _Lower;

    constexpr bool operator<(const _Big_uint128 _Rhs) const noexcept {
        if (_Upper != _Rhs._Upper) {
            return _Upper < _Rhs._Upper;
        }

        return _Lower < _Rhs._Lower;
    }
};

constexpr _Big_uint128 _Big_multiply(const uint64_t _Lfactor,
    const uint64_t _Rfactor) noexcept { 
    const uint64_t _Llow  = _Lfactor & 0xFFFF'FFFFULL;
    const uint64_t _Lhigh = _Lfactor >> 32;
    const uint64_t _Rlow  = _Rfactor & 0xFFFF'FFFFULL;
    const uint64_t _Rhigh = _Rfactor >> 32;

    uint64_t _Temp          = _Llow * _Rlow;
    const uint64_t _Lower32 = _Temp & 0xFFFF'FFFFULL;
    uint64_t _Carry         = _Temp >> 32;

    _Temp                     = _Llow * _Rhigh + _Carry;
    const uint64_t _Mid_lower = _Temp & 0xFFFF'FFFFULL;
    const uint64_t _Mid_upper = _Temp >> 32;

    _Temp  = _Lhigh * _Rlow + _Mid_lower;
    _Carry = _Temp >> 32;

    return {_Lhigh * _Rhigh + _Mid_upper + _Carry, (_Temp << 32) + _Lower32};
}

constexpr bool _Ratio_less(const int64_t _Nx1, const int64_t _Dx1, const int64_t _Nx2, const int64_t _Dx2) noexcept {
    if (_Nx1 >= 0 && _Nx2 >= 0) {
        return _Big_multiply(static_cast<uint64_t>(_Nx1), static_cast<uint64_t>(_Dx2))
             < _Big_multiply(static_cast<uint64_t>(_Nx2), static_cast<uint64_t>(_Dx1));
    }

    if (_Nx1 < 0 && _Nx2 < 0) {
        return _Big_multiply(static_cast<uint64_t>(-_Nx2), static_cast<uint64_t>(_Dx1))
             < _Big_multiply(static_cast<uint64_t>(-_Nx1), static_cast<uint64_t>(_Dx2));
    }

    return _Nx1 < _Nx2;
}

template <class _Rx1, class _Rx2>
struct ratio_less : bool_constant<_Ratio_less(_Rx1::num, _Rx1::den, _Rx2::num, _Rx2::den)> { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_less_v = ratio_less<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_less_equal : bool_constant<!ratio_less_v<_Rx2, _Rx1>> { 
    static_assert(
        _Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_less_equal_v = ratio_less_equal<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_greater : ratio_less<_Rx2, _Rx1>::type { 
    static_assert(_Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_greater_v = ratio_greater<_Rx1, _Rx2>::value;

template <class _Rx1, class _Rx2>
struct ratio_greater_equal : bool_constant<!ratio_less_v<_Rx1, _Rx2>> { 
    static_assert(
        _Is_ratio_v<_Rx1> && _Is_ratio_v<_Rx2>, "ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
};

template <class _Rx1, class _Rx2>
 constexpr bool ratio_greater_equal_v = ratio_greater_equal<_Rx1, _Rx2>::value;

using atto  = ratio<1, 1000000000000000000LL>;
using femto = ratio<1, 1000000000000000LL>;
using pico  = ratio<1, 1000000000000LL>;
using nano  = ratio<1, 1000000000>;
using micro = ratio<1, 1000000>;
using milli = ratio<1, 1000>;
using centi = ratio<1, 100>;
using deci  = ratio<1, 10>;
using deca  = ratio<10, 1>;
using hecto = ratio<100, 1>;
using kilo  = ratio<1000, 1>;
using mega  = ratio<1000000, 1>;
using giga  = ratio<1000000000, 1>;
using tera  = ratio<1000000000000LL, 1>;
using peta  = ratio<1000000000000000LL, 1>;
using exa   = ratio<1000000000000000000LL, 1>;
}


#pragma warning(pop)
#pragma pack(pop)
#line 286 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ratio"
#line 287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ratio"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"




























#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
namespace chrono {
    template <class _Rep>
    struct treat_as_floating_point : is_floating_point<_Rep> {}; 

    template <class _Rep>
     constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;

    template <class _Rep>
    struct duration_values { 
        [[nodiscard]] static constexpr _Rep zero() noexcept {
            
            return _Rep(0);
        }

        [[nodiscard]] static constexpr _Rep(min)() noexcept {
            
            return numeric_limits<_Rep>::lowest();
        }

        [[nodiscard]] static constexpr _Rep(max)() noexcept {
            
            return (numeric_limits<_Rep>::max) ();
        }
    };















#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

    template <class _Rep, class _Period = ratio<1>>
    class duration;

    template <class _Ty>
     constexpr bool _Is_duration_v = _Is_specialization_v<_Ty, duration>;

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    constexpr _To duration_cast(const duration<_Rep, _Period>&) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>); 

    template <class _Rep, class _Period>
    class duration { 
    public:
        using rep    = _Rep;
        using period = typename _Period::type;

        static_assert(!_Is_duration_v<_Rep>, "duration can't have duration as first template argument");
        static_assert(_Is_ratio_v<_Period>, "period not an instance of std::ratio");
        static_assert(0 < _Period::num, "period negative or zero");

        constexpr duration() = default;

        template <class _Rep2,
            enable_if_t<is_convertible_v<const _Rep2&,
                            _Rep> && (treat_as_floating_point_v<_Rep> || !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr explicit duration(const _Rep2& _Val) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) 
            : _MyRep(static_cast<_Rep>(_Val)) {}

        template <class _Rep2, class _Period2,
            enable_if_t<
                treat_as_floating_point_v<
                    _Rep> || (_Ratio_divide_sfinae<_Period2, _Period>::den == 1 && !treat_as_floating_point_v<_Rep2>),
                int> = 0>
        constexpr duration(const duration<_Rep2, _Period2>& _Dur) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<_Rep2>) 
            : _MyRep(::std::chrono:: duration_cast<duration>(_Dur).count()) {}

        [[nodiscard]] constexpr _Rep count() const noexcept(is_arithmetic_v<_Rep>)  {
            return _MyRep;
        }

        [[nodiscard]] constexpr common_type_t<duration> operator+() const
            noexcept(is_arithmetic_v<_Rep>)  {
            return common_type_t<duration>(*this);
        }

        [[nodiscard]] constexpr common_type_t<duration> operator-() const
            noexcept(is_arithmetic_v<_Rep>)  {
            return common_type_t<duration>(-_MyRep);
        }

        inline duration& operator++() noexcept(is_arithmetic_v<_Rep>)  {
            ++_MyRep;
            return *this;
        }

        inline duration operator++(int) noexcept(is_arithmetic_v<_Rep>)  {
            return duration(_MyRep++);
        }

        inline duration& operator--() noexcept(is_arithmetic_v<_Rep>)  {
            --_MyRep;
            return *this;
        }

        inline duration operator--(int) noexcept(is_arithmetic_v<_Rep>)  {
            return duration(_MyRep--);
        }

        inline duration& operator+=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep += _Right._MyRep;
            return *this;
        }

        inline duration& operator-=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep -= _Right._MyRep;
            return *this;
        }

        inline duration& operator*=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep *= _Right;
            return *this;
        }

        inline duration& operator/=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep /= _Right;
            return *this;
        }

        inline duration& operator%=(const _Rep& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep %= _Right;
            return *this;
        }

        inline duration& operator%=(const duration& _Right) noexcept(is_arithmetic_v<_Rep>)  {
            _MyRep %= _Right.count();
            return *this;
        }

        [[nodiscard]] static constexpr duration zero() noexcept {
            
            return duration(duration_values<_Rep>::zero());
        }

        [[nodiscard]] static constexpr duration(min)() noexcept {
            
            return duration((duration_values<_Rep>::min) ());
        }

        [[nodiscard]] static constexpr duration(max)() noexcept {
            
            return duration((duration_values<_Rep>::max) ());
        }

    private:
        _Rep _MyRep; 
    };

    template <class _Clock, class _Duration = typename _Clock::duration>
    class time_point { 
    public:
        using clock    = _Clock;
        using duration = _Duration;
        using rep      = typename _Duration::rep;
        using period   = typename _Duration::period;

        static_assert(_Is_duration_v<_Duration>,
            "N4885 [time.point.general]/1 mandates Duration to be a specialization of chrono::duration.");

        constexpr time_point() = default;

        constexpr explicit time_point(const _Duration& _Other) noexcept(is_arithmetic_v<rep>) 
            : _MyDur(_Other) {}

        template <class _Duration2, enable_if_t<is_convertible_v<_Duration2, _Duration>, int> = 0>
        constexpr time_point(const time_point<_Clock, _Duration2>& _Tp) noexcept(
            is_arithmetic_v<rep>&& is_arithmetic_v<typename _Duration2::rep>) 
            : _MyDur(_Tp.time_since_epoch()) {}

        [[nodiscard]] constexpr _Duration time_since_epoch() const noexcept(is_arithmetic_v<rep>)  {
            return _MyDur;
        }
















#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

        inline time_point& operator+=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>)  {
            _MyDur += _Dur;
            return *this;
        }

        inline time_point& operator-=(const _Duration& _Dur) noexcept(is_arithmetic_v<rep>)  {
            _MyDur -= _Dur;
            return *this;
        }

        [[nodiscard]] static constexpr time_point(min)() noexcept {
            return time_point((_Duration::min) ());
        }

        [[nodiscard]] static constexpr time_point(max)() noexcept {
            return time_point((_Duration::max) ());
        }

    private:
        _Duration _MyDur{duration::zero()}; 
    };
} 

template <class _Rep, class _Period>
 constexpr bool _Is_trivially_swappable_v<chrono::duration<_Rep, _Period>> = _Is_trivially_swappable_v<_Rep>;

template <class _Clock, class _Duration>
 constexpr bool _Is_trivially_swappable_v<chrono::time_point<_Clock, _Duration>> =
    _Is_trivially_swappable_v<_Duration>;

template <intmax_t _Ax, intmax_t _Bx>
struct _Lcm : integral_constant<intmax_t, (_Ax / _Gcd<_Ax, _Bx>::value) * _Bx> {}; 

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<::std::chrono:: duration<_Rep1, _Period1>,
    ::std::chrono:: duration<_Rep2, _Period2>> { 
    using type = ::std::chrono:: duration<common_type_t<_Rep1, _Rep2>,
        ratio<_Gcd<_Period1::num, _Period2::num>::value, _Lcm<_Period1::den, _Period2::den>::value>>;
};

template <class _Clock, class _Duration1, class _Duration2>
struct common_type<::std::chrono:: time_point<_Clock, _Duration1>,
    ::std::chrono:: time_point<_Clock, _Duration2>> { 
    using type = ::std::chrono:: time_point<_Clock, common_type_t<_Duration1, _Duration2>>;
};

namespace chrono {
    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator+(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() + _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator-(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() - _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2,
        enable_if_t<is_convertible_v<const _Rep2&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    [[nodiscard]] constexpr duration<common_type_t<_Rep1, _Rep2>, _Period1> operator*(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() * _Right);
    }

    template <class _Rep1, class _Rep2, class _Period2,
        enable_if_t<is_convertible_v<const _Rep1&, common_type_t<_Rep1, _Rep2>>, int> = 0>
    [[nodiscard]] constexpr duration<common_type_t<_Rep1, _Rep2>, _Period2>
        operator*(const _Rep1& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return _Right * _Left;
    }

    template <class _CR, class _Period1, class _Rep2, bool = is_convertible_v<const _Rep2&, _CR>>
    struct _Duration_div_mod1 { 
        using type = duration<_CR, _Period1>;
    };

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod1<_CR, _Period1, _Rep2, false> {}; 

    template <class _CR, class _Period1, class _Rep2, bool = _Is_duration_v<_Rep2>>
    struct _Duration_div_mod {}; 

    template <class _CR, class _Period1, class _Rep2>
    struct _Duration_div_mod<_CR, _Period1, _Rep2, false> : _Duration_div_mod1<_CR, _Period1, _Rep2> {
        
    };

    template <class _Rep1, class _Period1, class _Rep2>
    [[nodiscard]] constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator/(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() / _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<_Rep1, _Rep2>
        operator/(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_Left).count() / _CD(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2>
    [[nodiscard]] constexpr typename _Duration_div_mod<common_type_t<_Rep1, _Rep2>, _Period1, _Rep2>::type operator%(
        const duration<_Rep1, _Period1>& _Left,
        const _Rep2& _Right) noexcept(is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CR = common_type_t<_Rep1, _Rep2>;
        using _CD = duration<_CR, _Period1>;
        return _CD(_CD(_Left).count() % _Right);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
        operator%(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CD(_CD(_Left).count() % _CD(_Right).count());
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator==(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() == _CT(_Right).count();
    }


    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator!=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return !(_Left == _Right);
    }
#line 402 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator<(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
        return _CT(_Left).count() < _CT(_Right).count();
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator<=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return !(_Right < _Left);
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator>(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return _Right < _Left;
    }

    template <class _Rep1, class _Period1, class _Rep2, class _Period2>
    [[nodiscard]] constexpr bool
        operator>=(const duration<_Rep1, _Period1>& _Left, const duration<_Rep2, _Period2>& _Right) noexcept(
            is_arithmetic_v<_Rep1>&& is_arithmetic_v<_Rep2>)  {
        return !(_Left < _Right);
    }














    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> _Enabled>
    [[nodiscard]] constexpr _To duration_cast(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        using _CF = ratio_divide<_Period, typename _To::period>;

        using _ToRep = typename _To::rep;
        using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;

        constexpr bool _Num_is_one = _CF::num == 1;
        constexpr bool _Den_is_one = _CF::den == 1;

        if (_Den_is_one) {
            if (_Num_is_one) {
                return static_cast<_To>(static_cast<_ToRep>(_Dur.count()));
            } else {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)));
            }
        } else {
            if (_Num_is_one) {
                return static_cast<_To>(
                    static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)));
            } else {
                return static_cast<_To>(static_cast<_ToRep>(
                    static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num) / static_cast<_CR>(_CF::den)));
            }
        }
    }

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr _To floor(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        
        const _To _Casted{::std::chrono:: duration_cast<_To>(_Dur)};
        if (_Casted > _Dur) {
            return _To{_Casted.count() - static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    template <class _To, class _Rep, class _Period, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr _To ceil(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        
        const _To _Casted{::std::chrono:: duration_cast<_To>(_Dur)};
        if (_Casted < _Dur) {
            return _To{_Casted.count() + static_cast<typename _To::rep>(1)};
        }

        return _Casted;
    }

    template <class _Rep>
    constexpr bool _Is_even(_Rep _Val) noexcept(is_arithmetic_v<_Rep>)  {
        
        return _Val % 2 == 0;
    }

    template <class _To, class _Rep, class _Period,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    [[nodiscard]] constexpr _To round(const duration<_Rep, _Period>& _Dur) noexcept(
        is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        const _To _Floored{::std::chrono:: floor<_To>(_Dur)};
        const _To _Ceiled{_Floored + _To{1}};
        const auto _Floor_adjustment = _Dur - _Floored;
        const auto _Ceil_adjustment  = _Ceiled - _Dur;
        if (_Floor_adjustment < _Ceil_adjustment
            || (_Floor_adjustment == _Ceil_adjustment && _Is_even(_Floored.count()))) {
            return _Floored;
        }

        return _Ceiled;
    }

    template <class _Rep, class _Period, enable_if_t<numeric_limits<_Rep>::is_signed, int> = 0>
    [[nodiscard]] constexpr duration<_Rep, _Period> abs(const duration<_Rep, _Period> _Dur) noexcept(
        is_arithmetic_v<_Rep>)  {
        
        return _Dur < duration<_Rep, _Period>::zero() ? duration<_Rep, _Period>::zero() - _Dur : _Dur;
    }

    using nanoseconds  = duration<long long, nano>;
    using microseconds = duration<long long, micro>;
    using milliseconds = duration<long long, milli>;
    using seconds      = duration<long long>;
    using minutes      = duration<int, ratio<60>>;
    using hours        = duration<int, ratio<3600>>;





#line 543 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

    template <class _Clock, class _Duration, class _Rep, class _Period>
    [[nodiscard]] constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator+(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>)  {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() + _Right);
    }

    template <class _Rep, class _Period, class _Clock, class _Duration>
    [[nodiscard]] constexpr time_point<_Clock, common_type_t<duration<_Rep, _Period>, _Duration>>
        operator+(const duration<_Rep, _Period>& _Left, const time_point<_Clock, _Duration>& _Right) noexcept(
            is_arithmetic_v<_Rep>&& is_arithmetic_v<typename _Duration::rep>)  {
        return _Right + _Left;
    }

    template <class _Clock, class _Duration, class _Rep, class _Period>
    [[nodiscard]] constexpr time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>
        operator-(const time_point<_Clock, _Duration>& _Left, const duration<_Rep, _Period>& _Right) noexcept(
            is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<_Rep>)  {
        using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
        return _RT(_Left.time_since_epoch() - _Right);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr common_type_t<_Duration1, _Duration2>
        operator-(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Left.time_since_epoch() - _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator==(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Left.time_since_epoch() == _Right.time_since_epoch();
    }


    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator!=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return !(_Left == _Right);
    }
#line 589 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator<(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Left.time_since_epoch() < _Right.time_since_epoch();
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator<=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return !(_Right < _Left);
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator>(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return _Right < _Left;
    }

    template <class _Clock, class _Duration1, class _Duration2>
    [[nodiscard]] constexpr bool
        operator>=(const time_point<_Clock, _Duration1>& _Left, const time_point<_Clock, _Duration2>& _Right) noexcept(
            is_arithmetic_v<typename _Duration1::rep>&& is_arithmetic_v<typename _Duration2::rep>)  {
        return !(_Left < _Right);
    }










    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> time_point_cast(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: duration_cast<_To>(_Time.time_since_epoch()));
    }

    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> floor(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: floor<_To>(_Time.time_since_epoch()));
    }

    template <class _To, class _Clock, class _Duration, enable_if_t<_Is_duration_v<_To>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> ceil(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: ceil<_To>(_Time.time_since_epoch()));
    }

    template <class _To, class _Clock, class _Duration,
        enable_if_t<_Is_duration_v<_To> && !treat_as_floating_point_v<typename _To::rep>, int> = 0>
    [[nodiscard]] constexpr time_point<_Clock, _To> round(const time_point<_Clock, _Duration>& _Time) noexcept(
        is_arithmetic_v<typename _Duration::rep>&& is_arithmetic_v<typename _To::rep>)  {
        
        return time_point<_Clock, _To>(::std::chrono:: round<_To>(_Time.time_since_epoch()));
    }

    struct system_clock { 
        using rep                       = long long;
        using period                    = ratio<1, 10'000'000>; 
        using duration                  = ::std::chrono:: duration<rep, period>;
        using time_point                = ::std::chrono:: time_point<system_clock>;
        static constexpr bool is_steady = false;

        [[nodiscard]] static time_point now() noexcept { 
            return time_point(duration(_Xtime_get_ticks()));
        }

        [[nodiscard]] static __time64_t to_time_t(const time_point& _Time) noexcept { 
            return duration_cast<seconds>(_Time.time_since_epoch()).count();
        }

        [[nodiscard]] static time_point from_time_t(__time64_t _Tm) noexcept { 
            return time_point{seconds{_Tm}};
        }
    };






#line 682 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

    struct steady_clock { 
        using rep                       = long long;
        using period                    = nano;
        using duration                  = nanoseconds;
        using time_point                = ::std::chrono:: time_point<steady_clock>;
        static constexpr bool is_steady = true;

        [[nodiscard]] static time_point now() noexcept { 
            const long long _Freq = _Query_perf_frequency(); 
            const long long _Ctr  = _Query_perf_counter();
            static_assert(period::num == 1, "This assumes period::num == 1.");
            
            
            
            
            
            const long long _Whole = (_Ctr / _Freq) * period::den;
            const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;
            return time_point(duration(_Whole + _Part));
        }
    };

    using high_resolution_clock = steady_clock;

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 3300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"
} 














#line 3316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"
























































#line 3373 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"

namespace chrono {


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"
} 
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































template <class _Rep, class _Period>
[[nodiscard]] bool _To_xtime_10_day_clamped(:: xtime& _Xt, const ::std::chrono:: duration<_Rep, _Period>& _Rel_time) noexcept(
    is_arithmetic_v<_Rep>) {
    
    
    
    
    constexpr ::std::chrono:: nanoseconds _Ten_days{::std::chrono:: hours{24} * 10};
    constexpr ::std::chrono:: duration<double> _Ten_days_d{_Ten_days};
    ::std::chrono:: nanoseconds _Tx0 = ::std::chrono:: system_clock::now().time_since_epoch();
    const bool _Clamped      = _Ten_days_d < _Rel_time;
    if (_Clamped) {
        _Tx0 += _Ten_days;
    } else {
        _Tx0 += ::std::chrono:: duration_cast<::std::chrono:: nanoseconds>(_Rel_time);
    }

    const auto _Whole_seconds = ::std::chrono:: duration_cast<::std::chrono:: seconds>(_Tx0);
    _Xt.sec                   = _Whole_seconds.count();
    _Tx0 -= _Whole_seconds;
    _Xt.nsec = static_cast<long>(_Tx0.count());
    return _Clamped;
}

inline namespace literals {
    inline namespace chrono_literals {
        [[nodiscard]] constexpr ::std::chrono:: hours operator"" h(unsigned long long _Val) noexcept  {
            return ::std::chrono:: hours(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, ratio<3600>> operator"" h(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, ratio<3600>>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: minutes(operator"" min)(unsigned long long _Val) noexcept  {
            return ::std::chrono:: minutes(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, ratio<60>>(operator"" min)(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, ratio<60>>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: seconds operator"" s(unsigned long long _Val) noexcept  {
            return ::std::chrono:: seconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double> operator"" s(long double _Val) noexcept  {
            return ::std::chrono:: duration<double>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: milliseconds operator"" ms(unsigned long long _Val) noexcept  {
            return ::std::chrono:: milliseconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, milli> operator"" ms(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, milli>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: microseconds operator"" us(unsigned long long _Val) noexcept  {
            return ::std::chrono:: microseconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, micro> operator"" us(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, micro>(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: nanoseconds operator"" ns(unsigned long long _Val) noexcept  {
            return ::std::chrono:: nanoseconds(_Val);
        }

        [[nodiscard]] constexpr ::std::chrono:: duration<double, nano> operator"" ns(long double _Val) noexcept
         {
            return ::std::chrono:: duration<double, nano>(_Val);
        }







#line 6577 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"
    } 
} 

namespace chrono {
    using namespace literals::chrono_literals;
} 



}


#pragma warning(pop)
#pragma pack(pop)
#line 6592 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"
#line 6593 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\chrono"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"





#pragma once











#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"





#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\__msvc_system_error_abi.hpp"





#pragma once






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )








#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\__msvc_system_error_abi.hpp"

extern "C" {
[[nodiscard]] size_t __stdcall __std_get_string_size_without_trailing_whitespace(
    const char* _Str, size_t _Size) noexcept;

[[nodiscard]] size_t __stdcall __std_system_error_allocate_message(
    unsigned long _Message_id, char** _Ptr_str) noexcept;
void __stdcall __std_system_error_deallocate_message(char* _Str) noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\__msvc_system_error_abi.hpp"
#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\__msvc_system_error_abi.hpp"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cerrno"





#pragma once







#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cerrno"
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cerrno"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xcall_once.h"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
struct once_flag { 
    constexpr once_flag() noexcept : _Opaque(nullptr) {}

    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;

    void* _Opaque;
};

using _Execute_once_fp_t = int(__stdcall*)(void*, void*, void**);

 int __cdecl _Execute_once(
    once_flag& _Flag, _Execute_once_fp_t _Callback, void* _Pv) noexcept;

template <class _Ty>
union _Immortalizer_impl { 
    constexpr _Immortalizer_impl() noexcept : _Storage{} {}
    _Immortalizer_impl(const _Immortalizer_impl&) = delete;
    _Immortalizer_impl& operator=(const _Immortalizer_impl&) = delete;
    ~_Immortalizer_impl() {
        
    }

    _Ty _Storage;
};
}



#pragma warning(pop)
#pragma pack(pop)
#line 52 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xcall_once.h"
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xcall_once.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xerrc.h"





#pragma once





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
enum class errc { 
    address_family_not_supported       = 102, 
    address_in_use                     = 100, 
    address_not_available              = 101, 
    already_connected                  = 113, 
    argument_list_too_long             = 7, 
    argument_out_of_domain             = 33, 
    bad_address                        = 14, 
    bad_file_descriptor                = 9, 
    bad_message                        = 104, 
    broken_pipe                        = 32, 
    connection_aborted                 = 106, 
    connection_already_in_progress     = 103, 
    connection_refused                 = 107, 
    connection_reset                   = 108, 
    cross_device_link                  = 18, 
    destination_address_required       = 109, 
    device_or_resource_busy            = 16, 
    directory_not_empty                = 41, 
    executable_format_error            = 8, 
    file_exists                        = 17, 
    file_too_large                     = 27, 
    filename_too_long                  = 38, 
    function_not_supported             = 40, 
    host_unreachable                   = 110, 
    identifier_removed                 = 111, 
    illegal_byte_sequence              = 42, 
    inappropriate_io_control_operation = 25, 
    interrupted                        = 4, 
    invalid_argument                   = 22, 
    invalid_seek                       = 29, 
    io_error                           = 5, 
    is_a_directory                     = 21, 
    message_size                       = 115, 
    network_down                       = 116, 
    network_reset                      = 117, 
    network_unreachable                = 118, 
    no_buffer_space                    = 119, 
    no_child_process                   = 10, 
    no_link                            = 121, 
    no_lock_available                  = 39, 
    no_message_available               = 120, 
    no_message                         = 122, 
    no_protocol_option                 = 123, 
    no_space_on_device                 = 28, 
    no_stream_resources                = 124, 
    no_such_device_or_address          = 6, 
    no_such_device                     = 19, 
    no_such_file_or_directory          = 2, 
    no_such_process                    = 3, 
    not_a_directory                    = 20, 
    not_a_socket                       = 128, 
    not_a_stream                       = 125, 
    not_connected                      = 126, 
    not_enough_memory                  = 12, 
    not_supported                      = 129, 
    operation_canceled                 = 105, 
    operation_in_progress              = 112, 
    operation_not_permitted            = 1, 
    operation_not_supported            = 130, 
    operation_would_block              = 140, 
    owner_dead                         = 133, 
    permission_denied                  = 13, 
    protocol_error                     = 134, 
    protocol_not_supported             = 135, 
    read_only_file_system              = 30, 
    resource_deadlock_would_occur      = 36, 
    resource_unavailable_try_again     = 11, 
    result_out_of_range                = 34, 
    state_not_recoverable              = 127, 
    stream_timeout                     = 137, 
    text_file_busy                     = 139, 
    timed_out                          = 138, 
    too_many_files_open_in_system      = 23, 
    too_many_files_open                = 24, 
    too_many_links                     = 31, 
    too_many_symbolic_link_levels      = 114, 
    value_too_large                    = 132, 
    wrong_protocol_type                = 136 
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xerrc.h"
#line 110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\xerrc.h"
#pragma external_header(pop)
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"


#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"



#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {
enum class io_errc { 
    stream = 1
};

template <class _Enum>
struct is_error_code_enum : false_type {};

template <>
struct is_error_code_enum<io_errc> : true_type {};

template <class _Ty>
 constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

template <class _Enum>
struct is_error_condition_enum : false_type {};

template <>
struct is_error_condition_enum<errc> : true_type {};

template <class _Ty>
 constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

class error_code;
class error_condition;
[[nodiscard]] error_code make_error_code(errc) noexcept;
[[nodiscard]] error_code make_error_code(io_errc) noexcept;
[[nodiscard]] error_condition make_error_condition(errc) noexcept;
[[nodiscard]] error_condition make_error_condition(io_errc) noexcept;

class error_category;

[[nodiscard]] const error_category& generic_category() noexcept;
[[nodiscard]] const error_category& iostream_category() noexcept;
[[nodiscard]] const error_category& system_category() noexcept;

class __declspec(novtable) error_category { 
public:
     error_category() noexcept { 
        _Addr = reinterpret_cast<uintptr_t>(this);
    }




        virtual ~error_category() noexcept = default;

    [[nodiscard]] virtual const char* name() const noexcept = 0;

    [[nodiscard]] virtual string message(int _Errval) const = 0;

    [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept;

    [[nodiscard]] virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

    [[nodiscard]] virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

    [[nodiscard]] bool operator==(const error_category& _Right) const noexcept {
        return _Addr == _Right._Addr;
    }


    [[nodiscard]] bool operator!=(const error_category& _Right) const noexcept {
        return !(*this == _Right);
    }
#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"







    [[nodiscard]] bool operator<(const error_category& _Right) const noexcept {
        return _Addr < _Right._Addr;
    }
#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

protected:
    uintptr_t _Addr;

    constexpr explicit error_category(const uintptr_t _Addr_) noexcept : _Addr(_Addr_) {}

    enum : uintptr_t { 
        _Future_addr   = 1,
        _Generic_addr  = 3,
        _Iostream_addr = 5,
        _System_addr   = 7
    };
};


[[nodiscard]] inline bool _System_error_equal(const error_code&, const error_condition&) noexcept;
#line 129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

class error_code { 
public:
    error_code() noexcept : _Myval(0), _Mycat(&::std:: system_category()) {} 

    error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        *this = make_error_code(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code& operator=(_Enum _Errcode) noexcept {
        *this = make_error_code(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: system_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] error_condition default_error_condition() const noexcept;

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    [[nodiscard]] friend bool operator==(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }

    [[nodiscard]] friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept {
        return _System_error_equal(_Left, _Right);
    }










    [[nodiscard]] friend bool operator<(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() < _Right.category()
            || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
    }
#line 198 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

    [[nodiscard]] friend bool operator==(const error_condition& _Left, const error_code& _Right) noexcept {
        return _System_error_equal(_Right, _Left);
    }

    [[nodiscard]] friend bool operator!=(const error_code& _Left, const error_code& _Right) noexcept {
        return !(_Left == _Right);
    }

    [[nodiscard]] friend bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept {
        return !_System_error_equal(_Left, _Right);
    }

    [[nodiscard]] friend bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept {
        return !_System_error_equal(_Right, _Left);
    }
#line 215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};

class error_condition { 
public:
    error_condition() noexcept : _Myval(0), _Mycat(&::std:: generic_category()) {} 

    error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        *this = make_error_condition(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition& operator=(_Enum _Errcode) noexcept {
        *this = make_error_condition(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: generic_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    [[nodiscard]] friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }











    [[nodiscard]] friend bool operator<(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() < _Right.category()
            || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
    }
#line 285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

    [[nodiscard]] friend bool operator!=(const error_condition& _Left, const error_condition& _Right) noexcept {
        return !(_Left == _Right);
    }
#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

    
    
    
    friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept;

    friend bool operator==(const error_condition& _Left, const error_code& _Right) noexcept;
    friend bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept;
    friend bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept;
#line 300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};


[[nodiscard]] inline bool _System_error_equal(const error_code& _Left, const error_condition& _Right) noexcept {
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}





























































#line 373 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

[[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const noexcept {
    
    return error_condition(_Errval, *this);
}

[[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {
    return default_error_condition(_Errval) == _Cond;
}

[[nodiscard]] inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {
    return *this == _Code.category() && _Code.value() == _Errval;
}

[[nodiscard]] inline error_condition error_code::default_error_condition() const noexcept {
    
    return category().default_error_condition(value());
}

[[nodiscard]] inline error_code make_error_code(errc _Errno) noexcept {
    return error_code(static_cast<int>(_Errno), ::std:: generic_category());
}

[[nodiscard]] inline error_code make_error_code(io_errc _Errno) noexcept {
    return error_code(static_cast<int>(_Errno), ::std:: iostream_category());
}

[[nodiscard]] inline error_condition make_error_condition(errc _Errno) noexcept {
    return error_condition(static_cast<int>(_Errno), ::std:: generic_category());
}

[[nodiscard]] inline error_condition make_error_condition(io_errc _Errno) noexcept {
    return error_condition(static_cast<int>(_Errno), ::std:: iostream_category());
}

template <>
struct hash<error_code> {
     typedef error_code argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const error_code& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

template <>
struct hash<error_condition> {
     typedef error_condition argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const error_condition& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

class _System_error : public runtime_error { 
private:
    static string _Makestr(error_code _Errcode, string _Message) { 
        if (!_Message.empty()) {
            _Message.append(": ");
        }

        _Message.append(_Errcode.message());
        return _Message;
    }

protected:
    _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

    error_code _Mycode; 
};

class system_error : public _System_error { 
private:
    using _Mybase = _System_error;

public:
    system_error(error_code _Errcode) : _Mybase(_Errcode, "") {}

    system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

    system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

    system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat), "") {}

    system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    [[nodiscard]] const error_code& code() const noexcept {
        return _Mycode;
    }






#line 475 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
};

[[noreturn]] inline void _Throw_system_error(const errc _Errno) {
    throw system_error{::std:: make_error_code(_Errno)};
}

 const char* __cdecl _Syserror_map(int);
 int __cdecl _Winerror_map(int);

struct _System_error_message {
    char* _Str;
    size_t _Length;

    explicit _System_error_message(const unsigned long _Ec) noexcept
        : _Str(nullptr), _Length(:: __std_system_error_allocate_message(_Ec, &_Str)) {}

    _System_error_message(const _System_error_message&) = delete;
    _System_error_message& operator=(const _System_error_message&) = delete;

    ~_System_error_message() {
        :: __std_system_error_deallocate_message(_Str);
    }
};

class _Generic_error_category : public error_category { 
public:
    constexpr _Generic_error_category() noexcept : error_category(_Generic_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "generic";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        return _Syserror_map(_Errcode);
    }
};

class _Iostream_error_category2 : public error_category { 
public:
    constexpr _Iostream_error_category2() noexcept : error_category(_Iostream_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "iostream";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        if (_Errcode == static_cast<int>(io_errc::stream)) {
            static constexpr char _Iostream_error[] = "iostream stream error";
            constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; 
            return string(_Iostream_error, _Iostream_error_length);
        } else {
            return _Syserror_map(_Errcode);
        }
    }
};

class _System_error_category : public error_category { 
public:
    constexpr _System_error_category() noexcept : error_category(_System_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "system";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));
        if (_Msg._Length == 0) {
            static constexpr char _Unknown_error[] = "unknown error";
            constexpr size_t _Unknown_error_length = sizeof(_Unknown_error) - 1; 
            return string(_Unknown_error, _Unknown_error_length);
        } else {
            return string(_Msg._Str, _Msg._Length);
        }
    }

    [[nodiscard]] error_condition default_error_condition(int _Errval) const noexcept override {
        
        const int _Posv = _Winerror_map(_Errval);
        if (_Posv == 0) {
            return error_condition(_Errval, ::std:: system_category());
        } else {
            return error_condition(_Posv, ::std:: generic_category());
        }
    }
};





































#line 598 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"





#line 604 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"





#line 610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
template <class _Ty>
struct _Constexpr_immortalize_impl {
    union {
        _Ty _Storage;
    };

    constexpr _Constexpr_immortalize_impl() noexcept : _Storage{} {}

    _Constexpr_immortalize_impl(const _Constexpr_immortalize_impl&) = delete;
    _Constexpr_immortalize_impl& operator=(const _Constexpr_immortalize_impl&) = delete;

    [[msvc::noop_dtor]] ~_Constexpr_immortalize_impl() {
        
    }
};

template <class _Ty>
[[nodiscard]] const _Ty& _Immortalize_memcpy_image() noexcept {
    static _Constexpr_immortalize_impl<_Ty> _Static;
    return _Static._Storage;
}



















#line 651 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"

[[nodiscard]] inline const error_category& generic_category() noexcept {
    return _Immortalize_memcpy_image<_Generic_error_category>();
}

[[nodiscard]] inline const error_category& iostream_category() noexcept {
    return _Immortalize_memcpy_image<_Iostream_error_category2>();
}

[[nodiscard]] inline const error_category& system_category() noexcept {
    return _Immortalize_memcpy_image<_System_error_category>();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 669 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
#line 670 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\system_error"
#pragma external_header(pop)
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"





#pragma once






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\process.h"








#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_startup.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\math.h"















#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_startup.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\vcruntime_startup.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {



typedef enum _crt_argv_mode
{
    _crt_argv_no_arguments,
    _crt_argv_unexpanded_arguments,
    _crt_argv_expanded_arguments,
} _crt_argv_mode;

typedef enum _crt_exit_return_mode
{
    _crt_exit_terminate_process,
    _crt_exit_return_to_caller
} _crt_exit_return_mode;

typedef enum _crt_exit_cleanup_mode
{
    _crt_exit_full_cleanup,
    _crt_exit_quick_cleanup,
    _crt_exit_no_cleanup
} _crt_exit_cleanup_mode;

extern _crt_exit_return_mode __current_exit_return_mode;



__vcrt_bool __cdecl __vcrt_initialize(void);
__vcrt_bool __cdecl __vcrt_uninitialize(  __vcrt_bool _Terminating);
__vcrt_bool __cdecl __vcrt_uninitialize_critical(void);
__vcrt_bool __cdecl __vcrt_thread_attach(void);
__vcrt_bool __cdecl __vcrt_thread_detach(void);

int __cdecl __isa_available_init(void);
_crt_argv_mode __cdecl _get_startup_argv_mode(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_startup.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct _EXCEPTION_POINTERS;

__declspec(dllimport) int __cdecl _seh_filter_dll(
      unsigned long               _ExceptionNum,
      struct _EXCEPTION_POINTERS* _ExceptionPtr
    );

__declspec(dllimport) int __cdecl _seh_filter_exe(
      unsigned long               _ExceptionNum,
      struct _EXCEPTION_POINTERS* _ExceptionPtr
    );








typedef enum _crt_app_type
{
    _crt_unknown_app,
    _crt_console_app,
    _crt_gui_app
} _crt_app_type;

__declspec(dllimport) _crt_app_type __cdecl _query_app_type(void);

__declspec(dllimport) void __cdecl _set_app_type(
      _crt_app_type _Type
    );

typedef int (__cdecl *_UserMathErrorFunctionPointer)(struct _exception *);

__declspec(dllimport) void __cdecl __setusermatherr(
    _UserMathErrorFunctionPointer _UserMathErrorFunction
    );

int __cdecl _is_c_termination_complete(void);








__declspec(dllimport) errno_t __cdecl _configure_narrow_argv(
      _crt_argv_mode mode
    );

__declspec(dllimport) errno_t __cdecl _configure_wide_argv(
      _crt_argv_mode mode
    );



int __cdecl _initialize_narrow_environment(void);
int __cdecl _initialize_wide_environment(void);

__declspec(dllimport) char**    __cdecl _get_initial_narrow_environment(void);
__declspec(dllimport) wchar_t** __cdecl _get_initial_wide_environment(void);

char*    __cdecl _get_narrow_winmain_command_line(void);
wchar_t* __cdecl _get_wide_winmain_command_line(void);

__declspec(dllimport) char**    __cdecl __p__acmdln(void);
__declspec(dllimport) wchar_t** __cdecl __p__wcmdln(void);





    
    
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_startup.h"








typedef void (__cdecl* _PVFV)(void);
typedef int  (__cdecl* _PIFV)(void);
typedef void (__cdecl* _PVFI)(int);


    __declspec(dllimport) void __cdecl _initterm(
            _PVFV*  _First,
                                     _PVFV*  _Last
        );

    __declspec(dllimport) int  __cdecl _initterm_e(
               _PIFV*  _First,
                                     _PIFV*  _Last
        );
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_startup.h"










typedef struct _onexit_table_t
{
    _PVFV* _first;
    _PVFV* _last;
    _PVFV* _end;
} _onexit_table_t;

__declspec(dllimport) int __cdecl _initialize_onexit_table(
      _onexit_table_t* _Table
    );

__declspec(dllimport) int __cdecl _register_onexit_function(
      _onexit_table_t* _Table,
      _onexit_t        _Function
    );

__declspec(dllimport) int __cdecl _execute_onexit_table(
      _onexit_table_t* _Table
    );

__declspec(dllimport) int __cdecl _crt_atexit(
      _PVFV _Function
    );

__declspec(dllimport) int __cdecl _crt_at_quick_exit(
      _PVFV _Function
    );










     
    __crt_bool __cdecl __acrt_initialize(void);

     
    __crt_bool __cdecl __acrt_uninitialize(
          __crt_bool _Terminating
        );

     
    __crt_bool __cdecl __acrt_uninitialize_critical(
          __crt_bool _Terminating
        );

     
    __crt_bool __cdecl __acrt_thread_attach(void);

     
    __crt_bool __cdecl __acrt_thread_detach(void);

#line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\corecrt_startup.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\process.h"


#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




















    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);

    __declspec(dllimport) int __cdecl system(  char const* _Command);

    __declspec(dllimport) void __cdecl _cexit(void);
    __declspec(dllimport) void __cdecl _c_exit(void);

    typedef void (__stdcall *_tls_callback_type)(void *, unsigned long, void *);
    __declspec(dllimport) void __cdecl _register_thread_local_exe_atexit_callback(  _tls_callback_type _Callback);

#line 57 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\process.h"



























typedef void     (__cdecl*   _beginthread_proc_type  )(void*);
typedef unsigned (__stdcall* _beginthreadex_proc_type)(void*);

__declspec(dllimport) uintptr_t __cdecl _beginthread(
          _beginthread_proc_type _StartAddress,
          unsigned               _StackSize,
      void*                  _ArgList
    );

__declspec(dllimport) void __cdecl _endthread(void);

 
__declspec(dllimport) uintptr_t __cdecl _beginthreadex(
       void*                    _Security,
           unsigned                 _StackSize,
           _beginthreadex_proc_type _StartAddress,
       void*                    _ArgList,
           unsigned                 _InitFlag,
      unsigned*                _ThrdAddr
    );

__declspec(dllimport) void __cdecl _endthreadex(
      unsigned _ReturnCode
    );





    __declspec(dllimport) int __cdecl _getpid(void);

    __declspec(dllimport) intptr_t __cdecl _cwait(
          int*     _TermStat,
               intptr_t _ProcHandle,
               int      _Action
        );

    __declspec(dllimport) intptr_t __cdecl _execl(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execle(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execlp(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execlpe(
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _execv(
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _execve(
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(dllimport) intptr_t __cdecl _execvp(
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _execvpe(
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(dllimport) intptr_t __cdecl _spawnl(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnle(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnlp(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnlpe(
            int         _Mode,
          char const* _FileName,
          char const* _Arguments,
        ...);

    __declspec(dllimport) intptr_t __cdecl _spawnv(
            int                _Mode,
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _spawnve(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(dllimport) intptr_t __cdecl _spawnvp(
            int                _Mode,
          char const*        _FileName,
          char const* const* _Arguments
        );

    __declspec(dllimport) intptr_t __cdecl _spawnvpe(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments,
          char const* const* _Environment
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "LoadLibrary" " " "instead. See online help for details."))
    __declspec(dllimport) intptr_t __cdecl _loaddll(
          char* _FileName
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "FreeLibrary" " " "instead. See online help for details."))
    __declspec(dllimport) int __cdecl _unloaddll(
          intptr_t _Handle
        );

    typedef int (__cdecl* _GetDllProcAddrProcType)(void);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetProcAddress" " " "instead. See online help for details."))
    __declspec(dllimport) _GetDllProcAddrProcType __cdecl _getdllprocaddr(
                intptr_t _Handle,
          char*    _ProcedureName,
                intptr_t _Ordinal
        );

#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\process.h"





    
    
    
    
    
    
    
    

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_cwait" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl cwait(
              int*     _TermStat,
                   intptr_t _ProcHandle,
                   int      _Action
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execl" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execl(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execle" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execle(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execlp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execlp(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execlpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execlpe(
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execv" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execv(
              char const*        _FileName,
              char const* const* _Arguments
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execve" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execve(
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execvp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execvp(
              char const*        _FileName,
              char const* const* _Arguments
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_execvpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl execvpe(
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnl" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnl(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnle" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnle(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnlp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnlp(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnlpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnlpe(
                int         _Mode,
              char const* _FileName,
              char const* _Arguments,
            ...);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnv" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnv(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments);

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnve" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnve(
                    int                _Mode,
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnvp" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnvp(
                int                _Mode,
              char const*        _FileName,
              char const* const* _Arguments
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_spawnvpe" ". See online help for details."))
        __declspec(dllimport) intptr_t __cdecl spawnvpe(
                    int                _Mode,
                  char const*        _FileName,
                  char const* const* _Arguments,
              char const* const* _Environment
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getpid" ". See online help for details."))
        __declspec(dllimport) int __cdecl getpid(void);

    #line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\process.h"

#line 369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\process.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\process.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"





#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {


#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"

class thread { 
public:
    class id;

    using native_handle_type = void*;

    thread() noexcept : _Thr{} {}

private:


#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"

    template <class _Tuple, size_t... _Indices>
    static unsigned int __stdcall _Invoke(void* _RawVals) noexcept  {
        
        const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals));
        _Tuple& _Tup = *_FnVals;
        ::std:: invoke(::std:: move(::std:: get<_Indices>(_Tup))...);
        _Cnd_do_broadcast_at_thread_exit(); 
        return 0;
    }

    template <class _Tuple, size_t... _Indices>
    [[nodiscard]] static constexpr auto _Get_invoke(index_sequence<_Indices...>) noexcept {
        return &_Invoke<_Tuple, _Indices...>;
    }

    template <class _Fn, class... _Args>
    void _Start(_Fn&& _Fx, _Args&&... _Ax) {
        using _Tuple                 = tuple<decay_t<_Fn>, decay_t<_Args>...>;
        auto _Decay_copied           = ::std:: make_unique<_Tuple>(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...);
        constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{});

#pragma warning(push)
#pragma warning(disable : 5039) 
                                
                                
        _Thr._Hnd =
            reinterpret_cast<void*>(:: _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
#pragma warning(pop)

        if (_Thr._Hnd) { 
            (void) _Decay_copied.release();
        } else { 
            _Thr._Id = 0;
            _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);
        }
    }

public:
    template <class _Fn, class... _Args, enable_if_t<!is_same_v<_Remove_cvref_t<_Fn>, thread>, int> = 0>
    [[nodiscard]] explicit thread(_Fn&& _Fx, _Args&&... _Ax) {
        _Start(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...);
    }

    ~thread() noexcept {
        if (joinable()) {
            ::std:: terminate();
        }
    }

    thread(thread&& _Other) noexcept : _Thr(::std:: exchange(_Other._Thr, {})) {}

    thread& operator=(thread&& _Other) noexcept {
        if (joinable()) {
            ::std:: terminate();
        }

        _Thr = ::std:: exchange(_Other._Thr, {});
        return *this;
    }

    thread(const thread&) = delete;
    thread& operator=(const thread&) = delete;

    void swap(thread& _Other) noexcept {
        ::std:: swap(_Thr, _Other._Thr);
    }

    [[nodiscard]] bool joinable() const noexcept {
        return _Thr._Id != 0;
    }

    void join() {
        if (!joinable()) {
            _Throw_Cpp_error(_INVALID_ARGUMENT);
        }

        if (_Thr._Id == _Thrd_id()) {
            _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);
        }

        if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {
            _Throw_Cpp_error(_NO_SUCH_PROCESS);
        }

        _Thr = {};
    }

    void detach() {
        if (!joinable()) {
            _Throw_Cpp_error(_INVALID_ARGUMENT);
        }

        _Check_C_return(_Thrd_detach(_Thr));
        _Thr = {};
    }

    [[nodiscard]] id get_id() const noexcept;

    [[nodiscard]] native_handle_type native_handle() noexcept  { 
        return _Thr._Hnd;
    }

    [[nodiscard]] static unsigned int hardware_concurrency() noexcept {
        return _Thrd_hardware_concurrency();
    }

private:
    _Thrd_t _Thr;
};

template <class _Rep, class _Period>
[[nodiscard]] auto _To_absolute_time(const chrono::duration<_Rep, _Period>& _Rel_time) noexcept {
    constexpr auto _Zero                 = chrono::duration<_Rep, _Period>::zero();
    const auto _Now                      = chrono::steady_clock::now();
    decltype(_Now + _Rel_time) _Abs_time = _Now; 
    if (_Rel_time > _Zero) {
        constexpr auto _Forever = (chrono::steady_clock::time_point::max) ();
        if (_Abs_time < _Forever - _Rel_time) {
            _Abs_time += _Rel_time;
        } else {
            _Abs_time = _Forever;
        }
    }
    return _Abs_time;
}

namespace this_thread {
    [[nodiscard]] thread::id get_id() noexcept;

    inline void yield() noexcept {
        _Thrd_yield();
    }

    inline void sleep_until(const xtime* _Abs_time) {
        _Thrd_sleep(_Abs_time);
    }

    template <class _Clock, class _Duration>
    void sleep_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {


#line 192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"
        for (;;) {
            const auto _Now = _Clock::now();
            if (_Abs_time <= _Now) {
                return;
            }

            :: xtime _Tgt;
            (void) _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);
            _Thrd_sleep(&_Tgt);
        }
    }

    template <class _Rep, class _Period>
    void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time) {
        sleep_until(_To_absolute_time(_Rel_time));
    }
} 

class thread::id { 
public:
    id() noexcept : _Id(0) {} 

private:
    id(_Thrd_id_t _Other_id) : _Id(_Other_id) {}

    _Thrd_id_t _Id;

    friend thread::id thread::get_id() const noexcept;
    friend thread::id this_thread::get_id() noexcept;
    friend bool operator==(thread::id _Left, thread::id _Right) noexcept;


#line 225 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"
    friend bool operator<(thread::id _Left, thread::id _Right) noexcept;
#line 227 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"
    template <class _Ch, class _Tr>
    friend basic_ostream<_Ch, _Tr>& operator<<(basic_ostream<_Ch, _Tr>& _Str, thread::id _Id);
    friend hash<thread::id>;
};

[[nodiscard]] inline thread::id thread::get_id() const noexcept {
    return _Thr._Id;
}

[[nodiscard]] inline thread::id this_thread::get_id() noexcept {
    return _Thrd_id();
}

inline void swap(thread& _Left, thread& _Right) noexcept {
    _Left.swap(_Right);
}

[[nodiscard]] inline bool operator==(thread::id _Left, thread::id _Right) noexcept {
    return _Left._Id == _Right._Id;
}





#line 253 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"
[[nodiscard]] inline bool operator!=(thread::id _Left, thread::id _Right) noexcept {
    return !(_Left == _Right);
}

[[nodiscard]] inline bool operator<(thread::id _Left, thread::id _Right) noexcept {
    return _Left._Id < _Right._Id;
}

[[nodiscard]] inline bool operator<=(thread::id _Left, thread::id _Right) noexcept {
    return !(_Right < _Left);
}

[[nodiscard]] inline bool operator>(thread::id _Left, thread::id _Right) noexcept {
    return _Right < _Left;
}

[[nodiscard]] inline bool operator>=(thread::id _Left, thread::id _Right) noexcept {
    return !(_Left < _Right);
}
#line 273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"

template <class _Ch, class _Tr>
basic_ostream<_Ch, _Tr>& operator<<(basic_ostream<_Ch, _Tr>& _Str, thread::id _Id) {
    return _Str << _Id._Id;
}

template <>
struct hash<thread::id> {
     typedef thread::id argument_type;
     typedef size_t result_type;

    [[nodiscard]] size_t operator()(const thread::id _Keyval) const noexcept {
        return _Hash_representation(_Keyval._Id);
    }
};





























































































#line 382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"
}



#pragma warning(pop)
#pragma pack(pop)
#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"
#line 390 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\thread"
#pragma external_header(pop)
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )




namespace std {


class condition_variable;
class condition_variable_any;

class _Mutex_base { 
public:
    _Mutex_base(int _Flags = 0) noexcept {
        _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);
    }

    ~_Mutex_base() noexcept {
        _Mtx_destroy_in_situ(_Mymtx());
    }

    _Mutex_base(const _Mutex_base&) = delete;
    _Mutex_base& operator=(const _Mutex_base&) = delete;

    void lock() {
        _Check_C_return(_Mtx_lock(_Mymtx()));
    }

    [[nodiscard]] bool try_lock() {
        const auto _Res = _Mtx_trylock(_Mymtx());
        switch (_Res) {
        case _Thrd_success:
            return true;
        case _Thrd_busy:
            return false;
        default:
            _Throw_C_error(_Res);
        }
    }

    void unlock() {
        _Mtx_unlock(_Mymtx());
    }

    using native_handle_type = void*;

    [[nodiscard]] native_handle_type native_handle() {
        return _Mtx_getconcrtcs(_Mymtx());
    }

private:
    friend condition_variable;
    friend condition_variable_any;

    aligned_storage_t<80, 8> _Mtx_storage;

    _Mtx_t _Mymtx() noexcept { 
        return reinterpret_cast<_Mtx_t>(&_Mtx_storage);
    }
};

class mutex : public _Mutex_base { 
public:
     mutex() noexcept 
        : _Mutex_base() {}

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;
};

class recursive_mutex : public _Mutex_base { 
public:
    recursive_mutex() : _Mutex_base(_Mtx_recursive) {}

    [[nodiscard]] bool try_lock() noexcept {
        return _Mutex_base::try_lock();
    }

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;
};
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"

struct adopt_lock_t { 
    explicit adopt_lock_t() = default;
};

struct defer_lock_t { 
    explicit defer_lock_t() = default;
};

struct try_to_lock_t { 
    explicit try_to_lock_t() = default;
};

 constexpr adopt_lock_t adopt_lock{};
 constexpr defer_lock_t defer_lock{};
 constexpr try_to_lock_t try_to_lock{};

template <class _Mutex>
class unique_lock { 
public:
    using mutex_type = _Mutex;

    unique_lock() noexcept : _Pmtx(nullptr), _Owns(false) {}

    [[nodiscard]] explicit unique_lock(_Mutex& _Mtx)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(false) { 
        _Pmtx->lock();
        _Owns = true;
    }

    [[nodiscard]] unique_lock(_Mutex& _Mtx, adopt_lock_t)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(true) {} 

    unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(false) {} 

    [[nodiscard]] unique_lock(_Mutex& _Mtx, try_to_lock_t)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock()) {} 

    template <class _Rep, class _Period>
    [[nodiscard]] unique_lock(_Mutex& _Mtx, const chrono::duration<_Rep, _Period>& _Rel_time)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_for(_Rel_time)) {} 

    template <class _Clock, class _Duration>
    [[nodiscard]] unique_lock(_Mutex& _Mtx, const chrono::time_point<_Clock, _Duration>& _Abs_time)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_until(_Abs_time)) {
        


#line 157 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
    }

    [[nodiscard]] unique_lock(_Mutex& _Mtx, const xtime* _Abs_time)
        : _Pmtx(::std:: addressof(_Mtx)), _Owns(false) { 
        _Owns = _Pmtx->try_lock_until(_Abs_time);
    }

    [[nodiscard]] unique_lock(unique_lock&& _Other) noexcept : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns) {
        _Other._Pmtx = nullptr;
        _Other._Owns = false;
    }

    unique_lock& operator=(unique_lock&& _Other) {
        if (this != ::std:: addressof(_Other)) {
            if (_Owns) {
                _Pmtx->unlock();
            }

            _Pmtx        = _Other._Pmtx;
            _Owns        = _Other._Owns;
            _Other._Pmtx = nullptr;
            _Other._Owns = false;
        }
        return *this;
    }

    ~unique_lock() noexcept {
        if (_Owns) {
            _Pmtx->unlock();
        }
    }

    unique_lock(const unique_lock&) = delete;
    unique_lock& operator=(const unique_lock&) = delete;

    void lock() { 
        _Validate();
        _Pmtx->lock();
        _Owns = true;
    }

    [[nodiscard]] bool try_lock() {
        _Validate();
        _Owns = _Pmtx->try_lock();
        return _Owns;
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time) {
        _Validate();
        _Owns = _Pmtx->try_lock_for(_Rel_time);
        return _Owns;
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {


#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
        _Validate();
        _Owns = _Pmtx->try_lock_until(_Abs_time);
        return _Owns;
    }

    [[nodiscard]] bool try_lock_until(const xtime* _Abs_time) {
        _Validate();
        _Owns = _Pmtx->try_lock_until(_Abs_time);
        return _Owns;
    }

    void unlock() {
        if (!_Pmtx || !_Owns) {
            _Throw_system_error(errc::operation_not_permitted);
        }

        _Pmtx->unlock();
        _Owns = false;
    }

    void swap(unique_lock& _Other) noexcept {
        ::std:: swap(_Pmtx, _Other._Pmtx);
        ::std:: swap(_Owns, _Other._Owns);
    }

    _Mutex* release() noexcept {
        _Mutex* _Res = _Pmtx;
        _Pmtx        = nullptr;
        _Owns        = false;
        return _Res;
    }

    [[nodiscard]] bool owns_lock() const noexcept {
        return _Owns;
    }

    explicit operator bool() const noexcept {
        return _Owns;
    }

    [[nodiscard]] _Mutex* mutex() const noexcept {
        return _Pmtx;
    }

private:
    _Mutex* _Pmtx;
    bool _Owns;

    void _Validate() const { 
        if (!_Pmtx) {
            _Throw_system_error(errc::operation_not_permitted);
        }

        if (_Owns) {
            _Throw_system_error(errc::resource_deadlock_would_occur);
        }
    }
};

template <class _Mutex>
void swap(unique_lock<_Mutex>& _Left, unique_lock<_Mutex>& _Right) noexcept {
    _Left.swap(_Right);
}

template <size_t... _Indices, class... _LockN>
void _Lock_from_locks(const int _Target, index_sequence<_Indices...>, _LockN&... _LkN) { 
    int _Ignored[] = {((static_cast<int>(_Indices) == _Target ? (void) _LkN.lock() : void()), 0)...};
    (void) _Ignored;
}

template <size_t... _Indices, class... _LockN>
bool _Try_lock_from_locks(
    const int _Target, index_sequence<_Indices...>, _LockN&... _LkN) { 
    bool _Result{};
    int _Ignored[] = {((static_cast<int>(_Indices) == _Target ? (void) (_Result = _LkN.try_lock()) : void()), 0)...};
    (void) _Ignored;
    return _Result;
}

template <size_t... _Indices, class... _LockN>
void _Unlock_locks(const int _First, const int _Last, index_sequence<_Indices...>, _LockN&... _LkN) noexcept
 {
    
    int _Ignored[] = {
        ((_First <= static_cast<int>(_Indices) && static_cast<int>(_Indices) < _Last ? (void) _LkN.unlock() : void()),
            0)...};
    (void) _Ignored;
}

template <class... _LockN>
int _Try_lock_range(const int _First, const int _Last, _LockN&... _LkN) {
    using _Indices = index_sequence_for<_LockN...>;
    int _Next      = _First;
    try {
    for (; _Next != _Last; ++_Next) {
        if (!_Try_lock_from_locks(_Next, _Indices{}, _LkN...)) { 
            _Unlock_locks(_First, _Next, _Indices{}, _LkN...);
            return _Next;
        }
    }
    } catch (...) {
    _Unlock_locks(_First, _Next, _Indices{}, _LkN...);
    throw;
    }

    return -1;
}

template <class _Lock0, class _Lock1, class _Lock2, class... _LockN>
int _Try_lock1(_Lock0& _Lk0, _Lock1& _Lk1, _Lock2& _Lk2, _LockN&... _LkN) { 
    return _Try_lock_range(0, sizeof...(_LockN) + 3, _Lk0, _Lk1, _Lk2, _LkN...);
}

template <class _Lock0, class _Lock1>
int _Try_lock1(_Lock0& _Lk0, _Lock1& _Lk1) {
    
    if (!_Lk0.try_lock()) {
        return 0;
    }

    try {
    if (!_Lk1.try_lock()) {
        _Lk0.unlock();
        return 1;
    }
    } catch (...) {
    _Lk0.unlock();
    throw;
    }

    return -1;
}

template <class _Lock0, class _Lock1, class... _LockN>
[[nodiscard]] int try_lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN) { 
    return _Try_lock1(_Lk0, _Lk1, _LkN...);
}

template <class... _LockN>
int _Lock_attempt(const int _Hard_lock, _LockN&... _LkN) {
    
    using _Indices = index_sequence_for<_LockN...>;
    _Lock_from_locks(_Hard_lock, _Indices{}, _LkN...);
    int _Failed        = -1;
    int _Backout_start = _Hard_lock; 

    try {
    _Failed = _Try_lock_range(0, _Hard_lock, _LkN...);
    if (_Failed == -1) {
        _Backout_start = 0; 
        _Failed        = _Try_lock_range(_Hard_lock + 1, sizeof...(_LockN), _LkN...);
        if (_Failed == -1) { 
            return -1;
        }
    }
    } catch (...) {
    _Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices{}, _LkN...);
    throw;
    }

    
    _Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices{}, _LkN...);
    ::std:: this_thread::yield();
    return _Failed;
}

template <class _Lock0, class _Lock1, class _Lock2, class... _LockN>
void _Lock_nonmember1(_Lock0& _Lk0, _Lock1& _Lk1, _Lock2& _Lk2, _LockN&... _LkN) {
    
    int _Hard_lock = 0;
    while (_Hard_lock != -1) {
        _Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...);
    }
}

template <class _Lock0, class _Lock1>
bool _Lock_attempt_small(_Lock0& _Lk0, _Lock1& _Lk1) {
    
    _Lk0.lock();
    try {
    if (_Lk1.try_lock()) {
        return false;
    }
    } catch (...) {
    _Lk0.unlock();
    throw;
    }

    _Lk0.unlock();
    ::std:: this_thread::yield();
    return true;
}

template <class _Lock0, class _Lock1>
void _Lock_nonmember1(_Lock0& _Lk0, _Lock1& _Lk1) {
    
    while (_Lock_attempt_small(_Lk0, _Lk1) && _Lock_attempt_small(_Lk1, _Lk0)) { 
    }
}

template <class _Lock0, class _Lock1, class... _LockN>
void lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN) { 
    _Lock_nonmember1(_Lk0, _Lk1, _LkN...);
}

template <class _Mutex>
class [[nodiscard]] lock_guard { 
public:
    using mutex_type = _Mutex;

    explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { 
        _MyMutex.lock();
    }

    lock_guard(_Mutex& _Mtx, adopt_lock_t) : _MyMutex(_Mtx) {} 

    ~lock_guard() noexcept {
        _MyMutex.unlock();
    }

    lock_guard(const lock_guard&) = delete;
    lock_guard& operator=(const lock_guard&) = delete;

private:
    _Mutex& _MyMutex;
};






















































#line 497 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"







#line 505 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"










extern "C" [[nodiscard]] int __declspec(dllimport) __stdcall __std_init_once_begin_initialize(
    void** _LpInitOnce, unsigned long _DwFlags, int* _FPending, void** _LpContext) noexcept;









extern "C" [[nodiscard]] int __declspec(dllimport) __stdcall __std_init_once_complete(
    void** _LpInitOnce, unsigned long _DwFlags, void* _LpContext) noexcept;



 constexpr unsigned long _Init_once_init_failed = 0x4UL;

struct _Init_once_completer {
    once_flag& _Once;
    unsigned long _DwFlags;
    ~_Init_once_completer() {
        if (__std_init_once_complete(&_Once._Opaque, _DwFlags, nullptr) == 0) {
            :: abort();
        }
    }
};

template <class _Fn, class... _Args>
void(call_once)(once_flag& _Once, _Fn&& _Fx, _Args&&... _Ax) noexcept(
    noexcept(::std:: invoke(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...)))  {
    
    
    int _Pending;
    if (__std_init_once_begin_initialize(&_Once._Opaque, 0, &_Pending, nullptr) == 0) {
        :: abort();
    }

    if (_Pending != 0) {
        _Init_once_completer _Op{_Once, _Init_once_init_failed};
        ::std:: invoke(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...);
        _Op._DwFlags = 0;
    }
}






enum class cv_status { 
    no_timeout,
    timeout
};

class condition_variable { 
public:
    using native_handle_type = _Cnd_t;

    condition_variable() {
        _Cnd_init_in_situ(_Mycnd());
    }

    ~condition_variable() noexcept {
        _Cnd_destroy_in_situ(_Mycnd());
    }

    condition_variable(const condition_variable&) = delete;
    condition_variable& operator=(const condition_variable&) = delete;

    void notify_one() noexcept { 
        _Cnd_signal(_Mycnd());
    }

    void notify_all() noexcept { 
        _Cnd_broadcast(_Mycnd());
    }

    void wait(unique_lock<mutex>& _Lck) { 
        
        _Cnd_wait(_Mycnd(), _Lck.mutex()->_Mymtx());
    }

    template <class _Predicate>
    void wait(unique_lock<mutex>& _Lck, _Predicate _Pred) { 
        while (!_Pred()) {
            wait(_Lck);
        }
    }

    template <class _Rep, class _Period>
    cv_status wait_for(unique_lock<mutex>& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time) {
        
        if (_Rel_time <= chrono::duration<_Rep, _Period>::zero()) {
            return cv_status::timeout;
        }

        
        
        :: xtime _Tgt;
        const bool _Clamped     = _To_xtime_10_day_clamped(_Tgt, _Rel_time);
        const cv_status _Result = wait_until(_Lck, &_Tgt);
        if (_Clamped) {
            return cv_status::no_timeout;
        }

        return _Result;
    }

    template <class _Rep, class _Period, class _Predicate>
    bool wait_for(unique_lock<mutex>& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time, _Predicate _Pred) {
        
        return _Wait_until1(_Lck, _To_absolute_time(_Rel_time), _Pred);
    }

    template <class _Clock, class _Duration>
    cv_status wait_until(unique_lock<mutex>& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 636 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
        for (;;) {
            const auto _Now = _Clock::now();
            if (_Abs_time <= _Now) {
                return cv_status::timeout;
            }

            :: xtime _Tgt;
            (void) _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);
            const cv_status _Result = wait_until(_Lck, &_Tgt);
            if (_Result == cv_status::no_timeout) {
                return cv_status::no_timeout;
            }
        }
    }

    template <class _Clock, class _Duration, class _Predicate>
    bool wait_until(
        unique_lock<mutex>& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time, _Predicate _Pred) {
        


#line 658 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
        return _Wait_until1(_Lck, _Abs_time, _Pred);
    }

    cv_status wait_until(unique_lock<mutex>& _Lck, const xtime* _Abs_time) {
        
        if (!_Mtx_current_owns(_Lck.mutex()->_Mymtx())) {
            _Throw_Cpp_error(_OPERATION_NOT_PERMITTED);
        }

        
        const int _Res = _Cnd_timedwait(_Mycnd(), _Lck.mutex()->_Mymtx(), _Abs_time);
        switch (_Res) {
        case _Thrd_success:
            return cv_status::no_timeout;
        case _Thrd_timedout:
            return cv_status::timeout;
        default:
            _Throw_C_error(_Res);
        }
    }

    template <class _Predicate>
    bool wait_until(unique_lock<mutex>& _Lck, const xtime* _Abs_time, _Predicate _Pred) {
        
        return _Wait_until1(_Lck, _Abs_time, _Pred);
    }

    [[nodiscard]] native_handle_type native_handle() {
        return _Mycnd();
    }

    void _Register(unique_lock<mutex>& _Lck, int* _Ready) { 
        _Cnd_register_at_thread_exit(_Mycnd(), _Lck.release()->_Mymtx(), _Ready);
    }

    void _Unregister(mutex& _Mtx) { 
        _Cnd_unregister_at_thread_exit(_Mtx._Mymtx());
    }

private:
    aligned_storage_t<72, 8> _Cnd_storage;

    _Cnd_t _Mycnd() noexcept { 
        return reinterpret_cast<_Cnd_t>(&_Cnd_storage);
    }

    template <class _Predicate>
    bool _Wait_until1(unique_lock<mutex>& _Lck, const xtime* _Abs_time, _Predicate& _Pred) {
        
        while (!_Pred()) {
            if (wait_until(_Lck, _Abs_time) == cv_status::timeout) {
                return _Pred();
            }
        }

        return true;
    }

    template <class _Clock, class _Duration, class _Predicate>
    bool _Wait_until1(
        unique_lock<mutex>& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time, _Predicate& _Pred) {
        while (!_Pred()) {
            const auto _Now = _Clock::now();
            if (_Abs_time <= _Now) {
                return false;
            }

            :: xtime _Tgt;
            const bool _Clamped = _To_xtime_10_day_clamped(_Tgt, _Abs_time - _Now);
            if (wait_until(_Lck, &_Tgt) == cv_status::timeout && !_Clamped) {
                return _Pred();
            }
        }

        return true;
    }
};

struct _UInt_is_zero {
    const unsigned int& _UInt;

    [[nodiscard]] bool operator()() const {
        return _UInt == 0;
    }
};

class timed_mutex { 
public:
    timed_mutex() noexcept : _My_locked(0) {}

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void lock() { 
        unique_lock<mutex> _Lock(_My_mutex);
        while (_My_locked != 0) {
            _My_cond.wait(_Lock);
        }

        _My_locked = 0xffffffff;
    }

    [[nodiscard]] bool try_lock() noexcept { 
        lock_guard<mutex> _Lock(_My_mutex);
        if (_My_locked != 0) {
            return false;
        } else {
            _My_locked = 0xffffffff;
            return true;
        }
    }

    void unlock() { 
        {
            
            lock_guard<mutex> _Lock(_My_mutex);
            _My_locked = 0;
        }
        _My_cond.notify_one();
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time) { 
        return try_lock_until(_To_absolute_time(_Rel_time));
    }

    template <class _Time>
    bool _Try_lock_until(_Time _Abs_time) { 
        unique_lock<mutex> _Lock(_My_mutex);
        if (!_My_cond.wait_until(_Lock, _Abs_time, _UInt_is_zero{_My_locked})) {
            return false;
        }

        _My_locked = 0xffffffff;
        return true;
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 801 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
        return _Try_lock_until(_Abs_time);
    }

    [[nodiscard]] bool try_lock_until(const xtime* _Abs_time) { 
        return _Try_lock_until(_Abs_time);
    }

private:
    mutex _My_mutex;
    condition_variable _My_cond;
    unsigned int _My_locked;
};

class recursive_timed_mutex { 
public:
    recursive_timed_mutex() noexcept : _My_locked(0) {}

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void lock() { 
        const thread::id _Tid = this_thread::get_id();

        unique_lock<mutex> _Lock(_My_mutex);

        if (_Tid == _My_owner) {
            if (_My_locked < 0xffffffff) {
                ++_My_locked;
            } else {
                _Throw_system_error(errc::device_or_resource_busy);
            }
        } else {
            while (_My_locked != 0) {
                _My_cond.wait(_Lock);
            }

            _My_locked = 1;
            _My_owner  = _Tid;
        }
    }

    [[nodiscard]] bool try_lock() noexcept { 
        const thread::id _Tid = this_thread::get_id();

        lock_guard<mutex> _Lock(_My_mutex);

        if (_Tid == _My_owner) {
            if (_My_locked < 0xffffffff) {
                ++_My_locked;
            } else {
                return false;
            }
        } else {
            if (_My_locked != 0) {
                return false;
            } else {
                _My_locked = 1;
                _My_owner  = _Tid;
            }
        }
        return true;
    }

    void unlock() { 
        bool _Do_notify = false;

        {
            lock_guard<mutex> _Lock(_My_mutex);
            --_My_locked;
            if (_My_locked == 0) {
                _Do_notify = true;
                _My_owner  = thread::id();
            }
        }

        if (_Do_notify) {
            _My_cond.notify_one();
        }
    }

    template <class _Rep, class _Period>
    [[nodiscard]] bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time) { 
        return try_lock_until(_To_absolute_time(_Rel_time));
    }

    template <class _Time>
    bool _Try_lock_until(_Time _Abs_time) { 
        const thread::id _Tid = this_thread::get_id();

        unique_lock<mutex> _Lock(_My_mutex);

        if (_Tid == _My_owner) {
            if (_My_locked < 0xffffffff) {
                ++_My_locked;
            } else {
                return false;
            }
        } else {
            if (!_My_cond.wait_until(_Lock, _Abs_time, _UInt_is_zero{_My_locked})) {
                return false;
            }

            _My_locked = 1;
            _My_owner  = _Tid;
        }
        return true;
    }

    template <class _Clock, class _Duration>
    [[nodiscard]] bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 915 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
        return _Try_lock_until(_Abs_time);
    }

    [[nodiscard]] bool try_lock_until(const xtime* _Abs_time) { 
        return _Try_lock_until(_Abs_time);
    }

private:
    mutex _My_mutex;
    condition_variable _My_cond;
    unsigned int _My_locked;
    thread::id _My_owner;
};
#line 929 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
}


#pragma warning(pop)
#pragma pack(pop)
#line 935 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
#line 936 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\mutex"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"



#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294  4984 5053 )








namespace std {
template <class _Lock>
struct [[nodiscard]] _Unlock_guard {
    explicit _Unlock_guard(_Lock& _Mtx_) : _Mtx(_Mtx_) {
        _Mtx.unlock();
    }

    ~_Unlock_guard() noexcept  {
        
        
        
        
        _Mtx.lock();
    }

    _Unlock_guard(const _Unlock_guard&) = delete;
    _Unlock_guard& operator=(const _Unlock_guard&) = delete;

private:
    _Lock& _Mtx;
};

class condition_variable_any { 
public:
    condition_variable_any() : _Myptr{::std:: make_shared<mutex>()} {
        _Cnd_init_in_situ(_Mycnd());
    }

    ~condition_variable_any() noexcept {
        _Cnd_destroy_in_situ(_Mycnd());
    }

    condition_variable_any(const condition_variable_any&) = delete;
    condition_variable_any& operator=(const condition_variable_any&) = delete;

    void notify_one() noexcept { 
        lock_guard<mutex> _Guard{*_Myptr};
        _Cnd_signal(_Mycnd());
    }

    void notify_all() noexcept { 
        lock_guard<mutex> _Guard{*_Myptr};
        _Cnd_broadcast(_Mycnd());
    }

    template <class _Lock>
    void wait(_Lock& _Lck) noexcept  { 
        const shared_ptr<mutex> _Ptr = _Myptr; 
        unique_lock<mutex> _Guard{*_Ptr};
        _Unlock_guard<_Lock> _Unlock_outer{_Lck};
        _Cnd_wait(_Mycnd(), _Ptr->_Mymtx());
        _Guard.unlock();
    } 

    template <class _Lock, class _Predicate>
    void wait(_Lock& _Lck, _Predicate _Pred) noexcept(noexcept(static_cast<bool>(_Pred())))  {
        
        while (!static_cast<bool>(_Pred())) {
            wait(_Lck);
        }
    }

    template <class _Lock, class _Clock, class _Duration>
    cv_status wait_until(_Lock& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time) {
        


#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"
        return wait_for(_Lck, _Abs_time - _Clock::now());
    }

    template <class _Lock, class _Clock, class _Duration, class _Predicate>
    bool wait_until(_Lock& _Lck, const chrono::time_point<_Clock, _Duration>& _Abs_time, _Predicate _Pred) {
        


#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"
        while (!_Pred()) {
            if (wait_until(_Lck, _Abs_time) == cv_status::timeout) {
                return _Pred();
            }
        }

        return true;
    }

    template <class _Lock, class _Rep, class _Period>
    cv_status wait_for(_Lock& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time) { 
        if (_Rel_time <= chrono::duration<_Rep, _Period>::zero()) {
            _Unlock_guard<_Lock> _Unlock_outer{_Lck};
            (void) _Unlock_outer;
            return cv_status::timeout;
        }

        
        
        :: xtime _Tgt;
        const bool _Clamped     = _To_xtime_10_day_clamped(_Tgt, _Rel_time);
        const cv_status _Result = _Wait_until(_Lck, &_Tgt);
        if (_Clamped) {
            return cv_status::no_timeout;
        }

        return _Result;
    }

    template <class _Lock, class _Rep, class _Period, class _Predicate>
    bool wait_for(_Lock& _Lck, const chrono::duration<_Rep, _Period>& _Rel_time, _Predicate _Pred) {
        
        return wait_until(_Lck, _To_absolute_time(_Rel_time), ::std:: move(_Pred));
    }

    template <class _Lock>
    cv_status wait_until(_Lock& _Lck, const xtime* const _Abs_time) { 
        return _Wait_until(_Lck, _Abs_time);
    }

    template <class _Lock, class _Predicate>
    bool wait_until(_Lock& _Lck, const xtime* const _Abs_time, _Predicate _Pred) {
        
        while (!_Pred()) {
            if (_Wait_until(_Lck, _Abs_time) == cv_status::timeout) {
                return _Pred();
            }
        }
        return true;
    }























































































#line 245 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"

private:
    shared_ptr<mutex> _Myptr;

    aligned_storage_t<72, 8> _Cnd_storage;

    [[nodiscard]] _Cnd_t _Mycnd() noexcept { 
        return reinterpret_cast<_Cnd_t>(&_Cnd_storage);
    }

    template <class _Lock>
    cv_status _Wait_until(_Lock& _Lck, const xtime* const _Abs_time) { 
        const shared_ptr<mutex> _Ptr = _Myptr; 
        unique_lock<mutex> _Guard{*_Ptr};
        _Unlock_guard<_Lock> _Unlock_outer{_Lck};
        const int _Res = _Cnd_timedwait(_Mycnd(), _Ptr->_Mymtx(), _Abs_time);
        _Guard.unlock();

        switch (_Res) {
        case _Thrd_success:
            return cv_status::no_timeout;
        case _Thrd_timedout:
            return cv_status::timeout;
        default:
            _Throw_C_error(_Res);
        }
    }
};

inline void notify_all_at_thread_exit(condition_variable& _Cnd, unique_lock<mutex> _Lck) {
    
    _Cnd._Register(_Lck, nullptr);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 284 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"
#line 285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\condition_variable"
#pragma external_header(pop)
#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplwin.h"



#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppltaskscheduler.h"















#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\crtdefs.h"


















































































#pragma external_header(pop)
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppltaskscheduler.h"

#pragma pack(push,8)
#pragma warning(push,3)

namespace Concurrency { namespace details {
    typedef void(__cdecl *_Threadpool_callback)(void*);

    struct _Threadpool_chore
    {
        void *_M_work; 
        _Threadpool_callback _M_callback;
        void *_M_data;

        _Threadpool_chore(_Threadpool_callback _Callback, void *_Data) : _M_work(nullptr), _M_callback(_Callback), _M_data(_Data) {}
        _Threadpool_chore() : _M_work(nullptr), _M_callback(nullptr), _M_data(nullptr) {}
    };

     int __cdecl _Schedule_chore(_Threadpool_chore*);
     void __cdecl _Release_chore(_Threadpool_chore*);
     int __cdecl _Reschedule_chore(const _Threadpool_chore*);


    class _Threadpool_task
    {
        _Threadpool_chore _M_chore;

        static void __cdecl _Callback(void *_TpTask)
        {
            static_cast<_Threadpool_task*>(_TpTask)->_Invoke();
        }

    public:

        _Threadpool_task(): _M_chore{&_Callback, this} {}

        virtual void _Invoke() noexcept = 0;

        virtual ~_Threadpool_task()
        {
            _Release_chore(&_M_chore);
        }

        void _Schedule()
        {
            _Schedule_chore(&_M_chore);
        }

        void _Reschedule() const
        {
            _Reschedule_chore(&_M_chore);
        }

        bool _Is_scheduled() const noexcept
        {
            return _M_chore._M_work != nullptr;
        }
    };
} }

#pragma warning(pop)
#pragma pack(pop)
#pragma external_header(pop)
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplwin.h"

#pragma pack(push,8)
#pragma warning(push,3)



namespace Concurrency
{
namespace details
{

class _DefaultPPLTaskScheduler : public scheduler_interface
{
public:

    class _PPLTaskChore
    {
        _Threadpool_chore _M_Chore;
        TaskProc_t _M_proc;
        void *_M_param;

        static void __cdecl _Callback(void *_Args)
        {
            auto _Chore = ::std::unique_ptr<_PPLTaskChore>(static_cast<_PPLTaskChore*>(_Args));
            _Chore->_M_proc(_Chore->_M_param);
        }

    public:
        ~_PPLTaskChore()
        {
            _Release_chore(&_M_Chore);
        }

        _PPLTaskChore(TaskProc_t _Proc, void *_Param) : _M_Chore{&_Callback, this}, _M_proc(_Proc), _M_param(_Param)
        {
        }

        void _Schedule()
        {
            if (_Schedule_chore(&_M_Chore) != 0)
            {
                delete this;
                throw ::std::runtime_error("Fail to schedule the chore!");
            }
        }
    };

    virtual void schedule( TaskProc_t _Proc, void* _Param) override
    {
        (new _PPLTaskChore{ _Proc, _Param })->_Schedule();
    }
};

inline ::std::shared_ptr<scheduler_interface> * _GetStaticAmbientSchedulerStorage()
{
    
#pragma warning(suppress: 4640)
    static ::std::shared_ptr<scheduler_interface> _S_scheduler;
    return &_S_scheduler;
}

inline ::std::shared_ptr<scheduler_interface> & _GetStaticAmbientSchedulerRef()
{
    static ::std::once_flag _Flag;
    static ::std::shared_ptr<scheduler_interface> * _S_scheduler_address;
    ::std::call_once(_Flag, [] {
        _S_scheduler_address = _GetStaticAmbientSchedulerStorage();
    });
    return *_S_scheduler_address;
}

} 

inline const ::std::shared_ptr<scheduler_interface> &get_ambient_scheduler()
{
    return details::_GetStaticAmbientSchedulerRef();
}

inline void set_ambient_scheduler(const ::std::shared_ptr<scheduler_interface>& _Scheduler)
{
    details::_GetStaticAmbientSchedulerRef() = _Scheduler;
}

namespace details
{
    
     void __cdecl _ReportUnobservedException();

    namespace platform
    {
         unsigned int __cdecl GetNextAsyncId();
         size_t __cdecl CaptureCallstack(void **, size_t, size_t);
         long __cdecl GetCurrentThreadId();
    }
}

} 

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h"

























#pragma once












#pragma pack(push,8)




namespace Concurrency
{

namespace details
{

    
    class _RefCounter
    {
    public:

        virtual ~_RefCounter()
        {
            (void)( (!!((_M_refCount == 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 57, 0, L"%ls", L"_M_refCount == 0")) || (__debugbreak(), 0) );
        }

        
        
        long _Reference()
        {
            const long _Refcount = _InterlockedIncrement(&_M_refCount);

            
            (void)( (!!((_Refcount > 1))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 67, 0, L"%ls", L"_Refcount > 1")) || (__debugbreak(), 0) );
            return _Refcount;
        }

        
        
        long _Release()
        {
            const long _Refcount = _InterlockedDecrement(&_M_refCount);
            (void)( (!!((_Refcount >= 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 76, 0, L"%ls", L"_Refcount >= 0")) || (__debugbreak(), 0) );

            if (_Refcount == 0)
            {
                _Destroy();
            }

            return _Refcount;
        }

    protected:

        
        virtual void _Destroy()
        {
            delete this;
        }

        
        _RefCounter(long _InitialCount = 1) : _M_refCount(_InitialCount)
        {
            (void)( (!!((_M_refCount > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 97, 0, L"%ls", L"_M_refCount > 0")) || (__debugbreak(), 0) );
        }

        
        volatile long _M_refCount;
    };

    class _CancellationTokenState;

    class _CancellationTokenRegistration : public _RefCounter
    {
    private:

        static const long _STATE_CLEAR = 0;
        static const long _STATE_DEFER_DELETE = 1;
        static const long _STATE_SYNCHRONIZE = 2;
        static const long _STATE_CALLED = 3;

    public:

        _CancellationTokenRegistration(long _InitialRefs = 1) :
            _RefCounter(_InitialRefs),
            _M_state(_STATE_CALLED),
            _M_signaled(false),
            _M_pTokenState(nullptr)
        {
        }

        _CancellationTokenState *_GetToken() const
        {
            return _M_pTokenState;
        }

    protected:

        virtual ~_CancellationTokenRegistration()
        {
            (void)( (!!((_M_state != _STATE_CLEAR))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 134, 0, L"%ls", L"_M_state != _STATE_CLEAR")) || (__debugbreak(), 0) );
        }

        virtual void _Exec() = 0;

    private:

        friend class _CancellationTokenState;

        void _Invoke()
        {
            const long _Tid = ::Concurrency::details::platform::GetCurrentThreadId();
            (void)( (!!(((_Tid & 0x3) == 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 146, 0, L"%ls", L"(_Tid & 0x3) == 0")) || (__debugbreak(), 0) ); 

            long _Result = atomic_compare_exchange(_M_state, _Tid, _STATE_CLEAR);

            if (_Result == _STATE_CLEAR)
            {
                _Exec();

                _Result = atomic_compare_exchange(_M_state, _STATE_CALLED, _Tid);

                if (_Result == _STATE_SYNCHRONIZE)
                {
                    {
                        ::std::lock_guard<::std::mutex> _Lock(_M_Mutex);
                        _M_signaled = true;
                    }
                    _M_CondVar.notify_all();
                }
            }
            _Release();
        }

        atomic_long               _M_state;
        ::std::condition_variable _M_CondVar;
        ::std::mutex              _M_Mutex;
        bool                      _M_signaled;
        _CancellationTokenState * _M_pTokenState;
    };

    template<typename _Function>
    class _CancellationTokenCallback : public _CancellationTokenRegistration
    {
    public:

        _CancellationTokenCallback(const _Function& _Func) :
            _M_function(_Func)
        {
        }

    protected:

        virtual void _Exec() override
        {
            _M_function();
        }

    private:

        _Function _M_function;
    };

    class CancellationTokenRegistration_TaskProc : public _CancellationTokenRegistration
    {
    public:

        CancellationTokenRegistration_TaskProc(TaskProc_t _Proc,   void *_PData, int _InitialRefs) :
            _CancellationTokenRegistration(_InitialRefs), _M_proc(_Proc), _M_pData(_PData)
        {
        }

    protected:

        virtual void _Exec() override
        {
            _M_proc(_M_pData);
        }

    private:

        TaskProc_t _M_proc;
        void *_M_pData;

    };

    
    class _CancellationTokenState : public _RefCounter
    {
    protected:
        class TokenRegistrationContainer
        {
        private:
            typedef struct _Node {
                _CancellationTokenRegistration* _M_token;
                _Node *_M_next;

                _Node(_CancellationTokenRegistration* _Token) : _M_token(_Token), _M_next(nullptr)
                {
                }
            } Node;

        public:
            TokenRegistrationContainer() : _M_begin(nullptr), _M_last(nullptr)
            {
            }

            ~TokenRegistrationContainer()
            {
                auto _Node = _M_begin;
                while (_Node != nullptr)
                {
                    Node* _Tmp = _Node;
                    _Node = _Node->_M_next;
                    delete _Tmp;
                }
            }

            void swap(TokenRegistrationContainer& _List)
            {
                ::std::swap(_List._M_begin, _M_begin);
                ::std::swap(_List._M_last, _M_last);
            }

            bool empty()
            {
                return _M_begin == nullptr;
            }

            template<typename _Ty>
            void for_each(_Ty _Lambda)
            {
                Node* _Node = _M_begin;

                while (_Node != nullptr)
                {
                    _Lambda(_Node->_M_token);
                    _Node = _Node->_M_next;
                }
            }

            void push_back(_CancellationTokenRegistration* _Token)
            {
                auto _Node = new Node(_Token);
                if (_M_begin == nullptr)
                {
                    _M_begin = _Node;
                }
                else
                {
                    _M_last->_M_next = _Node;
                }

                _M_last = _Node;
            }

            void remove(_CancellationTokenRegistration* _Token)
            {
                Node* _Node = _M_begin;
                Node* _Prev = nullptr;

                while (_Node != nullptr)
                {
                    if (_Node->_M_token == _Token) {
                        if (_Prev == nullptr)
                        {
                            _M_begin = _Node->_M_next;
                        }
                        else
                        {
                            _Prev->_M_next = _Node->_M_next;
                        }

                        if (_Node->_M_next == nullptr)
                        {
                            _M_last = _Prev;
                        }

                        delete _Node;
                        break;
                    }

                    _Prev = _Node;
                    _Node = _Node->_M_next;
                }
            }

        private:
            Node *_M_begin;
            Node *_M_last;
        };

    public:
        static _CancellationTokenState * _NewTokenState()
        {
            return new _CancellationTokenState();
        }

        static _CancellationTokenState *_None()
        {
            return reinterpret_cast<_CancellationTokenState *>(2);
        }

        static bool _IsValid(  _CancellationTokenState *_PToken)
        {
            return (_PToken != nullptr && _PToken != _None());
        }

        _CancellationTokenState() :
            _M_stateFlag(0)
        {
        }

        ~_CancellationTokenState()
        {
            TokenRegistrationContainer _RundownList;
            {
                ::std::lock_guard<::std::mutex> _Lock(_M_listLock);
                _M_registrations.swap(_RundownList);
            }

            _RundownList.for_each([](_CancellationTokenRegistration * _PRegistration)
            {
                _PRegistration->_M_state = _CancellationTokenRegistration::_STATE_SYNCHRONIZE;
                _PRegistration->_Release();
            });
        }

        bool _IsCanceled() const
        {
            return (_M_stateFlag != 0);
        }

        void _Cancel()
        {
            if (atomic_compare_exchange(_M_stateFlag, 1l, 0l) == 0)
            {
                TokenRegistrationContainer _RundownList;
                {
                    ::std::lock_guard<::std::mutex> _Lock(_M_listLock);
                    _M_registrations.swap(_RundownList);
                }

                _RundownList.for_each([](_CancellationTokenRegistration * _PRegistration)
                {
                    _PRegistration->_Invoke();
                });

                _M_stateFlag = 2;
            }
        }

        _CancellationTokenRegistration *_RegisterCallback(TaskProc_t _PCallback,   void *_PData, int _InitialRefs = 1)
        {
            _CancellationTokenRegistration *_PRegistration = new CancellationTokenRegistration_TaskProc(_PCallback, _PData, _InitialRefs);
            _RegisterCallback(_PRegistration);
            return _PRegistration;
        }

        void _RegisterCallback(  _CancellationTokenRegistration *_PRegistration)
        {
            _PRegistration->_M_state = _CancellationTokenRegistration::_STATE_CLEAR;
            _PRegistration->_Reference();
            _PRegistration->_M_pTokenState = this;

            bool _Invoke = true;

            if (!_IsCanceled())
            {
                ::std::lock_guard<::std::mutex> _Lock(_M_listLock);

                if (!_IsCanceled())
                {
                    _Invoke = false;
                    _M_registrations.push_back(_PRegistration);
                }
            }

            if (_Invoke)
            {
                _PRegistration->_Invoke();
            }
        }

        void _DeregisterCallback(  _CancellationTokenRegistration *_PRegistration)
        {
            bool _Synchronize = false;

            {
                ::std::lock_guard<::std::mutex> _Lock(_M_listLock);

                
                
                
                
                
                if (!_M_registrations.empty())
                {
                    _M_registrations.remove(_PRegistration);
                    _PRegistration->_M_state = _CancellationTokenRegistration::_STATE_SYNCHRONIZE;
                    _PRegistration->_Release();
                }
                else
                {
                    _Synchronize = true;
                }
            }

            
            
            
            
            
            
            
            
            if (_Synchronize)
            {
                const long _Result = atomic_compare_exchange(
                    _PRegistration->_M_state,
                    _CancellationTokenRegistration::_STATE_DEFER_DELETE,
                    _CancellationTokenRegistration::_STATE_CLEAR
                    );

                switch(_Result)
                {
                    case _CancellationTokenRegistration::_STATE_CLEAR:
                    case _CancellationTokenRegistration::_STATE_CALLED:
                        break;
                    case _CancellationTokenRegistration::_STATE_DEFER_DELETE:
                    case _CancellationTokenRegistration::_STATE_SYNCHRONIZE:
                        (void)( (!!((false))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 465, 0, L"%ls", L"false")) || (__debugbreak(), 0) );
                        break;
                    default:
                    {
                        if (_Result == ::Concurrency::details::platform::GetCurrentThreadId())
                        {
                            
                            
                            
                            
                            
                            break;
                        }

                        const long _Result_1 = atomic_exchange(_PRegistration->_M_state, _CancellationTokenRegistration::_STATE_SYNCHRONIZE);

                        if (_Result_1 != _CancellationTokenRegistration::_STATE_CALLED)
                        {
                            ::std::unique_lock<::std::mutex> _Lock(_PRegistration->_M_Mutex);
                            _PRegistration->_M_CondVar.wait(_Lock,
                                [_PRegistration]{ return _PRegistration->_M_signaled; });

                            (void)( (!!((_PRegistration->_M_signaled))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h", 487, 0, L"%ls", L"_PRegistration->_M_signaled")) || (__debugbreak(), 0) );
                        }

                        break;
                    }
                }
            }
        }

    private:

        
        atomic_long _M_stateFlag;

        
        ::std::mutex _M_listLock;

        
        TokenRegistrationContainer _M_registrations;
    };

} 

class cancellation_token_source;
class cancellation_token;








class cancellation_token_registration
{
public:

    cancellation_token_registration() :
        _M_pRegistration(nullptr)
    {
    }

    ~cancellation_token_registration()
    {
        _Clear();
    }

    cancellation_token_registration(const cancellation_token_registration& _Src)
    {
        _Assign(_Src._M_pRegistration);
    }

    cancellation_token_registration(cancellation_token_registration&& _Src)
    {
        _Move(_Src._M_pRegistration);
    }

    cancellation_token_registration& operator=(const cancellation_token_registration& _Src)
    {
        if (this != &_Src)
        {
            _Clear();
            _Assign(_Src._M_pRegistration);
        }
        return *this;
    }

    cancellation_token_registration& operator=(cancellation_token_registration&& _Src)
    {
        if (this != &_Src)
        {
            _Clear();
            _Move(_Src._M_pRegistration);
        }
        return *this;
    }

    bool operator==(const cancellation_token_registration& _Rhs) const
    {
        return _M_pRegistration == _Rhs._M_pRegistration;
    }

    bool operator!=(const cancellation_token_registration& _Rhs) const
    {
        return !(operator==(_Rhs));
    }

private:

    friend class cancellation_token;

    cancellation_token_registration(  details::_CancellationTokenRegistration *_PRegistration) :
        _M_pRegistration(_PRegistration)
    {
    }

    void _Clear()
    {
        if (_M_pRegistration != nullptr)
        {
            _M_pRegistration->_Release();
        }
        _M_pRegistration = nullptr;
    }

    void _Assign(  details::_CancellationTokenRegistration *_PRegistration)
    {
        if (_PRegistration != nullptr)
        {
            _PRegistration->_Reference();
        }
        _M_pRegistration = _PRegistration;
    }

    void _Move(  details::_CancellationTokenRegistration *&_PRegistration)
    {
        _M_pRegistration = _PRegistration;
        _PRegistration = nullptr;
    }

    details::_CancellationTokenRegistration *_M_pRegistration;
};







class cancellation_token
{
public:

    typedef details::_CancellationTokenState * _ImplType;

    
    
    
    
    
    
    static cancellation_token none()
    {
        return cancellation_token();
    }

    cancellation_token(const cancellation_token& _Src)
    {
        _Assign(_Src._M_Impl);
    }

    cancellation_token(cancellation_token&& _Src)
    {
        _Move(_Src._M_Impl);
    }

    cancellation_token& operator=(const cancellation_token& _Src)
    {
        if (this != &_Src)
        {
            _Clear();
            _Assign(_Src._M_Impl);
        }
        return *this;
    }

    cancellation_token& operator=(cancellation_token&& _Src)
    {
        if (this != &_Src)
        {
            _Clear();
            _Move(_Src._M_Impl);
        }
        return *this;
    }

    bool operator==(const cancellation_token& _Src) const
    {
        return _M_Impl == _Src._M_Impl;
    }

    bool operator!=(const cancellation_token& _Src) const
    {
        return !(operator==(_Src));
    }

    ~cancellation_token()
    {
        _Clear();
    }

    
    
    
    
    
    
    bool is_cancelable() const
    {
        return (_M_Impl != nullptr);
    }

    
    
    
    
    
    
    bool is_canceled() const
    {
        return (_M_Impl != nullptr && _M_Impl->_IsCanceled());
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Function>
    ::Concurrency::cancellation_token_registration register_callback(const _Function& _Func) const
    {
        if (_M_Impl == nullptr)
        {
            
            throw invalid_operation();
        }
#pragma warning(suppress: 28197)
        details::_CancellationTokenCallback<_Function> *_PCallback = new details::_CancellationTokenCallback<_Function>(_Func);
        _M_Impl->_RegisterCallback(_PCallback);
        return cancellation_token_registration(_PCallback);
    }

    
    
    
    
    
    
    
    
    void deregister_callback(const cancellation_token_registration& _Registration) const
    {
        _M_Impl->_DeregisterCallback(_Registration._M_pRegistration);
    }

    _ImplType _GetImpl() const
    {
        return _M_Impl;
    }

    _ImplType _GetImplValue() const
    {
        return (_M_Impl == nullptr) ? ::Concurrency::details::_CancellationTokenState::_None() : _M_Impl;
    }

    static cancellation_token _FromImpl(_ImplType _Impl)
    {
        return cancellation_token(_Impl);
    }

private:

    friend class cancellation_token_source;

    _ImplType _M_Impl;

    void _Clear()
    {
        if (_M_Impl != nullptr)
        {
            _M_Impl->_Release();
        }
        _M_Impl = nullptr;
    }

    void _Assign(_ImplType _Impl)
    {
        if (_Impl != nullptr)
        {
            _Impl->_Reference();
        }
        _M_Impl = _Impl;
    }

    void _Move(_ImplType &_Impl)
    {
        _M_Impl = _Impl;
        _Impl = nullptr;
    }

    cancellation_token() :
        _M_Impl(nullptr)
    {
    }

    cancellation_token(_ImplType _Impl) :
        _M_Impl(_Impl)
    {
        if (_M_Impl == ::Concurrency::details::_CancellationTokenState::_None())
        {
            _M_Impl = nullptr;
        }

        if (_M_Impl != nullptr)
        {
            _M_Impl->_Reference();
        }
    }
};




class cancellation_token_source
{
public:

    typedef ::Concurrency::details::_CancellationTokenState * _ImplType;

    
    
    
    cancellation_token_source()
    {
        _M_Impl = new ::Concurrency::details::_CancellationTokenState;
    }

    cancellation_token_source(const cancellation_token_source& _Src)
    {
        _Assign(_Src._M_Impl);
    }

    cancellation_token_source(cancellation_token_source&& _Src)
    {
        _Move(_Src._M_Impl);
    }

    cancellation_token_source& operator=(const cancellation_token_source& _Src)
    {
        if (this != &_Src)
        {
            _Clear();
            _Assign(_Src._M_Impl);
        }
        return *this;
    }

    cancellation_token_source& operator=(cancellation_token_source&& _Src)
    {
        if (this != &_Src)
        {
            _Clear();
            _Move(_Src._M_Impl);
        }
        return *this;
    }

    bool operator==(const cancellation_token_source& _Src) const
    {
        return _M_Impl == _Src._M_Impl;
    }

    bool operator!=(const cancellation_token_source& _Src) const
    {
        return !(operator==(_Src));
    }

    ~cancellation_token_source()
    {
        if (_M_Impl != nullptr)
        {
            _M_Impl->_Release();
        }
    }

    
    
    
    
    
    
    
    cancellation_token get_token() const
    {
        return cancellation_token(_M_Impl);
    }

    
    
    
    
    
    
    
    
    
    
    static cancellation_token_source create_linked_source(cancellation_token& _Src)
    {
        cancellation_token_source _NewSource;
        _Src.register_callback( [_NewSource](){ _NewSource.cancel(); } );
        return _NewSource;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Iter>
    static cancellation_token_source create_linked_source(_Iter _Begin, _Iter _End)
    {
        cancellation_token_source _NewSource;
        for (_Iter _It = _Begin; _It != _End; ++_It)
        {
            _It->register_callback( [_NewSource](){ _NewSource.cancel(); } );
        }
        return _NewSource;
    }

    
    
    
    
    void cancel() const
    {
        _M_Impl->_Cancel();
    }

    _ImplType _GetImpl() const
    {
        return _M_Impl;
    }

    static cancellation_token_source _FromImpl(_ImplType _Impl)
    {
        return cancellation_token_source(_Impl);
    }

private:

    _ImplType _M_Impl;

    void _Clear()
    {
        if (_M_Impl != nullptr)
        {
            _M_Impl->_Release();
        }
        _M_Impl = nullptr;
    }

    void _Assign(_ImplType _Impl)
    {
        if (_Impl != nullptr)
        {
            _Impl->_Reference();
        }
        _M_Impl = _Impl;
    }

    void _Move(_ImplType &_Impl)
    {
        _M_Impl = _Impl;
        _Impl = nullptr;
    }

    cancellation_token_source(_ImplType _Impl) :
        _M_Impl(_Impl)
    {
        if (_M_Impl == ::Concurrency::details::_CancellationTokenState::_None())
        {
            _M_Impl = nullptr;
        }

        if (_M_Impl != nullptr)
        {
            _M_Impl->_Reference();
        }
    }
};

} 


#pragma pack(pop)

#line 995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplcancellation_token.h"
#pragma external_header(pop)
#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplwin.h"

namespace Concurrency
{

namespace details
{











#line 144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplwin.h"

    struct _TaskProcHandle
    {
        _TaskProcHandle() {}
        virtual ~_TaskProcHandle() {}
        virtual void invoke() const = 0;

        void operator()() const
        {
            this->invoke();
        }

        static void __cdecl _RunChoreBridge(void * _Parameter)
        {
            ::std::unique_ptr<_TaskProcHandle> {static_cast<_TaskProcHandle *>(_Parameter)}->invoke();
        }
    };

    class _TaskCollectionBaseImpl
    {
    protected:
        enum _TaskCollectionState {
            _New,
            _Scheduled,
            _Completed
        };

        void _SetCollectionState(_TaskCollectionState _NewState)
        {
            (void)( (!!((_NewState != _New))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplwin.h", 173, 0, L"%ls", L"_NewState != _New")) || (__debugbreak(), 0) );
            ::std::lock_guard<::std::mutex> _Lock(_M_Cs);
            if (_M_State < _NewState)
            {
                _M_State = _NewState;
            }

            _M_StateChanged.notify_all();
        }

        void WaitUntilStateChangedTo(_TaskCollectionState _State)
        {
            ::std::unique_lock<::std::mutex> _Lock(_M_Cs);

            while(_M_State < _State)
            {
                _M_StateChanged.wait(_Lock);
            }
        }
    public:

        typedef _TaskProcHandle _TaskProcHandle_t;

        _TaskCollectionBaseImpl(::Concurrency::scheduler_ptr _PScheduler)
            : _M_pScheduler(_PScheduler), _M_State(_New)
        {
        }

        void _ScheduleTask(_TaskProcHandle_t* _Parameter, _TaskInliningMode _InliningMode)
        {
            if (_InliningMode == _ForceInline)
            {
                _TaskProcHandle_t::_RunChoreBridge(_Parameter);
            }
            else
            {
                if (_M_pScheduler)
                {
                    _M_pScheduler->schedule(_TaskProcHandle_t::_RunChoreBridge, _Parameter);
                }
                else
                {
                    _DefaultPPLTaskScheduler().schedule(_TaskProcHandle_t::_RunChoreBridge, _Parameter);
                }
            }
        }

        void _Cancel()
        {
            
        }

        void _RunAndWait()
        {
            _Wait();
        }

        void _Wait()
        {
            WaitUntilStateChangedTo(_Completed);
        }

        void _Complete()
        {
            
            _SetCollectionState(_Completed);
        }

        ::Concurrency::scheduler_ptr _GetScheduler() const
        {
            return _M_pScheduler;
        }

        
        static void _RunTask(TaskProc_t _Proc, void * _Parameter, _TaskInliningMode _InliningMode)
        {
            if (_InliningMode == _ForceInline)
            {
                _Proc(_Parameter);
            }
            else
            {
                
                auto _Ptr = get_ambient_scheduler();
                if (_Ptr)
                {
                    _Ptr->schedule(_Proc, _Parameter);
                }
                else
                {
                    _DefaultPPLTaskScheduler().schedule(_Proc, _Parameter);
                }
            }
        }
    protected:
        ::std::condition_variable _M_StateChanged;
        ::std::mutex _M_Cs;
        ::Concurrency::scheduler_ptr _M_pScheduler;
        _TaskCollectionState _M_State;
    };

    typedef _TaskCollectionBaseImpl _TaskCollection_t;

    
    struct _Task_generator_oversubscriber {};

    typedef _TaskInliningMode _TaskInliningMode_t;
    typedef _Task_generator_oversubscriber _Task_generator_oversubscriber_t;

} 
} 

namespace concurrency = ::Concurrency;


#pragma warning(pop)
#pragma pack(pop)
#line 291 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\pplwin.h"
#pragma external_header(pop)
#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h"



#pragma pack(push,8)












namespace Concurrency
{
namespace details
{
    __declspec(dllimport) size_t __cdecl _GetCombinableSize();
} 

class structured_task_group;
class task_group;






























template<typename _Function>
class task_handle : public ::Concurrency::details::_UnrealizedChore
{
public:
    
    
    
    
    
    
    
    
    
    
    
    
    
    task_handle(const _Function& _Func) : _M_function(_Func)
    {
        m_pFunction = reinterpret_cast <TaskProc> (&::Concurrency::details::_UnrealizedChore::_InvokeBridge<task_handle>);
    }

    
    
    
    
    ~task_handle()
    {
        
        
        
        
        if (_OwningCollection() != nullptr && !_GetRuntimeOwnsLifetime())
        {
            _CheckTaskCollection();
        }
    }

    
    
    
    
    void operator()() const
    {
        _M_function();
    }

private:

    friend class task_group;
    friend class structured_task_group;

    
    _Function _M_function;

    task_handle const & operator=(task_handle const&);    

};






















template <class _Function>
task_handle<_Function> make_task(const _Function& _Func)
{
    return task_handle<_Function>(_Func);
}




































class structured_task_group
{
public:

    
    
    
    
    
    
    
    
    
    
    structured_task_group()
    {
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    structured_task_group(cancellation_token _CancellationToken) :
        _M_task_collection(_CancellationToken._GetImpl() != nullptr ? _CancellationToken._GetImpl() : ::Concurrency::details::_CancellationTokenState::_None())
    {
    }

    
    
    
    
    
    
    
    
    
    
    
    ~structured_task_group()
    {
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<class _Function>
    void run(task_handle<_Function>& _Task_handle)
    {
        _Task_handle._SetRuntimeOwnsLifetime(false);
        _M_task_collection._Schedule(&_Task_handle);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<class _Function>
    void run(task_handle<_Function>& _Task_handle, location& _Placement)
    {
        _Task_handle._SetRuntimeOwnsLifetime(false);
        _M_task_collection._Schedule(&_Task_handle, &_Placement);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    task_group_status wait()
    {
        
        
        
        return (task_group_status)_M_task_collection._Wait();
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<class _Function>
    task_group_status run_and_wait(task_handle<_Function>& _Task_handle)
    {
        
        
        
        return (task_group_status)_M_task_collection._RunAndWait(&_Task_handle);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<class _Function>
    task_group_status run_and_wait(const _Function& _Func)
    {
        
        
        
        task_handle<_Function> _Task(_Func);
        return (task_group_status)_M_task_collection._RunAndWait(&_Task);
    }

    
    
    
    
    
    
    
    
    void cancel()
    {
        _M_task_collection._Cancel();
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    bool is_canceling()
    {
        return _M_task_collection._IsCanceling();
    }

private:

    
    template<class _Function> void run(task_handle<_Function>&& _Task_handle);

    
    ::Concurrency::details::_StructuredTaskCollection _M_task_collection;
};














class task_group
{
public:

    
    
    
    
    
    
    
    
    
    
    task_group()
    {
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    task_group(cancellation_token _CancellationToken) :
        _M_task_collection(_CancellationToken._GetImpl() != nullptr ? _CancellationToken._GetImpl() : ::Concurrency::details::_CancellationTokenState::_None())
    {
    }

    
    
    
    
    
    
    
    
    
    
    
    ~task_group()
    {
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Function>
    void run(const _Function& _Func)
    {
        _M_task_collection._Schedule(::Concurrency::details::_UnrealizedChore::_InternalAlloc<task_handle<_Function>, _Function>(_Func));
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Function>
    void run(const _Function& _Func, location& _Placement)
    {
        _M_task_collection._Schedule(::Concurrency::details::_UnrealizedChore::_InternalAlloc<task_handle<_Function>, _Function>(_Func), &_Placement);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Function>
    void run(task_handle<_Function>& _Task_handle)
    {
        _Task_handle._SetRuntimeOwnsLifetime(false);
        _M_task_collection._Schedule(&_Task_handle);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Function>
    void run(task_handle<_Function>& _Task_handle, location& _Placement)
    {
        _Task_handle._SetRuntimeOwnsLifetime(false);
        _M_task_collection._Schedule(&_Task_handle, &_Placement);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    task_group_status wait()
    {
        
        
        
        return static_cast<task_group_status>(_M_task_collection._Wait());
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<class _Function>
    task_group_status run_and_wait(task_handle<_Function>& _Task_handle)
    {
        
        
        
        _Task_handle._SetRuntimeOwnsLifetime(false);
        return (task_group_status)_M_task_collection._RunAndWait(&_Task_handle);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<class _Function>
    task_group_status run_and_wait(const _Function& _Func)
    {
        
        
        
        return (task_group_status)_M_task_collection._RunAndWait(::Concurrency::details::_UnrealizedChore::_InternalAlloc<task_handle<_Function>, _Function>(_Func));
    }

    
    
    
    
    
    
    
    
    void cancel()
    {
        _M_task_collection._Cancel();
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    bool is_canceling()
    {
        return _M_task_collection._IsCanceling();
    }

private:

    
    template<class _Function> void run(task_handle<_Function>&& _Task_handle);

    
    ::Concurrency::details::_TaskCollection _M_task_collection;
};




















template<typename _Function>
void run_with_cancellation_token(const _Function& _Func, cancellation_token _Ct)
{
    structured_task_group _Stg(_Ct);
    _Stg.run_and_wait(_Func);
}










inline void interruption_point()
{
    structured_task_group _Stg;
    _Stg.wait();
}















__declspec(dllimport) bool __cdecl is_current_task_group_canceling();






template <typename _Function1, typename _Function2>
void _Parallel_invoke_impl(const _Function1& _Func1, const _Function2& _Func2)
{
    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    
    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run_and_wait(_Task_handle2);
}

























template <typename _Function1, typename _Function2>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    _Parallel_invoke_impl(_Func1, _Func2);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}































template <typename _Function1, typename _Function2, typename _Function3>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run_and_wait(_Task_handle3);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}





































template <typename _Function1, typename _Function2, typename _Function3, typename _Function4>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3, const _Function4& _Func4)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run(_Task_handle3);

    task_handle<_Function4> _Task_handle4(_Func4);
    _Task_group.run_and_wait(_Task_handle4);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}











































template <typename _Function1, typename _Function2, typename _Function3, typename _Function4, typename _Function5>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3, const _Function4& _Func4, const _Function5& _Func5)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run(_Task_handle3);

    task_handle<_Function4> _Task_handle4(_Func4);
    _Task_group.run(_Task_handle4);

    task_handle<_Function5> _Task_handle5(_Func5);
    _Task_group.run_and_wait(_Task_handle5);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}

















































template <typename _Function1, typename _Function2, typename _Function3, typename _Function4, typename _Function5,
    typename _Function6>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3, const _Function4& _Func4, const _Function5& _Func5,
    const _Function6& _Func6)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run(_Task_handle3);

    task_handle<_Function4> _Task_handle4(_Func4);
    _Task_group.run(_Task_handle4);

    task_handle<_Function5> _Task_handle5(_Func5);
    _Task_group.run(_Task_handle5);

    task_handle<_Function6> _Task_handle6(_Func6);
    _Task_group.run_and_wait(_Task_handle6);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}























































template <typename _Function1, typename _Function2, typename _Function3, typename _Function4, typename _Function5,
    typename _Function6, typename _Function7>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3, const _Function4& _Func4, const _Function5& _Func5,
    const _Function6& _Func6, const _Function7& _Func7)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run(_Task_handle3);

    task_handle<_Function4> _Task_handle4(_Func4);
    _Task_group.run(_Task_handle4);

    task_handle<_Function5> _Task_handle5(_Func5);
    _Task_group.run(_Task_handle5);

    task_handle<_Function6> _Task_handle6(_Func6);
    _Task_group.run(_Task_handle6);

    task_handle<_Function7> _Task_handle7(_Func7);
    _Task_group.run_and_wait(_Task_handle7);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}





























































template <typename _Function1, typename _Function2, typename _Function3, typename _Function4, typename _Function5,
    typename _Function6, typename _Function7, typename _Function8>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3, const _Function4& _Func4, const _Function5& _Func5,
    const _Function6& _Func6, const _Function7& _Func7, const _Function8& _Func8)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run(_Task_handle3);

    task_handle<_Function4> _Task_handle4(_Func4);
    _Task_group.run(_Task_handle4);

    task_handle<_Function5> _Task_handle5(_Func5);
    _Task_group.run(_Task_handle5);

    task_handle<_Function6> _Task_handle6(_Func6);
    _Task_group.run(_Task_handle6);

    task_handle<_Function7> _Task_handle7(_Func7);
    _Task_group.run(_Task_handle7);

    task_handle<_Function8> _Task_handle8(_Func8);
    _Task_group.run_and_wait(_Task_handle8);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}



































































template <typename _Function1, typename _Function2, typename _Function3, typename _Function4, typename _Function5,
    typename _Function6, typename _Function7, typename _Function8, typename _Function9>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3, const _Function4& _Func4, const _Function5& _Func5,
    const _Function6& _Func6, const _Function7& _Func7, const _Function8& _Func8, const _Function9& _Func9)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run(_Task_handle3);

    task_handle<_Function4> _Task_handle4(_Func4);
    _Task_group.run(_Task_handle4);

    task_handle<_Function5> _Task_handle5(_Func5);
    _Task_group.run(_Task_handle5);

    task_handle<_Function6> _Task_handle6(_Func6);
    _Task_group.run(_Task_handle6);

    task_handle<_Function7> _Task_handle7(_Func7);
    _Task_group.run(_Task_handle7);

    task_handle<_Function8> _Task_handle8(_Func8);
    _Task_group.run(_Task_handle8);

    task_handle<_Function9> _Task_handle9(_Func9);
    _Task_group.run_and_wait(_Task_handle9);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}









































































template <typename _Function1, typename _Function2, typename _Function3, typename _Function4, typename _Function5,
    typename _Function6, typename _Function7, typename _Function8, typename _Function9, typename _Function10>
void parallel_invoke(const _Function1& _Func1, const _Function2& _Func2, const _Function3& _Func3, const _Function4& _Func4, const _Function5& _Func5,
    const _Function6& _Func6, const _Function7& _Func7, const _Function8& _Func8, const _Function9& _Func9, const _Function10& _Func10)
{
    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_START);

    structured_task_group _Task_group;

    task_handle<_Function1> _Task_handle1(_Func1);
    _Task_group.run(_Task_handle1);

    task_handle<_Function2> _Task_handle2(_Func2);
    _Task_group.run(_Task_handle2);

    task_handle<_Function3> _Task_handle3(_Func3);
    _Task_group.run(_Task_handle3);

    task_handle<_Function4> _Task_handle4(_Func4);
    _Task_group.run(_Task_handle4);

    task_handle<_Function5> _Task_handle5(_Func5);
    _Task_group.run(_Task_handle5);

    task_handle<_Function6> _Task_handle6(_Func6);
    _Task_group.run(_Task_handle6);

    task_handle<_Function7> _Task_handle7(_Func7);
    _Task_group.run(_Task_handle7);

    task_handle<_Function8> _Task_handle8(_Func8);
    _Task_group.run(_Task_handle8);

    task_handle<_Function9> _Task_handle9(_Func9);
    _Task_group.run(_Task_handle9);

    task_handle<_Function10> _Task_handle10(_Func10);
    _Task_group.run_and_wait(_Task_handle10);

    _Trace_ppl_function(PPLParallelInvokeEventGuid, 4, CONCRT_EVENT_END);
}







class auto_partitioner
{
public:
    
    
    
    
    auto_partitioner() {}

    
    
    
    
    ~auto_partitioner() {}

    template<class _Type>
    _Type _Get_num_chunks(_Type ) const
    {
        return static_cast<_Type>(::Concurrency::details::_CurrentScheduler::_GetNumberOfVirtualProcessors());
    }
};






class static_partitioner
{
public:
    
    
    
    
    static_partitioner() = default;

    
    
    
    
    ~static_partitioner() = default;

    template<class _Type>
    _Type _Get_num_chunks(_Type ) const
    {
        return static_cast<_Type>(::Concurrency::details::_CurrentScheduler::_GetNumberOfVirtualProcessors());
    }
};






class simple_partitioner
{
private:
    typedef unsigned long long _Size_type;

public:
    
    
    
    
    
    
    
    explicit simple_partitioner(_Size_type _Chunk_size) : _M_chunk_size(_Chunk_size)
    {
        if (_Chunk_size == 0)
        {
            throw ::std::invalid_argument("_Chunk_size");
        }
    }

    
    
    
    
    ~simple_partitioner() {}

    template<class _Type>
    _Type _Get_num_chunks(_Type _Range_arg) const
    {
        static_assert(sizeof(_Type) <= sizeof(_Size_type), "Potential truncation of _Range_arg");
        _Size_type _Num_chunks = (static_cast<_Size_type>(_Range_arg) / _M_chunk_size);

        if (_Num_chunks == 0)
        {
           _Num_chunks = 1;
        }

        return static_cast<_Type>(_Num_chunks);
    }

private:

    _Size_type _M_chunk_size;
};








class affinity_partitioner
{
public:

    
    
    
    
    affinity_partitioner() : _M_num_chunks(0), _M_pChunk_locations(nullptr)
    {
    }

    
    
    
    
    ~affinity_partitioner()
    {
        delete [] _M_pChunk_locations;
    }

    location& _Get_chunk_location(unsigned int _ChunkIndex)
    {
        return _M_pChunk_locations[_ChunkIndex];
    }

    template<class _Type>
    _Type _Get_num_chunks(_Type )
    {
        if (_M_num_chunks == 0)
        {
            _M_num_chunks = ::Concurrency::details::_CurrentScheduler::_GetNumberOfVirtualProcessors();
            _M_pChunk_locations = new location[_M_num_chunks];
        }

        return static_cast<_Type>(_M_num_chunks);
    }

private:
    
    unsigned int _M_num_chunks;

    
    location * _M_pChunk_locations;
};





#pragma warning(push)
#pragma warning(disable: 4180)

#pragma warning(disable: 6263)



template <typename _Random_iterator, typename _Index_type, typename _Function, bool _Is_iterator>
class _Parallel_chunk_helper_invoke
{
public:
    static void __cdecl _Invoke(const _Random_iterator& _First, _Index_type& _Index, const _Function& _Func)
    {
        _Func(_First[_Index]);
    }
};



template <typename _Random_iterator, typename _Index_type, typename _Function>
class _Parallel_chunk_helper_invoke<_Random_iterator, _Index_type, _Function, false>
{
public:
    static void __cdecl _Invoke(const _Random_iterator& _First, _Index_type& _Index, const _Function& _Func)
    {
        _Func(static_cast<_Random_iterator>(_First + _Index));
    }
};



template<typename _Index_type>
class _Range
{
public:

    
    _Range(_Index_type _Current_iteration, _Index_type _Last_iteration)
        : _M_current(_Current_iteration),
        _M_last(_Last_iteration)
    {
        
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_Number_of_iterations() > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1814, 0, L"%ls", L"_Number_of_iterations() > 0")) || (__debugbreak(), 0) ); __assume(_Number_of_iterations() > 0);} while(false);
    }

    
    void _Send_range(_Range<_Index_type> * _Helper_range)
    {
        
        
        
        _Index_type _Remaining_iterations = _Number_of_iterations();
        if (_Remaining_iterations > 1)
        {
            
            _M_last_iteration = _M_current_iteration + _Remaining_iterations / 2;

            
            __pragma(warning (suppress: 4127)) do {(void)( (!!((_Number_of_iterations() > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1830, 0, L"%ls", L"_Number_of_iterations() > 0")) || (__debugbreak(), 0) ); __assume(_Number_of_iterations() > 0);} while(false);
        }

        
        _Helper_range->_M_current_iteration = _M_last_iteration;
    }

    
    void _Steal_range(_Range<_Index_type>  * _Helper_range)
    {
        
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_Number_of_iterations() > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1841, 0, L"%ls", L"_Number_of_iterations() > 0")) || (__debugbreak(), 0) ); __assume(_Number_of_iterations() > 0);} while(false);

        _Index_type _Current_iter = _M_current_iteration;

        _Helper_range->_M_current_iteration = _Current_iter + 1;
        _Helper_range->_M_last_iteration = _M_last_iteration;

        _M_last_iteration = _Current_iter + 1;
    }

    
    _Index_type _Number_of_iterations() const
    {
        return (_M_last_iteration - _M_current_iteration);
    }

    
    _Index_type _Get_current_iteration() const
    {
        return _M_current;
    }

    
    void _Set_current_iteration(const _Index_type _I)
    {
        _M_current = _I;
    }

    __declspec(property(get=_Get_current_iteration, put=_Set_current_iteration)) _Index_type _M_current_iteration;

    
    _Index_type _Get_last_iteration() const
    {
        return _M_last;
    }

    
    void _Set_last_iteration(const _Index_type _I)
    {
        _M_last = _I;
    }

    __declspec(property(get=_Get_last_iteration, put=_Set_last_iteration)) _Index_type _M_last_iteration;

private:

    
    
    volatile _Index_type _M_current;
    volatile _Index_type _M_last;
};



template<typename _Index_type>
class _Worker_proxy
{
public:
    _Worker_proxy(_Worker_proxy *_PParent_worker = nullptr)
        : _M_pHelper_range(nullptr),
        _M_pParent_worker(_PParent_worker),
        _M_beacon(),
        _M_context(),
        _M_completion_count(0),
        _M_pWorker_range(nullptr),
        _M_stop_iterating(0)
    {
        _M_context = ::Concurrency::details::_Context::_CurrentContext();
    }

    ~_Worker_proxy()
    {
        
        if (_M_completion_count != _Tree_Complete)
        {
            
            _Propagate_cancel();

            
            _Set_done();
        }
    }

    
    bool _Receive_range(_Range<_Index_type> * _Helper_range)
    {
        
        if (_M_completion_count)
        {
            return false;
        }

        __pragma(warning (suppress: 4127)) do {(void)( (!!((_Helper_range != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1933, 0, L"%ls", L"_Helper_range != nullptr")) || (__debugbreak(), 0) ); __assume(_Helper_range != nullptr);} while(false);

        
        
        
        
        _Index_type _Cached_first_iteration = _Helper_range->_M_current_iteration;

        
        
        
        
        
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_pHelper_range == nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1946, 0, L"%ls", L"_M_pHelper_range == nullptr")) || (__debugbreak(), 0) ); __assume(_M_pHelper_range == nullptr);} while(false);
        _M_pHelper_range = _Helper_range;

        ::Concurrency::details::_SpinWaitBackoffNone spinWait(::Concurrency::details::_Context::_Yield);

        
        
        while ((_Helper_range->_M_current_iteration == _Cached_first_iteration) && !_M_completion_count)
        {
            if ((_M_pWorker_range != nullptr) && _M_context._IsSynchronouslyBlocked())
            {
                

                
                
                
                
                long _Stop_iterating = _InterlockedIncrement(&_M_stop_iterating);
                __pragma(warning (suppress: 4127)) do {(void)( (!!((_Stop_iterating > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1964, 0, L"%ls", L"_Stop_iterating > 0")) || (__debugbreak(), 0) ); __assume(_Stop_iterating > 0);} while(false);

                
                _Range<_Index_type> * _Worker_range = _M_pWorker_range;

                
                
                
                
                if ((_Worker_range != nullptr) && _M_context._IsSynchronouslyBlocked()
                    && (_Helper_range->_M_current_iteration == _Cached_first_iteration) && !_M_completion_count)
                {
                    __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_pHelper_range == _Helper_range))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1976, 0, L"%ls", L"_M_pHelper_range == _Helper_range")) || (__debugbreak(), 0) ); __assume(_M_pHelper_range == _Helper_range);} while(false);

                    _M_pHelper_range = nullptr;
                    _Worker_range->_Steal_range(_Helper_range);

                    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Helper_range->_M_current_iteration != _Cached_first_iteration))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1981, 0, L"%ls", L"_Helper_range->_M_current_iteration != _Cached_first_iteration")) || (__debugbreak(), 0) ); __assume(_Helper_range->_M_current_iteration != _Cached_first_iteration);} while(false);
                }

                
                
                
                
                _Stop_iterating = _InterlockedDecrement(&_M_stop_iterating);
                __pragma(warning (suppress: 4127)) do {(void)( (!!((_Stop_iterating >= 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 1989, 0, L"%ls", L"_Stop_iterating >= 0")) || (__debugbreak(), 0) ); __assume(_Stop_iterating >= 0);} while(false);
            }
            else
            {
                
                spinWait._SpinOnce();
            }
        }

        
        
        if (_Helper_range->_M_current_iteration == _Cached_first_iteration)
        {
            return false;
        }

        return (_Helper_range->_Number_of_iterations() > 0);
    }

    
    bool _Send_range(_Range<_Index_type> * _Worker_range)
    {
        
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_pWorker_range == nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2012, 0, L"%ls", L"_M_pWorker_range == nullptr")) || (__debugbreak(), 0) ); __assume(_M_pWorker_range == nullptr);} while(false);

        
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_M_pHelper_range != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2015, 0, L"%ls", L"_M_pHelper_range != nullptr")) || (__debugbreak(), 0) ); __assume(_M_pHelper_range != nullptr);} while(false);

        
        _Worker_range->_Send_range(_M_pHelper_range);

        
        _InterlockedExchangePointer(reinterpret_cast<void * volatile *>(&_M_pHelper_range), nullptr);

        
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_Worker_range->_Number_of_iterations() >= 1))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2024, 0, L"%ls", L"_Worker_range->_Number_of_iterations() >= 1")) || (__debugbreak(), 0) ); __assume(_Worker_range->_Number_of_iterations() >= 1);} while(false);

        
        return (_Worker_range->_Number_of_iterations() > 1);
    }

    
    
    void _Enable_intrusive_steal(_Range<_Index_type> * _Worker_range)
    {
        _M_pWorker_range = _Worker_range;
    }

    
    void _Disable_intrusive_steal()
    {
        _M_pWorker_range = nullptr;
        _Wait_on_intrusive_steal();
    }

    bool _Is_helper_registered()
    {
        return (_M_pHelper_range != nullptr);
    }

    bool _Is_done()
    {
        return (_M_completion_count != 0);
    }

    void _Set_done()
    {
        
        
        
        _InterlockedExchange(&_M_completion_count, 1);
    }

    void _Set_tree_done()
    {
        
        _M_completion_count = _Tree_Complete;
    }

    bool _Is_beacon_signaled()
    {
        return _M_beacon._Is_signaled();
    }

    bool _Verify_beacon_cancellation()
    {
        return _M_beacon._Confirm_cancel();
    }

private:

    
    void _Wait_on_intrusive_steal()
    {
        
        if (_M_stop_iterating != 0)
        {
            ::Concurrency::details::_SpinWaitBackoffNone spinWait;

            while (_M_stop_iterating != 0)
            {
                spinWait._SpinOnce();
            }
        }
    }

    void _NotifyCancel()
    {
        _M_beacon._Raise();
    }

    void _Propagate_cancel()
    {
        if (_M_pParent_worker != nullptr)
        {
            _M_pParent_worker->_NotifyCancel();
        }
    }

    
    static const long _Tree_Complete = 2;

    
    _Range<_Index_type> * volatile               _M_pHelper_range;

    
    _Worker_proxy *                              _M_pParent_worker;

    
    ::Concurrency::details::_Cancellation_beacon _M_beacon;
    ::Concurrency::details::_Context             _M_context;

    volatile long                                _M_completion_count;

    
    _Range<_Index_type> * volatile               _M_pWorker_range;
    volatile long                                _M_stop_iterating;

    _Worker_proxy const & operator=(_Worker_proxy const&);    

};









template <typename _Random_iterator, typename _Index_type, typename _Function, typename _Partitioner, bool _Is_iterator>
class _Parallel_chunk_helper
{
public:
    _Parallel_chunk_helper(_Index_type, const _Random_iterator& _First, _Index_type _First_iteration, _Index_type _Last_iteration, const _Index_type& _Step,
        const _Function& _Func, const _Partitioner&, _Worker_proxy<_Index_type> * const _Parent_data = nullptr)
            : _M_first(_First),
            _M_step(_Step),
            _M_function(_Func),
            _M_first_iteration(_First_iteration),
            _M_last_iteration(_Last_iteration),
            _M_parent_worker(_Parent_data)
    {
        
    }

        
    _Parallel_chunk_helper(const _Random_iterator& _First,  const _Index_type& _Step, const _Function& _Func,
        const _Range<_Index_type>& _Worker_range, _Worker_proxy<_Index_type> * const _Parent_data = nullptr)
            : _M_first(_First),
            _M_step(_Step),
            _M_function(_Func),
            _M_first_iteration(_Worker_range._M_current_iteration),
            _M_last_iteration(_Worker_range._M_last_iteration),
            _M_parent_worker(_Parent_data)
    {
        
    }

    
    
    
    
    
    void operator()() const
    {
        _Range<_Index_type> _Worker_range(_M_first_iteration, _M_last_iteration);

        
        
        
        
        if (_M_parent_worker != nullptr && !_M_parent_worker->_Receive_range(&_Worker_range))
        {
            
            return;
        }

        
        _Index_type _Current_iteration = _Worker_range._M_current_iteration;
        _Index_type _Scaled_index = _Current_iteration * _M_step;

        
        
        if (_Worker_range._Number_of_iterations() == 1)
        {
            
            _Parallel_chunk_helper_invoke<_Random_iterator, _Index_type, _Function, _Is_iterator>::_Invoke(_M_first, _Scaled_index, _M_function);
            return;
        }

        
        
        structured_task_group _Helper_group;

        
        _Worker_proxy<_Index_type> _Worker(_M_parent_worker);

        
        
        
        task_handle<_Parallel_chunk_helper> _Helper_task(_Parallel_chunk_helper(_M_first, _M_step, _M_function, _Worker_range, &_Worker));

        _Helper_group.run(_Helper_task);

        ::Concurrency::details::_MallocaListHolder<task_handle<_Parallel_chunk_helper>> _Holder;

        
        
        
        

        for (_Index_type _I = _Current_iteration; _I < _Worker_range._M_last_iteration; (_I++, _Worker_range._M_current_iteration =_I, _Scaled_index += _M_step))
        {
            if (_Worker._Is_beacon_signaled())
            {
                
                
                
                
                if (_Worker._Is_done() || _Worker._Verify_beacon_cancellation())
                {
                    break;
                }
            }

            if (_Worker._Is_helper_registered())
            {
                
                

                if (_Worker._Send_range(&_Worker_range))
                {
                    
                    
                    task_handle<_Parallel_chunk_helper> * _Helper_subtask = _Holder._AddRawMallocaNode(__pragma(warning(suppress: 6255 6386)) (_MallocaComputeSize(_Holder._GetAllocationSize()) != 0 ? _MarkAllocaS(malloc(_MallocaComputeSize(_Holder._GetAllocationSize())), 0xDDDD) : 0));

                    new(_Helper_subtask) task_handle<_Parallel_chunk_helper>
                        (_Parallel_chunk_helper(_M_first, _M_step, _M_function, _Worker_range, &_Worker));

                    
                    
                    _Helper_group.run(*_Helper_subtask);
                }
            }

            
            _Worker._Enable_intrusive_steal(&_Worker_range);

            
            _Parallel_chunk_helper_invoke<_Random_iterator, _Index_type, _Function, _Is_iterator>::_Invoke(_M_first, _Scaled_index, _M_function);

            
            _Worker._Disable_intrusive_steal();
        }

        
        _Worker._Set_done();

        
        _Helper_group.wait();

        
        
        _Worker._Set_tree_done();
    }

private:

    const _Random_iterator&            _M_first;
    const _Index_type&                 _M_step;
    const _Function&                   _M_function;

    const _Index_type                  _M_first_iteration;
    const _Index_type                  _M_last_iteration;

    _Worker_proxy<_Index_type> * const _M_parent_worker;

    _Parallel_chunk_helper const & operator=(_Parallel_chunk_helper const&);    
};

template <typename _Random_iterator, typename _Index_type, typename _Function, typename _Partitioner, bool _Is_iterator>
class _Parallel_fixed_chunk_helper
{
public:
    _Parallel_fixed_chunk_helper(_Index_type, const _Random_iterator& _First, _Index_type _First_iteration,
         _Index_type _Last_iteration, const _Index_type& _Step, const _Function& _Func, const _Partitioner&)
            : _M_first(_First),
            _M_step(_Step),
            _M_function(_Func),
            _M_first_iteration(_First_iteration),
            _M_last_iteration(_Last_iteration)
    {
        
    }

    void operator()() const
    {
        
        _Index_type _Scaled_index = _M_first_iteration * _M_step;

        for (_Index_type _I = _M_first_iteration; _I < _M_last_iteration; (_I++, _Scaled_index += _M_step))
        {
            
            _Parallel_chunk_helper_invoke<_Random_iterator, _Index_type, _Function, _Is_iterator>::_Invoke(_M_first, _Scaled_index, _M_function);
        }
    }
private:

    const _Random_iterator&            _M_first;
    const _Index_type&                 _M_step;
    const _Function&                   _M_function;

    const _Index_type                  _M_first_iteration;
    const _Index_type                  _M_last_iteration;

    _Parallel_fixed_chunk_helper const & operator=(_Parallel_fixed_chunk_helper const&);    
};

template <typename _Random_iterator, typename _Index_type, typename _Function, bool _Is_iterator>
class _Parallel_localized_chunk_helper
{
public:
    typedef _Parallel_fixed_chunk_helper<_Random_iterator, _Index_type, _Function, static_partitioner, _Is_iterator> _Base;

    _Parallel_localized_chunk_helper(_Index_type _Chunk_index, const _Random_iterator& _First, _Index_type _First_iteration, _Index_type _Last_iteration, const _Index_type& _Step,
        const _Function& _Func, affinity_partitioner& _Part)
            : _M_chunk_location(_Part._Get_chunk_location(static_cast<unsigned int>(_Chunk_index))),
            _M_fixed_helper(_Chunk_index, _First, _First_iteration, _Last_iteration, _Step, _Func, static_partitioner())
    {
        
    }

    
    void operator()() const
    {
        
        if (_M_chunk_location._Is_system())
        {
            _M_chunk_location = location::current();
        }

        _M_fixed_helper();
    }
private:

    location&       _M_chunk_location;
    _Base           _M_fixed_helper;
    _Parallel_localized_chunk_helper const & operator=(_Parallel_localized_chunk_helper const&);    
};

#pragma warning(pop)

template <typename _Worker_class, typename _Index_type, typename Partitioner>
void _Parallel_chunk_task_group_run(structured_task_group& _Task_group,
                                    task_handle<_Worker_class>* _Chunk_helpers,
                                    const Partitioner&,
                                    _Index_type _I)
{
    _Task_group.run(_Chunk_helpers[_I]);
}

template <typename _Worker_class, typename _Index_type>
void _Parallel_chunk_task_group_run(structured_task_group& _Task_group,
                                    task_handle<_Worker_class>* _Chunk_helpers,
                                    affinity_partitioner& _Part,
                                    _Index_type _I)
{
     _Task_group.run(_Chunk_helpers[_I], _Part._Get_chunk_location(static_cast<unsigned int>(_I)));
}




template <typename _Worker_class, typename _Random_iterator, typename _Index_type, typename _Function, typename _Partitioner>
void _Parallel_chunk_impl(const _Random_iterator& _First, _Index_type _Range_arg, const _Index_type& _Step, const _Function& _Func, _Partitioner&& _Part)
{
    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Range_arg > 1))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2386, 0, L"%ls", L"_Range_arg > 1")) || (__debugbreak(), 0) ); __assume(_Range_arg > 1);} while(false);
    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Step > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2387, 0, L"%ls", L"_Step > 0")) || (__debugbreak(), 0) ); __assume(_Step > 0);} while(false);

    _Index_type _Num_iterations = _Range_arg;
    if (_Step != 1)
    {
        --_Num_iterations;
        _Num_iterations /= _Step;
        ++_Num_iterations;
    }

    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Num_iterations > 1))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2397, 0, L"%ls", L"_Num_iterations > 1")) || (__debugbreak(), 0) ); __assume(_Num_iterations > 1);} while(false);

    _Index_type _Num_chunks = _Part._Get_num_chunks(_Num_iterations);
    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Num_chunks > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2400, 0, L"%ls", L"_Num_chunks > 0")) || (__debugbreak(), 0) ); __assume(_Num_chunks > 0);} while(false);

    
    ::Concurrency::details::_MallocaArrayHolder<task_handle<_Worker_class>> _Holder;
    task_handle<_Worker_class> * _Chunk_helpers = _Holder._InitOnRawMalloca(__pragma(warning(suppress: 6255 6386)) (_MallocaComputeSize(sizeof(task_handle<_Worker_class>) * static_cast<size_t>(_Num_chunks)) != 0 ? _MarkAllocaS(malloc(_MallocaComputeSize(sizeof(task_handle<_Worker_class>) * static_cast<size_t>(_Num_chunks))), 0xDDDD) : 0));

    structured_task_group _Task_group;

    _Index_type _Iterations_per_chunk = _Num_iterations / _Num_chunks;
    _Index_type _Remaining_iterations = _Num_iterations % _Num_chunks;

    
    
    if (_Iterations_per_chunk == 0)
    {
        _Num_chunks = _Remaining_iterations;
    }

    _Index_type _Work_size = 0;
    _Index_type _Start_iteration = 0;
    _Index_type _I;

    
    for (_I = 0; _I < _Num_chunks - 1; _I++)
    {
        if (_Remaining_iterations > 0)
        {
            
            _Work_size = _Iterations_per_chunk + 1;
            _Remaining_iterations--;
        }
        else
        {
            _Work_size = _Iterations_per_chunk;
        }

        
        new(&_Chunk_helpers[_I]) task_handle<_Worker_class>(_Worker_class(_I, _First, _Start_iteration, _Start_iteration + _Work_size, _Step, _Func, ::std::forward<_Partitioner>(_Part)));
        _Holder._IncrementConstructedElemsCount();

        
        _Parallel_chunk_task_group_run(_Task_group, _Chunk_helpers, ::std::forward<_Partitioner>(_Part), _I);

        
        _Start_iteration += _Work_size;
    }

    
    __pragma(warning (suppress: 4127)) do {(void)( (!!(((_Remaining_iterations == 0) || ((_Iterations_per_chunk == 0) && (_Remaining_iterations == 1))))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 2448, 0, L"%ls", L"(_Remaining_iterations == 0) || ((_Iterations_per_chunk == 0) && (_Remaining_iterations == 1))")) || (__debugbreak(), 0) ); __assume((_Remaining_iterations == 0) || ((_Iterations_per_chunk == 0) && (_Remaining_iterations == 1)));} while(false);
    _Work_size = _Num_iterations - _Start_iteration;

    
    new(&_Chunk_helpers[_I]) task_handle<_Worker_class>(_Worker_class(_I, _First, _Start_iteration, _Start_iteration + _Work_size, _Step, _Func, ::std::forward<_Partitioner>(_Part)));
    _Holder._IncrementConstructedElemsCount();

    _Task_group.run_and_wait(_Chunk_helpers[_I]);
}

template <typename _Worker_class, typename _Random_iterator, typename _Index_type, typename _Function>
void _Parallel_chunk_impl(const _Random_iterator& _First, _Index_type _Range_arg, const _Index_type& _Step, const _Function& _Func)
{
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, auto_partitioner());
}


template <typename _Index_type, typename _Diff_type, typename _Function>
void _Parallel_for_partitioned_impl(_Index_type _First, _Diff_type _Range_arg, _Diff_type _Step, const _Function& _Func, const auto_partitioner& _Part)
{
    typedef _Parallel_chunk_helper<_Index_type, _Diff_type, _Function, auto_partitioner, false> _Worker_class;
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}


template <typename _Index_type, typename _Diff_type, typename _Function>
void _Parallel_for_partitioned_impl(_Index_type _First, _Diff_type _Range_arg, _Diff_type _Step, const _Function& _Func, const static_partitioner& _Part)
{
    typedef _Parallel_fixed_chunk_helper<_Index_type, _Diff_type, _Function, static_partitioner, false> _Worker_class;
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}


template <typename _Index_type, typename _Diff_type, typename _Function>
void _Parallel_for_partitioned_impl(_Index_type _First, _Diff_type _Range_arg, _Diff_type _Step, const _Function& _Func, const simple_partitioner& _Part)
{
    typedef _Parallel_fixed_chunk_helper<_Index_type, _Diff_type, _Function, simple_partitioner, false> _Worker_class;
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}



template <typename _Index_type, typename _Diff_type, typename _Function>
void _Parallel_for_partitioned_impl(_Index_type _First, _Diff_type _Range_arg, _Diff_type _Step, const _Function& _Func, affinity_partitioner& _Part)
{
    typedef _Parallel_localized_chunk_helper<_Index_type, _Diff_type, _Function, false> _Worker_class;
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}

template <typename _Index_type, typename _Function, typename _Partitioner>
void _Parallel_for_impl(_Index_type _First, _Index_type _Last, _Index_type _Step, const _Function& _Func, _Partitioner&& _Part)
{
    
    if (_Step < 1)
    {
        throw ::std::invalid_argument("_Step");
    }

    
    if (_First >= _Last)
    {
        return;
    }

    using _Diff_type = ::std::conditional_t<::std::is_integral_v<_Index_type>,
        ::std::conditional_t<sizeof(_Index_type) <= sizeof(long), unsigned long, unsigned long long>,
        decltype(_Last - _First)>;

    _Diff_type _Range_size = static_cast<_Diff_type>(_Last) - static_cast<_Diff_type>(_First);
    _Diff_type _Diff_step = _Step;

    if (_Range_size <= _Diff_step)
    {
        _Func(_First);
    }
    else
    {
        _Parallel_for_partitioned_impl<_Index_type, _Diff_type, _Function>(_First, _Range_size, _Step, _Func, ::std::forward<_Partitioner>(_Part));
    }
}

template <typename _Index_type, typename _Function>
void _Parallel_for_impl(_Index_type _First, _Index_type _Last, _Index_type _Step, const _Function& _Func)
{
    _Parallel_for_impl(_First, _Last, _Step, _Func, auto_partitioner());
}









































template <typename _Index_type, typename _Function, typename _Partitioner>
void parallel_for(_Index_type _First, _Index_type _Last, _Index_type _Step, const _Function& _Func, _Partitioner&& _Part)
{
    _Trace_ppl_function(PPLParallelForEventGuid, 4, CONCRT_EVENT_START);
    _Parallel_for_impl(_First, _Last, _Step, _Func, ::std::forward<_Partitioner>(_Part));
    _Trace_ppl_function(PPLParallelForEventGuid, 4, CONCRT_EVENT_END);
}





























template <typename _Index_type, typename _Function>
void parallel_for(_Index_type _First, _Index_type _Last, _Index_type _Step, const _Function& _Func)
{
    parallel_for(_First, _Last, _Step, _Func, auto_partitioner());
}


































template <typename _Index_type, typename _Function>
void parallel_for(_Index_type _First, _Index_type _Last, const _Function& _Func, const auto_partitioner& _Part = auto_partitioner())
{
    parallel_for(_First, _Last, static_cast<_Index_type>(1), _Func, _Part);
}


































template <typename _Index_type, typename _Function>
void parallel_for(_Index_type _First, _Index_type _Last, const _Function& _Func, const static_partitioner& _Part)
{
    parallel_for(_First, _Last, static_cast<_Index_type>(1), _Func, _Part);
}


































template <typename _Index_type, typename _Function>
void parallel_for(_Index_type _First, _Index_type _Last, const _Function& _Func, const simple_partitioner& _Part)
{
    parallel_for(_First, _Last, static_cast<_Index_type>(1), _Func, _Part);
}


































template <typename _Index_type, typename _Function>
void parallel_for(_Index_type _First, _Index_type _Last, const _Function& _Func, affinity_partitioner& _Part)
{
    parallel_for(_First, _Last, static_cast<_Index_type>(1), _Func, _Part);
}











#pragma warning(push)
#pragma warning(disable: 4180)

template <typename _Forward_iterator, typename _Function, unsigned int _Chunk_size>
class _Parallel_for_each_helper
{
public:
    typedef typename ::std::iterator_traits<_Forward_iterator>::value_type _Value_type;
    static const unsigned int _Size = _Chunk_size;

    _Parallel_for_each_helper(_Forward_iterator& _First, const _Forward_iterator& _Last, const _Function& _Func) :
        _M_function(_Func), _M_len(0)
    {
        static_assert(::std::is_lvalue_reference_v<decltype(*_First)>, "lvalue required for forward iterator operator *");
        
        for (unsigned int _Index=0; (_Index < _Size) && (_First != _Last); _Index++)
        {
            _M_element[_M_len++] = &(*_First++);
        }
    }

    void operator()() const
    {
        
        _Parallel_for_impl(0U, _M_len, 1U,
            [this] (unsigned int _Index)
            {
                _M_function(*(_M_element[_Index]));
            }
        );
    }

private:

    const _Function& _M_function;
    typename ::std::iterator_traits<_Forward_iterator>::pointer    _M_element[_Size];
    unsigned int     _M_len;

    _Parallel_for_each_helper const & operator=(_Parallel_for_each_helper const&);    
};

#pragma warning(pop)



template <typename _Forward_iterator, typename _Function>
void _Parallel_for_each_chunk(_Forward_iterator& _First, const _Forward_iterator& _Last, const _Function& _Func, task_group& _Task_group)
{
    
    
    
    const unsigned int _Chunk_size = 1024;

    
    _Parallel_for_each_helper<_Forward_iterator, _Function, _Chunk_size> _Functor(_First, _Last, _Func);

    
    
    _Task_group.run(_Functor);
}

template <typename _Forward_iterator, typename _Function>
void _Parallel_for_each_forward_impl(_Forward_iterator& _First, const _Forward_iterator& _Last, const _Function& _Func, task_group& _Task_group)
{
    _Parallel_for_each_chunk(_First, _Last, _Func, _Task_group);

    
    if (_First != _Last)
    {
        _Task_group.run(
            [&_First, &_Last, &_Func, &_Task_group]
            {
                ::Concurrency::_Parallel_for_each_forward_impl(_First, _Last, _Func, _Task_group);
            }
        );
    }
}

template <typename _Forward_iterator, typename _Function>
void _Parallel_for_each_impl(_Forward_iterator _First, const _Forward_iterator& _Last, const _Function& _Func, const auto_partitioner&, ::std::forward_iterator_tag)
{
    
    
    if (_First != _Last)
    {
        task_group _Task_group;

        _Parallel_for_each_forward_impl(_First, _Last, _Func, _Task_group);

        _Task_group.wait();
    }
}

template <typename _Random_iterator, typename _Index_type, typename _Function>
void _Parallel_for_each_partitioned_impl(const _Random_iterator& _First, _Index_type _Range_arg, _Index_type _Step, const _Function& _Func, const auto_partitioner& _Part)
{
    typedef _Parallel_chunk_helper<_Random_iterator, _Index_type, _Function, auto_partitioner, true> _Worker_class;
        
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}

template <typename _Random_iterator, typename _Index_type, typename _Function>
void _Parallel_for_each_partitioned_impl(const _Random_iterator& _First, _Index_type _Range_arg, _Index_type _Step, const _Function& _Func, const static_partitioner& _Part)
{
    typedef _Parallel_fixed_chunk_helper<_Random_iterator, _Index_type, _Function, static_partitioner, true> _Worker_class;
    
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}

template <typename _Random_iterator, typename _Index_type, typename _Function>
void _Parallel_for_each_partitioned_impl(const _Random_iterator& _First, _Index_type _Range_arg, _Index_type _Step, const _Function& _Func, const simple_partitioner& _Part)
{
    typedef _Parallel_fixed_chunk_helper<_Random_iterator, _Index_type, _Function, simple_partitioner, true> _Worker_class;
    
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}

template <typename _Random_iterator, typename _Index_type, typename _Function>
void _Parallel_for_each_partitioned_impl(const _Random_iterator& _First, _Index_type _Range_arg, _Index_type _Step, const _Function& _Func, affinity_partitioner& _Part)
{
    typedef _Parallel_localized_chunk_helper<_Random_iterator, _Index_type, _Function, true> _Worker_class;
        
    _Parallel_chunk_impl<_Worker_class>(_First, _Range_arg, _Step, _Func, _Part);
}

template <typename _Random_iterator, typename _Function, typename _Partitioner>
void _Parallel_for_each_impl(const _Random_iterator& _First, const _Random_iterator& _Last, const _Function& _Func, _Partitioner&& _Part, ::std::random_access_iterator_tag)
{
    typedef typename ::std::iterator_traits<_Random_iterator>::difference_type _Index_type;

    
    if (_First >= _Last)
    {
        return;
    }

    _Index_type _Range_size = _Last - _First;

    if (_Range_size == 1)
    {
        _Func(*_First);
    }
    else
    {
        _Index_type _Step = 1;

        _Parallel_for_each_partitioned_impl(_First, _Range_size, _Step, _Func, ::std::forward<_Partitioner>(_Part));
   }
}





























template <typename _Iterator, typename _Function>
void parallel_for_each(_Iterator _First, _Iterator _Last, const _Function& _Func)
{
    parallel_for_each(_First, _Last, _Func, auto_partitioner());
}






































template <typename _Iterator, typename _Function, typename _Partitioner>
void parallel_for_each(_Iterator _First, _Iterator _Last, const _Function& _Func, _Partitioner&& _Part)
{
    _Trace_ppl_function(PPLParallelForeachEventGuid, 4, CONCRT_EVENT_START);
    _Parallel_for_each_impl(_First, _Last, _Func, ::std::forward<_Partitioner>(_Part), typename ::std::iterator_traits<_Iterator>::iterator_category());
    _Trace_ppl_function(PPLParallelForeachEventGuid, 4, CONCRT_EVENT_END);
}



#pragma warning(push)
#pragma warning(disable: 4180)


template <typename _Reduce_type, typename _Sub_function, typename _Combinable_type>
struct _Reduce_functor_helper
{
    const _Sub_function &_Sub_fun;
    const _Reduce_type &_Identity_value;

    _Combinable_type &_Combinable;

    typedef _Reduce_type _Reduce_type;
    typedef typename _Combinable_type::_Bucket _Bucket_type;

    _Reduce_functor_helper(const _Reduce_type &_Identity, const _Sub_function &_Sub_fun, _Combinable_type &&_Comb)
        : _Sub_fun(_Sub_fun),
        _Identity_value(_Identity),
        _Combinable(_Comb)
    {
    }

private:
    _Reduce_functor_helper &operator =(const _Reduce_functor_helper &_Other);
};


template<typename _Ty, typename _Sym_fun>
class _Order_combinable
{
public:
    
    struct _Bucket
    {
        
        char _Value[(sizeof(_Ty) / sizeof(char))];
        _Bucket * _Next;

        _Bucket(_Bucket *_N)
            : 
            _Next(_N)
        {
        }

        void _Insert(_Bucket *_Item)
        {
            
            _Item->_Next = _Next;
            _Next = _Item;
        }

        
        void _Put(const _Ty &_Cur)
        {
            new(reinterpret_cast<_Ty *>(&_Value)) _Ty(_Cur);
        }
    };

private:
    const _Sym_fun &_M_fun;
    size_t _M_number;
    _Bucket *_M_root;
    _Order_combinable &operator =(const _Order_combinable &_Other);

public:
    _Bucket *_Construct(_Bucket *_Par = 0)
    {
        _Bucket * _Ret = static_cast<_Bucket *>(::Concurrency::Alloc(sizeof(_Bucket)));
        return new(_Ret)_Bucket(_Par);
    }

    _Order_combinable(const _Sym_fun &_Fun)
        : _M_fun(_Fun),
        _M_number(0),
        _M_root(0)
    {
    }

    ~_Order_combinable()
    {
        while (_M_root)
        {
            _Bucket *_Cur = _M_root;
            _M_root = _M_root->_Next;
            reinterpret_cast<_Ty &>(_Cur->_Value).~_Ty();
            ::Concurrency::Free(_Cur);
        }
    }

    
    _Ty _Serial_combine_release()
    {
        _Ty _Ret(reinterpret_cast<_Ty &>(_M_root->_Value));
        _Bucket *_Cur = _M_root;
        _M_root = _M_root->_Next;

        while (_M_root)
        {
            reinterpret_cast<_Ty &>(_Cur->_Value).~_Ty();
            ::Concurrency::Free(_Cur);
            _Cur = _M_root;
            _Ret = _M_fun(reinterpret_cast <_Ty &> (_Cur->_Value), _Ret);
            _M_root = _M_root->_Next;
        }

        reinterpret_cast<_Ty &>(_Cur->_Value).~_Ty();
        ::Concurrency::Free(_Cur);

        return _Ret;
    }

    
    _Bucket *_Unsafe_push_back()
    {
        return _M_root = _Construct(_M_root);
    }
};



























































template<typename _Reduce_type, typename _Forward_iterator, typename _Range_reduce_fun, typename _Sym_reduce_fun>
inline _Reduce_type parallel_reduce(_Forward_iterator _Begin, _Forward_iterator _End, const _Reduce_type& _Identity,
    const _Range_reduce_fun &_Range_fun, const _Sym_reduce_fun &_Sym_fun)
{
    typedef typename ::std::iterator_traits<_Forward_iterator>::value_type _Value_type;

    static_assert(!::std::is_same_v<typename ::std::iterator_traits<_Forward_iterator>::iterator_category, ::std::input_iterator_tag>
        && !::std::is_same_v<typename ::std::iterator_traits<_Forward_iterator>::iterator_category, ::std::output_iterator_tag>,
        "iterator can not be input_iterator or output_iterator.");

    return _Parallel_reduce_impl(_Begin, _End,
        _Reduce_functor_helper<_Reduce_type, _Range_reduce_fun,
            _Order_combinable<_Reduce_type, _Sym_reduce_fun>>(_Identity, _Range_fun, _Order_combinable<_Reduce_type, _Sym_reduce_fun>(_Sym_fun)),
        typename ::std::iterator_traits<_Forward_iterator>::iterator_category());
}
















































template<typename _Forward_iterator, typename _Sym_reduce_fun>
inline typename ::std::iterator_traits<_Forward_iterator>::value_type parallel_reduce(_Forward_iterator _Begin, _Forward_iterator _End,
    const typename ::std::iterator_traits<_Forward_iterator>::value_type &_Identity, _Sym_reduce_fun _Sym_fun)
{
    typedef ::std::remove_cv_t<typename ::std::iterator_traits<_Forward_iterator>::value_type> _Reduce_type;

    return parallel_reduce(_Begin, _End, _Identity,
        [_Sym_fun](_Forward_iterator _Begin, _Forward_iterator _End, _Reduce_type _Init)->_Reduce_type
        {
            while (_Begin != _End)
            {
                _Init = _Sym_fun(_Init, *_Begin++);
            }

            return _Init;
        },
        _Sym_fun);
}








































template<typename _Forward_iterator>
inline typename ::std::iterator_traits<_Forward_iterator>::value_type parallel_reduce(
    _Forward_iterator _Begin, _Forward_iterator _End, const typename ::std::iterator_traits<_Forward_iterator>::value_type &_Identity)
{
    return parallel_reduce(_Begin, _End, _Identity, ::std::plus<typename ::std::iterator_traits<_Forward_iterator>::value_type>());
}


template <typename _Forward_iterator, typename _Function>
typename _Function::_Reduce_type _Parallel_reduce_impl(_Forward_iterator _First, const _Forward_iterator& _Last, const _Function& _Func,
    ::std::forward_iterator_tag)
{
    
    
    if (_First != _Last)
    {
        task_group _Task_group;
        _Parallel_reduce_forward_executor(_First, _Last, _Func, _Task_group);
        _Task_group.wait();
        return _Func._Combinable._Serial_combine_release();
    }
    else
    {
        return _Func._Identity_value;
    }
}


template<typename _Forward_iterator, typename _Functor>
class _Parallel_reduce_fixed_worker
{
public:
    
    _Parallel_reduce_fixed_worker(_Forward_iterator _Begin, _Forward_iterator _End, const _Functor &_Fun)
        : _M_fun(_Fun),
        _M_begin(_Begin),
        _M_end(_End),
        _M_bucket(_M_fun._Combinable._Unsafe_push_back())
    {
    }

    void operator ()() const
    {
        _M_bucket->_Put(_M_fun._Sub_fun(_M_begin, _M_end, _M_fun._Identity_value));
    }

private:
    const _Functor &_M_fun;
    const _Forward_iterator _M_begin, _M_end;
    typename _Functor::_Bucket_type * const _M_bucket;
    _Parallel_reduce_fixed_worker &operator =(const _Parallel_reduce_fixed_worker &_Other);
};

template <typename _Worker, typename _Random_iterator, typename _Function>
void _Parallel_reduce_random_executor(_Random_iterator _Begin, _Random_iterator _End, const _Function& _Fun);

template <typename _Random_iterator, typename _Function>
typename _Function::_Reduce_type _Parallel_reduce_impl(_Random_iterator _First, _Random_iterator _Last, const _Function& _Func,
    ::std::random_access_iterator_tag)
{
    typedef _Parallel_reduce_fixed_worker<_Random_iterator, _Function> _Worker_class;

    
    if (_First >= _Last)
    {
        return _Func._Identity_value;
    }
    
    else if (_Last - _First <= 1)
    {
        _Worker_class(_First, _Last, _Func)();
        return _Func._Combinable._Serial_combine_release();
    }
    else
    {
        
        _Parallel_reduce_random_executor<_Worker_class>(_First, _Last, _Func);
        return _Func._Combinable._Serial_combine_release();
    }
}




template <typename _Worker, typename _Random_iterator, typename _Function>
void _Parallel_reduce_random_executor(_Random_iterator _Begin, _Random_iterator _End, const _Function& _Fun)
{
    size_t _Cpu_num = static_cast<size_t>(::Concurrency::details::_CurrentScheduler::_GetNumberOfVirtualProcessors()), _Size = _End - _Begin;

    structured_task_group _Tg;
    ::Concurrency::details::_MallocaArrayHolder<task_handle<_Worker>> _Holder;
    task_handle<_Worker> *_Tasks = _Holder._InitOnRawMalloca(__pragma(warning(suppress: 6255 6386)) (_MallocaComputeSize(sizeof(task_handle<_Worker>) * (_Cpu_num - 1)) != 0 ? _MarkAllocaS(malloc(_MallocaComputeSize(sizeof(task_handle<_Worker>) * (_Cpu_num - 1))), 0xDDDD) : 0));

    size_t _Begin_index = 0;
    size_t _Step = _Size / _Cpu_num;
    size_t _NumRemaining = _Size - _Step * _Cpu_num;

    for(size_t _I = 0; _I < _Cpu_num - 1; _I++)
    {
        size_t _Next = _Begin_index + _Step;

        
        if (_NumRemaining)
        {
            --_NumRemaining;
            ++_Next;
        }

        
        new (_Tasks + _I) task_handle<_Worker>(_Worker(_Begin + _Begin_index, _Begin + _Next, _Fun));
        _Holder._IncrementConstructedElemsCount();

        
        _Tg.run(_Tasks[_I]);
        _Begin_index = _Next;
    }

    task_handle<_Worker> _Tail(_Worker(_Begin + _Begin_index, _End, _Fun));
    _Tg.run_and_wait(_Tail);
}



template <typename _Forward_iterator, typename _Function, int _Default_worker_size, int _Default_chunk_size>
struct _Parallel_reduce_forward_executor_helper
{
    typedef _Parallel_reduce_fixed_worker<_Forward_iterator, _Function> _Worker_class;
    mutable task_handle<_Worker_class> * _Workers;
    int _Worker_size;

    _Parallel_reduce_forward_executor_helper(_Forward_iterator &_First, _Forward_iterator _Last, const _Function& _Func)
        : _Workers(static_cast<task_handle<_Worker_class> *>(
            ::Concurrency::Alloc(sizeof(task_handle<_Worker_class>) * _Default_worker_size))),
        _Worker_size(0)
    {
        while (_Worker_size < _Default_worker_size && _First != _Last)
        {
            
            _Forward_iterator _Head = _First;

            
            for (size_t _I = 0; _I < _Default_chunk_size && _First != _Last; ++_I, ++_First)
            {
                
            }

            
            new (_Workers + _Worker_size++) task_handle<_Worker_class>(_Worker_class(_Head, _First, _Func));
        }
    }

    _Parallel_reduce_forward_executor_helper(const _Parallel_reduce_forward_executor_helper &_Other):
        _Workers(_Other._Workers), _Worker_size(_Other._Worker_size)
    {
        _Other._Workers = 0; 
    }

    void operator ()() const
    {
        structured_task_group _Tg;
        for(int _I = 0; _I < _Worker_size; _I++)
        {
            _Tg.run(_Workers[_I]);
        }
        _Tg.wait();
    }

    ~_Parallel_reduce_forward_executor_helper()
    {
        if (_Workers)
        {
            for (int _I = 0; _I < _Worker_size; _I++)
            {
                _Workers[_I].~task_handle<_Worker_class>();
            }
            ::Concurrency::Free(_Workers);
            _Workers = 0;
        }
    }
};

template <typename _Forward_iterator, typename _Function>
void _Parallel_reduce_forward_executor(_Forward_iterator _First, _Forward_iterator _Last, const _Function& _Func, task_group& _Task_group)
{
    const static int _Internal_worker_number = 1024, _Default_chunk_size = 512;
    typedef _Parallel_reduce_fixed_worker<_Forward_iterator, _Function> _Worker_class;

    structured_task_group _Worker_group;
    ::Concurrency::details::_MallocaArrayHolder<task_handle<_Worker_class>> _Holder;
    task_handle<_Worker_class>* _Workers = _Holder._InitOnRawMalloca(__pragma(warning(suppress: 6255 6386)) (_MallocaComputeSize(_Internal_worker_number * sizeof(task_handle<_Worker_class>)) != 0 ? _MarkAllocaS(malloc(_MallocaComputeSize(_Internal_worker_number * sizeof(task_handle<_Worker_class>))), 0xDDDD) : 0));

    
    int _Index = 0;
    while (_Index < _Internal_worker_number && _First != _Last)
    {
        
        _Forward_iterator _Head = _First;

        
        for (size_t _I = 0; _I < _Default_chunk_size && _First != _Last; ++_I, ++_First)
        {
            
        };

        
        new (_Workers + _Index) task_handle<_Worker_class>(_Worker_class(_Head, _First, _Func));
        _Holder._IncrementConstructedElemsCount();
        _Worker_group.run(_Workers[_Index]);
        ++_Index;
    }

    
    while (_First != _Last)
    {
        _Task_group.run(_Parallel_reduce_forward_executor_helper<_Forward_iterator, _Function, _Internal_worker_number, _Default_chunk_size>(_First, _Last, _Func));
    }

    _Worker_group.wait();
}

#pragma warning(pop)




#pragma warning(push)
#pragma warning(disable: 4180)




template<typename _Any_input_traits, typename _Any_output_traits>
struct _Unary_transform_impl_helper
{
    template<typename _Input_iterator, typename _Output_iterator, typename _Unary_operator>
    static void _Parallel_transform_unary_impl(_Input_iterator _Begin, _Input_iterator _End, _Output_iterator& _Result, const _Unary_operator& _Unary_op, const auto_partitioner&)
    {
        task_group _Tg;
        _Parallel_transform_unary_impl2(_Begin, _End, _Result, _Unary_op, _Tg);
        _Tg.wait();
    }
};

template<>
struct _Unary_transform_impl_helper<::std::random_access_iterator_tag, ::std::random_access_iterator_tag>
{
    template<typename _Random_input_iterator, typename _Random_output_iterator, typename _Unary_operator, typename _Partitioner>
    static void _Parallel_transform_unary_impl(_Random_input_iterator _Begin, _Random_input_iterator _End,
        _Random_output_iterator& _Result, const _Unary_operator& _Unary_op, _Partitioner&& _Part)
    {
        if (_Begin < _End)
        {
            ::Concurrency::_Parallel_for_impl(static_cast<size_t>(0), static_cast<size_t>(_End - _Begin), static_cast<size_t>(1),
                [_Begin, &_Result, &_Unary_op](size_t _Index)
                {
                    _Result[_Index] = _Unary_op(_Begin[_Index]);
                },
                ::std::forward<_Partitioner>(_Part));
            _Result += _End - _Begin;
        }
    }
};

template<typename _Any_input_traits1, typename _Any_input_traits2, typename _Any_output_traits>
struct _Binary_transform_impl_helper
{

    template<typename _Input_iterator1, typename _Input_iterator2, typename _Output_iterator, typename _Binary_operator>
    static void _Parallel_transform_binary_impl(_Input_iterator1 _Begin1, _Input_iterator1 _End1, _Input_iterator2 _Begin2,
        _Output_iterator& _Result, const _Binary_operator& _Binary_op, const auto_partitioner&)
    {
        task_group _Tg;
        _Parallel_transform_binary_impl2(_Begin1, _End1, _Begin2, _Result, _Binary_op, _Tg);
        _Tg.wait();
    }
};

template<>
struct _Binary_transform_impl_helper<::std::random_access_iterator_tag, ::std::random_access_iterator_tag, ::std::random_access_iterator_tag>
{
    template<typename _Random_input_iterator1, typename _Random_input_iterator2, typename _Random_output_iterator, typename _Binary_operator, typename _Partitioner>
    static void _Parallel_transform_binary_impl(_Random_input_iterator1 _Begin1, _Random_input_iterator1 _End1,
        _Random_input_iterator2 _Begin2, _Random_output_iterator& _Result, const _Binary_operator& _Binary_op, _Partitioner&& _Part)
    {
        if (_Begin1 < _End1)
        {
            ::Concurrency::_Parallel_for_impl(static_cast<size_t>(0), static_cast<size_t>(_End1 - _Begin1), static_cast<size_t>(1),
                [_Begin1, _Begin2, &_Result, &_Binary_op](size_t _Index)
                {
                    _Result[_Index] = _Binary_op(_Begin1[_Index], _Begin2[_Index]);
                },
                ::std::forward<_Partitioner>(_Part));
            _Result += _End1 - _Begin1;
        }
    }
};




template <typename _Forward_iterator, typename _Iterator_kind>
class _Iterator_helper
{
public:
    static const size_t _Size = 1024;
    typedef typename ::std::iterator_traits<_Forward_iterator>::value_type value_type;

    _Iterator_helper()
    {
        static_assert(!::std::is_same_v<_Iterator_kind, ::std::input_iterator_tag>
            && !::std::is_same_v<_Iterator_kind, ::std::output_iterator_tag>,
            "iterator can not be input_iterator or output_iterator.");
    }

    size_t _Populate(_Forward_iterator& _First, _Forward_iterator _Last)
    {
        size_t _Length = 0;
        static_assert(::std::is_lvalue_reference_v<decltype(*_First)>, "lvalue required for forward iterator operator *");

        for (size_t _Index=0; (_Index < _Size) && (_First != _Last); _Index++)
        {
            
            _M_element_array[_Length++] = &(*_First++);
        }

        return _Length;
    }

    void _Populate(_Forward_iterator& _First, size_t _Length)
    {
        for (size_t _Index=0; _Index < _Length; _Index++)
        {
            _M_element_array[_Index] = &(*_First++);
        }
    }

    void _Store(const value_type& _Elem, size_t _Index) const
    {
        *(_M_element_array[_Index]) = _Elem;
    }

    typename ::std::iterator_traits<_Forward_iterator>::reference _Load(size_t _Index) const
    {
        return *(_M_element_array[_Index]);
    }

private:
    typename ::std::iterator_traits<_Forward_iterator>::pointer _M_element_array[_Size];
};

template <typename _Random_iterator>
class _Iterator_helper<_Random_iterator, ::std::random_access_iterator_tag>
{
public:
    static const size_t _Size = 1024;
    typedef typename ::std::iterator_traits<_Random_iterator>::value_type value_type;

    _Iterator_helper()
    {
    }

    size_t _Populate(_Random_iterator& _First, _Random_iterator _Last)
    {
        typename ::std::iterator_traits<_Random_iterator>::difference_type _Range_size = _Last - _First;
        typename ::std::iterator_traits<_Random_iterator>::difference_type _Sized = _Size;
        _M_first = _First;

        if (_Range_size > _Sized)
        {
            _First += _Size;
            return _Size;
        }
        else
        {
            _First += _Range_size;
            return static_cast<size_t>(_Range_size);
        }
    }

    void _Populate(_Random_iterator& _First, size_t _Length)
    {
        _M_first = _First;
        _First += _Length;
    }

    void _Store(const value_type& _Elem, size_t _Index) const
    {
        _M_first[_Index] = _Elem;
    }

    typename ::std::iterator_traits<_Random_iterator>::reference _Load(size_t _Index) const
    {
        
        return _M_first[_Index];
    }

private:
    _Random_iterator _M_first;
};

template <typename _Input_iterator1, typename _Input_iterator2, typename _Output_iterator, typename _Binary_operator>
class _Parallel_transform_binary_helper
{
public:
    _Parallel_transform_binary_helper(_Input_iterator1& _First1, _Input_iterator1 _Last1, _Input_iterator2& _First2,
        _Output_iterator& _Result, const _Binary_operator& _Binary_op)
            : _M_input_helper1(),
            _M_input_helper2(),
            _M_output_helper(),
            _M_binary_op(_Binary_op),
            _M_len(_M_input_helper1._Populate(_First1, _Last1))
        {
            _M_input_helper2._Populate(_First2, _M_len);
            _M_output_helper._Populate(_Result, _M_len);
        }

        void operator()() const
        {
            
            ::Concurrency::_Parallel_for_impl(static_cast<size_t>(0), _M_len, static_cast<size_t>(1),
                [this] (size_t _Index)
                {
                    _M_output_helper._Store(_M_binary_op(_M_input_helper1._Load(_Index), _M_input_helper2._Load(_Index)), _Index);
                });
        }

private:

    _Iterator_helper<_Input_iterator1, typename ::std::iterator_traits<_Input_iterator1>::iterator_category> _M_input_helper1;
    _Iterator_helper<_Input_iterator2, typename ::std::iterator_traits<_Input_iterator2>::iterator_category> _M_input_helper2;
    _Iterator_helper<_Output_iterator, typename ::std::iterator_traits<_Output_iterator>::iterator_category> _M_output_helper;
    const _Binary_operator&                                                                                  _M_binary_op;
    size_t                                                                                                   _M_len;

    _Parallel_transform_binary_helper const & operator=(_Parallel_transform_binary_helper const&);    
};

template <typename _Input_iterator1, typename _Input_iterator2, typename _Output_iterator, typename _Binary_operator>
void _Parallel_transform_binary_impl2(_Input_iterator1 _First1, _Input_iterator1 _Last1, _Input_iterator2 _First2, _Output_iterator &_Result,
    const _Binary_operator& _Binary_op, task_group& _Tg)
{
    
    {
        _Parallel_transform_binary_helper<_Input_iterator1, _Input_iterator2, _Output_iterator, _Binary_operator> _Functor(_First1, _Last1, _First2, _Result, _Binary_op);
        _Tg.run(_Functor);
    }

    
    if (_First1 != _Last1)
    {
        _Tg.run(
            [=, &_Result, &_Binary_op, &_Tg]
            {
                _Parallel_transform_binary_impl2(_First1, _Last1, _First2, _Result, _Binary_op, _Tg);
            });
    }
}

template <typename _Input_iterator, typename _Output_iterator, typename _Unary_operator>
class _Parallel_transform_unary_helper
{
public:
    _Parallel_transform_unary_helper(_Input_iterator& _First, _Input_iterator _Last, _Output_iterator &_Result, const _Unary_operator& _Unary_op)
            : _M_input_helper(),
            _M_output_helper(),
            _M_unary_op(_Unary_op),
            _M_len(_M_input_helper._Populate(_First, _Last))
        {
            _M_output_helper._Populate(_Result, _M_len);
        }

        void operator()() const
        {
            
            ::Concurrency::_Parallel_for_impl(static_cast<size_t>(0), _M_len, static_cast<size_t>(1),
                [this] (size_t _Index)
                {
                    _M_output_helper._Store(_M_unary_op(_M_input_helper._Load(_Index)), _Index);
                });
        }

private:

    _Iterator_helper<_Input_iterator, typename ::std::iterator_traits<_Input_iterator>::iterator_category>   _M_input_helper;
    _Iterator_helper<_Output_iterator, typename ::std::iterator_traits<_Output_iterator>::iterator_category> _M_output_helper;
    const _Unary_operator&                                                                                   _M_unary_op;
    size_t                                                                                                   _M_len;

    _Parallel_transform_unary_helper const & operator=(_Parallel_transform_unary_helper const&);    
};

template <typename _Input_iterator, typename _Output_iterator, typename _Unary_operator>
void _Parallel_transform_unary_impl2(_Input_iterator _First, _Input_iterator _Last, _Output_iterator &_Result,
    const _Unary_operator& _Unary_op, task_group& _Tg)
{
    
    {
        _Parallel_transform_unary_helper<_Input_iterator, _Output_iterator, _Unary_operator> _Functor(_First, _Last, _Result, _Unary_op);
        _Tg.run(_Functor);
    }

    
    if (_First != _Last)
    {
        _Tg.run(
            [=, &_Result, &_Unary_op, &_Tg]
            {
                _Parallel_transform_unary_impl2(_First, _Last, _Result, _Unary_op, _Tg);
            });
    }
}

template <typename _Input_iterator, typename _Output_iterator, typename _Unary_operator, typename _Partitioner>
_Output_iterator _Parallel_transform_unary_impl(_Input_iterator _First, _Input_iterator _Last, _Output_iterator _Result, const _Unary_operator& _Unary_op, _Partitioner&& _Part)
{
    typedef typename ::std::iterator_traits<_Input_iterator>::iterator_category _Input_iterator_type;
    typedef typename ::std::iterator_traits<_Output_iterator>::iterator_category _Output_iterator_type;

    if (_First != _Last)
    {
        _Unary_transform_impl_helper<_Input_iterator_type, _Output_iterator_type>
            ::_Parallel_transform_unary_impl(_First, _Last, _Result, _Unary_op, ::std::forward<_Partitioner>(_Part));
    }

    return _Result;
}




















































template <typename _Input_iterator1, typename _Output_iterator, typename _Unary_operator>
_Output_iterator parallel_transform(_Input_iterator1 _First1, _Input_iterator1 _Last1, _Output_iterator _Result, const _Unary_operator& _Unary_op, const auto_partitioner& _Part = auto_partitioner())
{
    return _Parallel_transform_unary_impl(_First1, _Last1, _Result, _Unary_op, _Part);
}




















































template <typename _Input_iterator1, typename _Output_iterator, typename _Unary_operator>
_Output_iterator parallel_transform(_Input_iterator1 _First1, _Input_iterator1 _Last1, _Output_iterator _Result, const _Unary_operator& _Unary_op, const static_partitioner& _Part)
{
    return _Parallel_transform_unary_impl(_First1, _Last1, _Result, _Unary_op, _Part);
}




















































template <typename _Input_iterator1, typename _Output_iterator, typename _Unary_operator>
_Output_iterator parallel_transform(_Input_iterator1 _First1, _Input_iterator1 _Last1, _Output_iterator _Result, const _Unary_operator& _Unary_op, const simple_partitioner& _Part)
{
    return _Parallel_transform_unary_impl(_First1, _Last1, _Result, _Unary_op, _Part);
}




















































template <typename _Input_iterator1, typename _Output_iterator, typename _Unary_operator>
_Output_iterator parallel_transform(_Input_iterator1 _First1, _Input_iterator1 _Last1, _Output_iterator _Result, const _Unary_operator& _Unary_op, affinity_partitioner& _Part)
{
    return _Parallel_transform_unary_impl(_First1, _Last1, _Result, _Unary_op, _Part);
}


























































template <typename _Input_iterator1, typename _Input_iterator2, typename _Output_iterator, typename _Binary_operator, typename _Partitioner>
_Output_iterator parallel_transform(_Input_iterator1 _First1, _Input_iterator1 _Last1, _Input_iterator2 _First2,
    _Output_iterator _Result, const _Binary_operator& _Binary_op, _Partitioner&& _Part)
{
    typedef typename ::std::iterator_traits<_Input_iterator1>::iterator_category _Input_iterator_type1;
    typedef typename ::std::iterator_traits<_Input_iterator2>::iterator_category _Input_iterator_type2;
    typedef typename ::std::iterator_traits<_Output_iterator>::iterator_category _Output_iterator_type;

    if (_First1 != _Last1)
    {
        _Binary_transform_impl_helper<_Input_iterator_type1, _Input_iterator_type2, _Output_iterator_type>
            ::_Parallel_transform_binary_impl(_First1, _Last1, _First2, _Result, _Binary_op, ::std::forward<_Partitioner>(_Part));
    }

    return _Result;
}

















































template <typename _Input_iterator1, typename _Input_iterator2, typename _Output_iterator, typename _Binary_operator>
_Output_iterator parallel_transform(_Input_iterator1 _First1, _Input_iterator1 _Last1, _Input_iterator2 _First2,
    _Output_iterator _Result, const _Binary_operator& _Binary_op)
{
    return parallel_transform(_First1, _Last1, _First2, _Result, _Binary_op, auto_partitioner());
}

#pragma warning(pop)

#pragma warning(push)

#pragma warning(disable: 4316)















template<typename _Ty>
class combinable
{
private:



#pragma warning(push)
#pragma warning(disable: 4324)
    __declspec(align(64))
    struct _Node
    {
        unsigned long _M_key;
        _Ty _M_value;
        _Node* _M_chain;

        _Node(unsigned long _Key, _Ty _InitialValue)
            : _M_key(_Key),
            _M_value(::std::move(_InitialValue)),
            _M_chain(nullptr)
        {
        }
    };
#pragma warning(pop)

    static _Ty _DefaultInit()
    {
        return _Ty();
    }

public:
    
    
    
    
    
    
    
    
    
    
    
    combinable()
        : _M_buckets(),
        _M_size(),
        _M_fnInitialize(_DefaultInit)
    {
        _InitNew();
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template <typename _Function>
    explicit combinable(_Function _FnInitialize)
        : _M_buckets(),
        _M_size(),
        _M_fnInitialize(::std::move(_FnInitialize))
    {
        _InitNew();
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    combinable(const combinable& _Other)
        : _M_buckets(),
        _M_size(_Other._M_size),
        _M_fnInitialize(_Other._M_fnInitialize) 
    {
        _M_buckets = _InitCopy(_Other);
    }

    
    
    
    
    
    
    
    
    
    
    combinable& operator=(const combinable& _Other)
    {
        auto _Fn_initialize_copy = _Other._M_fnInitialize; 
        auto _New_buckets = _InitCopy(_Other); 
        
        clear();
        delete [] _M_buckets;
        _M_buckets = _New_buckets;
        _M_fnInitialize.swap(_Fn_initialize_copy);
        _M_size = _Other._M_size;

        return *this;
    }

    
    
    
    
    ~combinable()
    {
        clear();
        delete [] _M_buckets;
    }

    
    
    
    
    
    
    
    
    _Ty& local()
    {
        unsigned long _Key = ::Concurrency::details::platform::GetCurrentThreadId();
        size_t _Index;
        _Node* _ExistingNode = _FindLocalItem(_Key, &_Index);
        if (_ExistingNode == nullptr)
        {
            _ExistingNode = _AddLocalItem(_Key, _Index);
        }

        __pragma(warning (suppress: 4127)) do {(void)( (!!((_ExistingNode != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 4366, 0, L"%ls", L"_ExistingNode != nullptr")) || (__debugbreak(), 0) ); __assume(_ExistingNode != nullptr);} while(false);
        return _ExistingNode->_M_value;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    _Ty& local(bool& _Exists)
    {
        unsigned long _Key = ::Concurrency::details::platform::GetCurrentThreadId();
        size_t _Index;
        _Node* _ExistingNode = _FindLocalItem(_Key, &_Index);
        if (_ExistingNode == nullptr)
        {
            _Exists = false;
            _ExistingNode = _AddLocalItem(_Key, _Index);
        }
        else
        {
            _Exists = true;
        }

        __pragma(warning (suppress: 4127)) do {(void)( (!!((_ExistingNode != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 4398, 0, L"%ls", L"_ExistingNode != nullptr")) || (__debugbreak(), 0) ); __assume(_ExistingNode != nullptr);} while(false);
        return _ExistingNode->_M_value;
    }

    
    
    
    
    void clear()
    {
        for (size_t _Index = 0; _Index < _M_size; ++_Index)
        {
            _Node* _CurrentNode = _M_buckets[_Index];
            while (_CurrentNode != nullptr)
            {
                _Node* _NextNode = _CurrentNode->_M_chain;
                delete _CurrentNode;
                _CurrentNode = _NextNode;
            }
        }
        memset((void*)_M_buckets, 0, _M_size * sizeof _M_buckets[0]);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Function>
    _Ty combine(_Function _FnCombine) const
    {
        _Node* _CurrentNode = nullptr;
        size_t _Index;

        
        
        for (_Index = 0; _Index < _M_size; ++_Index)
        {
            _CurrentNode = _M_buckets[_Index];
            if (_CurrentNode != nullptr)
            {
                 break;
            }
        }

        
        if (_CurrentNode == nullptr)
        {
            return _M_fnInitialize();
        }

        
        _Ty _Result = _CurrentNode->_M_value;
        for (_CurrentNode = _CurrentNode->_M_chain; _CurrentNode != nullptr; _CurrentNode = _CurrentNode->_M_chain)
        {
            _Result = _FnCombine(_Result, _CurrentNode->_M_value);
        }

        
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_Index < _M_size))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 4467, 0, L"%ls", L"_Index < _M_size")) || (__debugbreak(), 0) ); __assume(_Index < _M_size);} while(false);
        for (++_Index; _Index < _M_size; ++_Index)
        {
            for (_CurrentNode = _M_buckets[_Index]; _CurrentNode != nullptr; _CurrentNode = _CurrentNode->_M_chain)
            {
                _Result = _FnCombine(_Result, _CurrentNode->_M_value);
            }
        }

        return _Result;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    template<typename _Function>
    void combine_each(_Function _FnCombine) const
    {
        for (size_t _Index = 0; _Index < _M_size; ++_Index)
        {
            for (_Node* _CurrentNode = _M_buckets[_Index]; _CurrentNode != nullptr; _CurrentNode = _CurrentNode->_M_chain)
            {
                _FnCombine(_CurrentNode->_M_value);
            }
        }
    }

private:
    void _InitNew()
    {
        _M_size = ::Concurrency::details::_GetCombinableSize();
        _M_buckets = new _Node*[_M_size]{};
    }

    struct _InitCopyOp
    {
        ::std::unique_ptr<_Node*[]> _M_new_buckets;
        size_t _M_index; 

        explicit _InitCopyOp(size_t _Size)
            : _M_new_buckets(),
            _M_index(0)
        {
            if (_Size != 0)
            {
                _M_new_buckets = ::std::make_unique<_Node*[]>(_Size);
            }
        }

        _Node ** _DoCopy(size_t _Size, const combinable& _Other)
        {
            for (; _M_index < _Size; ++_M_index)
            {
                for (_Node* _CurrentNode = _Other._M_buckets[_M_index]; _CurrentNode != nullptr;
                    _CurrentNode = _CurrentNode->_M_chain)
                {
                    
                    _Node* _NewNode = new _Node(_CurrentNode->_M_key, _CurrentNode->_M_value);
                    _NewNode->_M_chain = _M_new_buckets[_M_index];
                    _M_new_buckets[_M_index] = _NewNode;
                }
            }

            return _M_new_buckets.release(); 
        }

        ~_InitCopyOp()
        {
            if (_M_new_buckets)
            {
                
                
                for (size_t _Next = 0; _Next <= _M_index; ++_Next)
                {
                    _Node* _CurrentNode = _M_new_buckets[_Next];
                    while (_CurrentNode)
                    {
                        const auto _NextNode = _CurrentNode->_M_chain;
                        delete _CurrentNode;
                        _CurrentNode = _NextNode;
                    }
                }
            }
        }
    };

    static _Node ** _InitCopy(const combinable& _Other)
    {
        _InitCopyOp _Op{_Other._M_size};
        return _Op._DoCopy(_Other._M_size, _Other);
    }

    _Node* _FindLocalItem(unsigned long _Key, size_t* _PIndex)
    {
        __pragma(warning (suppress: 4127)) do {(void)( (!!((_PIndex != nullptr))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 4571, 0, L"%ls", L"_PIndex != nullptr")) || (__debugbreak(), 0) ); __assume(_PIndex != nullptr);} while(false);

        *_PIndex = _Key % _M_size;

        
        for (_Node* _CurrentNode = _M_buckets[*_PIndex]; _CurrentNode != nullptr; _CurrentNode = _CurrentNode->_M_chain)
        {
            if (_CurrentNode->_M_key == _Key)
            {
                return _CurrentNode;
            }
        }

        return nullptr;
    }

    _Node* _AddLocalItem(unsigned long _Key, size_t _Index)
    {
        _Node* _NewNode = new _Node(_Key, _M_fnInitialize());
        _Node* _TopNode;
        do
        {
            _TopNode = _M_buckets[_Index];
            _NewNode->_M_chain = _TopNode;
        } while (_InterlockedCompareExchangePointer(reinterpret_cast<void * volatile *>(&_M_buckets[_Index]), _NewNode, _TopNode) != _TopNode);

        return _NewNode;
    }

private:
    _Node *volatile * _M_buckets;
    size_t _M_size;
    ::std::function<_Ty ()> _M_fnInitialize;
};

#pragma warning(pop) 































template<typename _Random_iterator, typename _Function>
inline size_t _Median_of_three(const _Random_iterator &_Begin, size_t _A, size_t _B, size_t _C, const _Function &_Func, bool &_Potentially_equal)
{
    _Potentially_equal = false;
    if (_Func(_Begin[_A], _Begin[_B]))
    {
        if (_Func(_Begin[_A], _Begin[_C]))
        {
            return _Func(_Begin[_B], _Begin[_C]) ? _B : _C;
        }
        else
        {
            return _A;
        }
    }
    else
    {
        if (_Func(_Begin[_B], _Begin[_C]))
        {
            return _Func(_Begin[_A], _Begin[_C]) ? _A : _C;
        }
        else
        {
            _Potentially_equal = true;
            return _B;
        }
    }
}

template<typename _Random_iterator, typename _Function>
inline size_t _Median_of_nine(const _Random_iterator &_Begin, size_t _Size, const _Function &_Func, bool &_Potentially_equal)
{
    size_t _Offset = _Size / 8;
    size_t _A = _Median_of_three(_Begin, 0, _Offset, _Offset * 2, _Func, _Potentially_equal),
        _B = _Median_of_three(_Begin, _Offset * 3, _Offset * 4, _Offset * 5, _Func, _Potentially_equal),
        _C = _Median_of_three(_Begin, _Offset * 6, _Offset * 7, _Size - 1, _Func, _Potentially_equal);
    _B = _Median_of_three(_Begin, _A, _B, _C, _Func, _Potentially_equal);

    if (_Potentially_equal)
    {
        _Potentially_equal = !_Func(_Begin[_C], _Begin[_A]);
    }

    return _B;
}


template<typename _Random_iterator, typename _Function>
inline size_t _Select_median_pivot(const _Random_iterator &_Begin, size_t _Size, const _Function &_Func, const size_t _Chunk_size, bool &_Potentially_equal)
{
    
    if (_Chunk_size < 512 && _Size <= ::std::max<size_t>(_Chunk_size * 4, static_cast<size_t>(15)))
    {
        bool _Never_care_equal;
        return _Median_of_three(_Begin, 0, _Size / 2, _Size - 1, _Func, _Never_care_equal);
    }
    else
    {
        return _Median_of_nine(_Begin, _Size, _Func, _Potentially_equal);
    }
}



template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Function>
size_t _Search_mid_point(const _Random_iterator &_Begin1, size_t &_Len1, const _Random_buffer_iterator &_Begin2, size_t &_Len2, const _Function &_Func)
{
    size_t _Len = (_Len1 + _Len2) / 2, _Index1 = 0, _Index2 = 0;

    while (_Index1 < _Len1 && _Index2 < _Len2)
    {
        size_t _Mid1 = (_Index1 + _Len1) / 2, _Mid2 = (_Index2 + _Len2) / 2;
        if (_Func(_Begin1[_Mid1], _Begin2[_Mid2]))
        {
            if (_Mid1 + _Mid2 < _Len)
            {
                _Index1 = _Mid1 + 1;
            }
            else
            {
                _Len2 = _Mid2;
            }
        }
        else
        {
            if (_Mid1 + _Mid2 < _Len)
            {
                _Index2 = _Mid2 + 1;
            }
            else
            {
                _Len1 = _Mid1;
            }
        }
    }

    if (_Index1 == _Len1)
    {
        _Len2 = _Len - _Len1;
    }
    else
    {
        _Len1 = _Len - _Len2;
    }

    return _Len;
}


template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Random_output_iterator, typename _Function>
void _Merge_chunks(_Random_iterator _Begin1, const _Random_iterator &_End1, _Random_buffer_iterator _Begin2, const _Random_buffer_iterator &_End2,
    _Random_output_iterator _Output, const _Function &_Func)
{
    while (_Begin1 != _End1 && _Begin2 != _End2)
    {
        if (_Func(*_Begin1, *_Begin2))
        {
            *_Output++ = ::std::move(*_Begin1++);
        }
        else
        {
            *_Output++ = ::std::move(*_Begin2++);
        }
    }

    if (_Begin1 != _End1)
    {
        ::std::move(_Begin1, _End1, _Output);
    }
    else if (_Begin2 != _End2)
    {
        ::std::move(_Begin2, _End2, _Output);
    }
}



template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Random_output_iterator, typename _Function>
void _Parallel_merge(_Random_iterator _Begin1, size_t _Len1, _Random_buffer_iterator _Begin2, size_t _Len2, _Random_output_iterator _Output,
    const _Function &_Func, size_t _Div_num)
{
    
    if (_Div_num <= 1 || (_Len1 <= 1 && _Len2 <= 1))
    {
        _Merge_chunks(_Begin1, _Begin1 + _Len1, _Begin2, _Begin2 + _Len2, _Output, _Func);
    }
    else
    {
        size_t _Mid_len1 = _Len1, _Mid_len2 = _Len2;
        size_t _Mid = _Search_mid_point(_Begin1, _Mid_len1, _Begin2, _Mid_len2, _Func);

        structured_task_group _Tg;
        auto _Handle = make_task([&]
        {
            _Parallel_merge(_Begin1, _Mid_len1, _Begin2, _Mid_len2, _Output, _Func, _Div_num / 2);
        });
        _Tg.run(_Handle);

        _Parallel_merge(_Begin1 + _Mid_len1, _Len1 - _Mid_len1, _Begin2 + _Mid_len2, _Len2 - _Mid_len2, _Output + _Mid, _Func, _Div_num / 2);

        _Tg.wait();
    }
}


template<typename _Ty, typename _Function>
inline size_t _Radix_key(const _Ty& _Val, size_t _Radix, _Function _Proj_func)
{
    return static_cast<size_t>(_Proj_func(_Val) >> static_cast<int>(8 * _Radix) & 255);
}


template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Function>
void _Integer_radix_pass(const _Random_iterator &_Begin, size_t _Size, const _Random_buffer_iterator &_Output, size_t _Radix, _Function _Proj_func)
{
    if (!_Size)
    {
        return;
    }

    size_t _Pos[256] = {0};

    for (size_t _I = 0; _I < _Size; _I++)
    {
        ++_Pos[_Radix_key(_Begin[_I], _Radix, _Proj_func)];
    }

    for (size_t _I = 1; _I < 256; _I++)
    {
        _Pos[_I] += _Pos[_I - 1];
    }

    
    for (size_t _I = _Size - 1; _I != 0; _I--)
    {
        _Output[--_Pos[_Radix_key(_Begin[_I], _Radix, _Proj_func)]] = ::std::move(_Begin[_I]);
    }

    _Output[--_Pos[_Radix_key(_Begin[0], _Radix, _Proj_func)]] = ::std::move(_Begin[0]);
}


template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Function>
void _Integer_radix_sort(const _Random_iterator &_Begin, size_t _Size, const _Random_buffer_iterator &_Output,
    size_t _Radix, _Function _Proj_func, size_t _Deep = 0)
{
    size_t _Cur_radix = 0;
    if (_Size == 0)
    {
        return;
    }

    while (_Cur_radix < _Radix)
    {
        _Integer_radix_pass(_Begin, _Size, _Output, _Cur_radix++, _Proj_func);
        _Integer_radix_pass(_Output, _Size, _Begin, _Cur_radix++, _Proj_func);
    }

    if (_Cur_radix == _Radix)
    {
        _Integer_radix_pass(_Begin, _Size, _Output, _Cur_radix++, _Proj_func);
    }

    
    if (_Deep + _Radix + 1 & 1)
    {
        if (_Radix + 1 & 1)
        {
            ::std::move(_Output, _Output + _Size, _Begin);
        }
        else
        {
            ::std::move(_Begin, _Begin + _Size, _Output);
        }
    }
}



template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Function>
void _Parallel_integer_radix_sort(const _Random_iterator &_Begin, size_t _Size, const _Random_buffer_iterator &_Output,
    size_t _Radix, _Function _Proj_func, const size_t _Chunk_size, size_t _Deep = 0)
{
    
    if (_Size <= _Chunk_size || _Radix < 1)
    {
        return _Integer_radix_sort(_Begin, _Size, _Output, _Radix, _Proj_func, _Deep);
    }

    size_t _Threads_num = ::Concurrency::details::_CurrentScheduler::_GetNumberOfVirtualProcessors();
    size_t _Buffer_size = sizeof(size_t) * 256 * _Threads_num;
    size_t _Step = _Size / _Threads_num;
    size_t _Remain = _Size % _Threads_num;

    ::Concurrency::details::_MallocaArrayHolder<size_t> _Holder;
    using _Chunk_ptr_t = size_t (*)[256];
    _Chunk_ptr_t _Chunks = reinterpret_cast<_Chunk_ptr_t>(_Holder._InitOnRawMalloca(__pragma(warning(suppress: 6255 6386)) (_MallocaComputeSize(_Buffer_size) != 0 ? _MarkAllocaS(malloc(_MallocaComputeSize(_Buffer_size)), 0xDDDD) : 0)));

    memset(_Chunks, 0, _Buffer_size);

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    ::Concurrency::parallel_for(static_cast<size_t>(0), _Threads_num, [=](size_t _Index)
    {
        size_t _Beg_index, _End_index;

        
        if (_Index < _Remain)
        {
            _Beg_index = _Index * (_Step + 1);
            _End_index = _Beg_index + (_Step + 1);
        }
        else
        {
            _Beg_index = _Remain * (_Step + 1) + (_Index - _Remain) * _Step;
            _End_index = _Beg_index + _Step;
        }

        
        while (_Beg_index != _End_index)
        {
            ++_Chunks[_Index][_Radix_key(_Begin[_Beg_index++], _Radix, _Proj_func)];
        }
    });

    int _Index = -1, _Count = 0;

    
    for (int _I = 0; _I < 256; _I++)
    {
        size_t _Last = _I ? _Chunks[_Threads_num - 1][_I - 1] : 0;
        _Chunks[0][_I] += _Last;

        for (size_t _J = 1; _J < _Threads_num; _J++)
        {
            _Chunks[_J][_I] += _Chunks[_J - 1][_I];
        }

        
        
        if (_Chunks[_Threads_num - 1][_I] - _Last)
        {
            ++_Count;
            _Index = _I;
        }
    }

    
    if (_Count > 1)
    {
        
        ::Concurrency::parallel_for(static_cast<size_t>(0), _Threads_num, [=](size_t _Index)
        {
            size_t _Beg_index, _End_index;

            
            if (_Index < _Remain)
            {
                _Beg_index = _Index * (_Step + 1);
                _End_index = _Beg_index + (_Step + 1);
            }
            else
            {
                _Beg_index = _Remain * (_Step + 1) + (_Index - _Remain) * _Step;
                _End_index = _Beg_index + _Step;
            }

            
            
            if (_Beg_index != _End_index--)
            {
                while (_Beg_index != _End_index)
                {
                    _Output[--_Chunks[_Index][_Radix_key(_Begin[_End_index], _Radix, _Proj_func)]] = ::std::move(_Begin[_End_index]);
                    --_End_index;
                }
                _Output[--_Chunks[_Index][_Radix_key(_Begin[_End_index], _Radix, _Proj_func)]] = ::std::move(_Begin[_End_index]);
            }
        });

        
        ::Concurrency::parallel_for(static_cast<size_t>(0), static_cast<size_t>(256), [=](size_t _Index)
        {
            if (_Index < 256 - 1)
            {
                _Parallel_integer_radix_sort(_Output + _Chunks[0][_Index], _Chunks[0][_Index + 1] - _Chunks[0][_Index],
                    _Begin + _Chunks[0][_Index], _Radix - 1, _Proj_func, _Chunk_size, _Deep + 1);
            }
            else
            {
                _Parallel_integer_radix_sort(_Output + _Chunks[0][_Index], _Size - _Chunks[0][_Index],
                    _Begin + _Chunks[0][_Index], _Radix - 1, _Proj_func, _Chunk_size, _Deep + 1);
            }
        });
    }
    else
    {
        
        
        
        
        _Parallel_integer_radix_sort(_Begin, _Size, _Output, _Radix - 1, _Proj_func, _Chunk_size, _Deep);
    }
}

template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Function>
void _Parallel_integer_sort_asc(const _Random_iterator &_Begin, size_t _Size, const _Random_buffer_iterator &_Output,
    _Function _Proj_func, const size_t _Chunk_size)
{
    typedef typename ::std::iterator_traits<_Random_iterator>::value_type _Value_type;
    
    
    typedef ::std::remove_const_t<::std::remove_reference_t<decltype(_Proj_func(*_Begin))>> _Integer_type;

    
    _Integer_type _Max_val = ::Concurrency::parallel_reduce(_Begin, _Begin + _Size, _Proj_func(*_Begin),
        [=](_Random_iterator _Begin, _Random_iterator _End, _Integer_type _Init) -> _Integer_type
        {
            while (_Begin != _End)
            {
                _Integer_type _Ret = _Proj_func(*_Begin++);
                if (_Init < _Ret)
                {
                    _Init = _Ret;
                }
            }

            return _Init;
        }, [](const _Integer_type &_A, const _Integer_type &_B) -> const _Integer_type& {return (_A < _B)? _B : _A;});
    size_t _Radix = 0;

    
    while (_Max_val >>= 8)
    {
        ++_Radix;
    }

    _Parallel_integer_radix_sort(_Begin, _Size, _Output, _Radix, _Proj_func, _Chunk_size);
}

template<typename _Random_iterator, typename _Function>
void _Parallel_quicksort_impl(const _Random_iterator &_Begin, size_t _Size, const _Function &_Func, size_t _Div_num, const size_t _Chunk_size, int _Depth)
{
    if (_Depth >= 64 || _Size <= _Chunk_size || _Size <= static_cast<size_t>(3) || _Chunk_size >= 512 && _Div_num <= 1)
    {
        return ::std::sort(_Begin, _Begin + _Size, _Func);
    }

    
    
    
    bool _Is_three_way_split = false;
    size_t _Mid_index = _Select_median_pivot(_Begin, _Size, _Func, _Chunk_size, _Is_three_way_split);

    
    if (_Mid_index)
    {
        ::std::swap(*_Begin, _Begin[_Mid_index]);
    }
    size_t _I = 1, _J = _Size - 1;

    
    
    if (_Is_three_way_split && _Div_num < 1024)
    {
        while (_Func(*_Begin, _Begin[_J]))
        {
            --_J;
        }

        while (_Func(_Begin[_I], *_Begin))
        {
            ++_I;
        }

        
        
        size_t _K = _J;
        while (_I <= _K)
        {
            if (_Func(_Begin[_K], *_Begin))
            {
                ::std::swap(_Begin[_I++], _Begin[_K]);
            }
            else
            {
                --_K;
            }

            while (_Func(*_Begin, _Begin[_K]))
            {
                ::std::swap(_Begin[_K--], _Begin[_J--]);
            }
        }

        ++_J;
    }
    else
    {
        while (_I <= _J)
        {
            
            while (_Func(*_Begin, _Begin[_J]))
            {
                --_J;
            }

            
            while (_Func(_Begin[_I], *_Begin))
            {
                ++_I;
            }

            if (_I < _J)
            {
                ::std::swap(_Begin[_I++], _Begin[_J--]);
            }
            else
            {
                break;
            }
        }

        _I = ++_J;
    }

    ::std::swap(*_Begin, _Begin[--_I]);

    structured_task_group _Tg;
    volatile size_t _Next_div = _Div_num / 2;
    auto _Handle = make_task([&]
    {
        _Parallel_quicksort_impl(_Begin + _J, _Size - _J, _Func, _Next_div, _Chunk_size, _Depth+1);
    });
    _Tg.run(_Handle);

    _Parallel_quicksort_impl(_Begin, _I, _Func, _Next_div, _Chunk_size, _Depth+1);

    
    if (_Div_num < 1024)
    {
        _Next_div /= 2;
    }

    _Tg.wait();
}





template<typename _Random_iterator, typename _Random_buffer_iterator, typename _Function>
inline bool _Parallel_buffered_sort_impl(const _Random_iterator &_Begin, size_t _Size, _Random_buffer_iterator _Output, const _Function &_Func,
    int _Div_num, const size_t _Chunk_size)
{
    static_assert(::std::is_same_v<typename ::std::iterator_traits<_Random_iterator>::value_type, typename ::std::iterator_traits<_Random_buffer_iterator>::value_type>,
        "same value type expected");

    if (_Div_num <= 1 || _Size <= _Chunk_size)
    {
        _Parallel_quicksort_impl(_Begin, _Size, _Func, 1024, _Chunk_size, 0);

        
        
        
        int _Left_div_turns = 0;
        while (_Div_num >>= 1)
        {
            _Left_div_turns++;
        }

        if (_Left_div_turns & 1)
        {
            ::std::move(_Begin, _Begin + _Size, _Output);
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        size_t _Mid = _Size / 2;
        structured_task_group _Tg;

        auto _Handle = make_task([&, _Chunk_size]
        {
            _Parallel_buffered_sort_impl(_Begin, _Mid, _Output, _Func, _Div_num / 2, _Chunk_size);
        });
        _Tg.run(_Handle);

        bool _Is_buffer_swap = _Parallel_buffered_sort_impl(_Begin + _Mid, _Size - _Mid, _Output + _Mid, _Func, _Div_num / 2, _Chunk_size);

        _Tg.wait();

        if (_Is_buffer_swap)
        {
            _Parallel_merge(_Output, _Mid, _Output + _Mid, _Size - _Mid, _Begin, _Func, _Div_num);
        }
        else
        {
            _Parallel_merge(_Begin, _Mid, _Begin + _Mid, _Size - _Mid, _Output, _Func, _Div_num);
        }

        return !_Is_buffer_swap;
    }
}



#pragma warning (push)
#pragma warning (disable: 4127)


template<typename _Allocator>
inline typename ::std::allocator_traits<_Allocator>::pointer _Construct_buffer(size_t _N, _Allocator &_Alloc)
{
    using _Traits = ::std::allocator_traits<_Allocator>;
    using _Value_type = typename _Allocator::value_type;
    using _Pointer = typename _Traits::pointer;

    const _Pointer _P = _Alloc.allocate(_N);

    
    
    if (!::std::is_trivially_default_constructible_v<_Value_type>)
    {
        for (size_t _I = 0; _I < _N; _I++)
        {
            
            _Traits::construct(_Alloc, _P + _I);
        }
    }

    return _P;
}


template<typename _Allocator>
inline void _Destroy_buffer(typename ::std::allocator_traits<_Allocator>::pointer _P, size_t _N, _Allocator &_Alloc)
{
    using _Traits = ::std::allocator_traits<_Allocator>;

    
    
    if (!::std::is_trivially_destructible_v<typename _Allocator::value_type>)
    {
        for (size_t _I = 0; _I < _N; _I++)
        {
            _Traits::destroy(_Alloc, _P + _I);
        }
    }

    _Alloc.deallocate(_P, _N);
}





template<typename _Allocator>
class _AllocatedBufferHolder
{
public:
    _AllocatedBufferHolder(size_t _Size, const _Allocator &_Alloc)
        : _M_size(_Size),
        _M_alloc(_Alloc),
        _M_buffer(_Construct_buffer(_Size, _M_alloc))
    {
    }

    ~_AllocatedBufferHolder()
    {
        _Destroy_buffer(_M_buffer, _M_size, _M_alloc);
    }

    typename ::std::allocator_traits<_Allocator>::pointer _Get_buffer()
    {
        return _M_buffer;
    }

private:
    size_t _M_size;
    _Allocator _M_alloc;
    typename ::std::allocator_traits<_Allocator>::pointer _M_buffer;
};


#pragma warning (pop)


































template<typename _Random_iterator, typename _Function>
inline void parallel_sort(const _Random_iterator &_Begin, const _Random_iterator &_End, const _Function &_Func, const size_t _Chunk_size = 2048)
{
    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Chunk_size > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 5366, 0, L"%ls", L"_Chunk_size > 0")) || (__debugbreak(), 0) ); __assume(_Chunk_size > 0);} while(false);

    
    interruption_point();

    size_t _Size = _End - _Begin;
    size_t _Core_num = ::Concurrency::details::_CurrentScheduler::_GetNumberOfVirtualProcessors();

    if (_Size <= _Chunk_size || _Core_num < 2)
    {
        return ::std::sort(_Begin, _End, _Func);
    }

    _Parallel_quicksort_impl(_Begin, _Size, _Func, _Core_num * 1024, _Chunk_size, 0);
}























template<typename _Random_iterator>
inline void parallel_sort(const _Random_iterator &_Begin, const _Random_iterator &_End)
{
    parallel_sort(_Begin, _End, ::std::less<typename ::std::iterator_traits<_Random_iterator>::value_type>());
}












































template<typename _Allocator, typename _Random_iterator, typename _Function>
inline void parallel_buffered_sort(const _Allocator& _Alloc, const _Random_iterator &_Begin, const _Random_iterator &_End, const _Function &_Func, const size_t _Chunk_size = 2048)
{
    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Chunk_size > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 5456, 0, L"%ls", L"_Chunk_size > 0")) || (__debugbreak(), 0) ); __assume(_Chunk_size > 0);} while(false);

    
    interruption_point();

    size_t _Size = _End - _Begin;
    size_t _Core_num = ::Concurrency::details::_CurrentScheduler::_GetNumberOfVirtualProcessors();

    if (_Size <= _Chunk_size || _Core_num < 2)
    {
        return ::std::sort(_Begin, _End, _Func);
    }
    const static size_t _CORE_NUM_MASK = 0x55555555;

    _AllocatedBufferHolder<_Allocator> _Holder(_Size, _Alloc);

    
    run_with_cancellation_token([&]() {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        _Parallel_buffered_sort_impl(_Begin, _Size, stdext::make_unchecked_array_iterator(_Holder._Get_buffer()),
            _Func, _Core_num & _CORE_NUM_MASK | _Core_num << 1 & _CORE_NUM_MASK, _Chunk_size);
    }, cancellation_token::none());

}









































template<typename _Allocator, typename _Random_iterator, typename _Function>
inline void parallel_buffered_sort(const _Random_iterator &_Begin, const _Random_iterator &_End, const _Function &_Func, const size_t _Chunk_size = 2048)
{
    _Allocator _Alloc;
    return parallel_buffered_sort<_Allocator, _Random_iterator, _Function>(_Alloc, _Begin, _End, _Func, _Chunk_size);
}






































template<typename _Random_iterator, typename _Function>
inline void parallel_buffered_sort(const _Random_iterator &_Begin, const _Random_iterator &_End, const _Function &_Func, const size_t _Chunk_size = 2048)
{
    parallel_buffered_sort<::std::allocator<typename ::std::iterator_traits<_Random_iterator>::value_type>>(_Begin, _End, _Func, _Chunk_size);
}



























template<typename _Random_iterator>
inline void parallel_buffered_sort(const _Random_iterator &_Begin, const _Random_iterator &_End)
{
    parallel_buffered_sort<::std::allocator<typename ::std::iterator_traits<_Random_iterator>::value_type>>(_Begin, _End,
        ::std::less<typename ::std::iterator_traits<_Random_iterator>::value_type>());
}






























template<typename _Allocator, typename _Random_iterator>
inline void parallel_buffered_sort(const _Random_iterator &_Begin, const _Random_iterator &_End)
{
    parallel_buffered_sort<_Allocator>(_Begin, _End,
        ::std::less<typename ::std::iterator_traits<_Random_iterator>::value_type>());
}

































template<typename _Allocator, typename _Random_iterator>
inline void parallel_buffered_sort(const _Allocator& _Alloc, const _Random_iterator &_Begin, const _Random_iterator &_End)
{
    parallel_buffered_sort<_Allocator>(_Alloc, _Begin, _End, ::std::less<typename ::std::iterator_traits<_Random_iterator>::value_type>());
}

#pragma warning(push)
#pragma warning (disable: 4127)




template <typename _DataType>
struct _Radix_sort_default_function
{
    size_t operator()(const _DataType& _Val) const
    {
        
        
        
        
        
        
        static_assert(::std::is_integral_v<_DataType>,
            "Type should be integral to use default radix function. For more information on integral types, please refer to https://msdn.microsoft.com/en-us/library/bb983099.aspx.");
        static_assert((sizeof(_DataType) <= sizeof(size_t)), "Passed Type is bigger than size_t.");

        if (::std::is_unsigned_v<_DataType>)
        {
            return _Val;
        }
        else
        {
            
            
            
            return (((0xffffffffffffffffui64/2) + 1) + static_cast<size_t>(_Val));
        }
    }
};
#pragma warning (pop)


























template<typename _Random_iterator>
inline void parallel_radixsort(const _Random_iterator &_Begin, const _Random_iterator &_End)
{
    typedef typename ::std::iterator_traits<_Random_iterator>::value_type _DataType;

    _Radix_sort_default_function<_DataType> _Proj_func;

    parallel_radixsort<::std::allocator<_DataType>>(_Begin, _End, _Proj_func, 256 * 256);
}
































template<typename _Allocator, typename _Random_iterator>
inline void parallel_radixsort(const _Allocator& _Alloc, const _Random_iterator &_Begin, const _Random_iterator &_End)
{
    typedef typename ::std::iterator_traits<_Random_iterator>::value_type _DataType;

    _Radix_sort_default_function<_DataType> _Proj_func;

    parallel_radixsort<_Allocator>(_Alloc, _Begin, _End, _Proj_func);
}





























template<typename _Allocator, typename _Random_iterator>
inline void parallel_radixsort(const _Random_iterator &_Begin, const _Random_iterator &_End)
{
    _Allocator _Alloc;
    return parallel_radixsort<_Allocator, _Random_iterator>(_Alloc, _Begin, _End);
}









































template<typename _Allocator, typename _Random_iterator, typename _Function>
inline void parallel_radixsort(const _Allocator& _Alloc, const _Random_iterator &_Begin, const _Random_iterator &_End, const _Function &_Proj_func, const size_t _Chunk_size = 256 * 256)
{
    __pragma(warning (suppress: 4127)) do {(void)( (!!((_Chunk_size > 0))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ppl.h", 5901, 0, L"%ls", L"_Chunk_size > 0")) || (__debugbreak(), 0) ); __assume(_Chunk_size > 0);} while(false);

    
    interruption_point();

    size_t _Size = _End - _Begin;

    
    if (_Size <= 1)
    {
        return;
    }

    _AllocatedBufferHolder<_Allocator> _Holder(_Size, _Alloc);

    
    run_with_cancellation_token([&]() {
        _Parallel_integer_sort_asc(_Begin, _Size, stdext::make_unchecked_array_iterator(_Holder._Get_buffer()), _Proj_func, _Chunk_size);
    }, cancellation_token::none());
}






































template<typename _Allocator, typename _Random_iterator, typename _Function>
inline void parallel_radixsort(const _Random_iterator &_Begin, const _Random_iterator &_End, const _Function &_Proj_func, const size_t _Chunk_size = 256 * 256)
{
    _Allocator _Alloc;
    return parallel_radixsort<_Allocator, _Random_iterator, _Function>(_Alloc, _Begin, _End, _Proj_func, _Chunk_size);
}



































template<typename _Random_iterator, typename _Function>
inline void parallel_radixsort(const _Random_iterator &_Begin, const _Random_iterator &_End, const _Function &_Proj_func, const size_t _Chunk_size = 256 * 256)
{
    parallel_radixsort<::std::allocator<typename ::std::iterator_traits<_Random_iterator>::value_type>>(
        _Begin, _End, _Proj_func, _Chunk_size);
}




}

namespace concurrency = ::Concurrency;


#pragma pack(pop)
#pragma external_header(pop)
#line 3 "C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.cpp"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\cassert"
#pragma external_header(pop)
#line 6 "C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.cpp"

using namespace DirectX;

Waves::Waves(int m, int n, float dx, float dt, float speed, float damping)
{
	mNumRows = m;
	mNumCols = n;

	mVertexCount = m * n;
	mTriangleCount = (m - 1) * (n - 1) * 2;

	mTimeStep = dt;
	mSpatialStep = dx;

	float d = damping * dt + 2.0f;
	float e = (speed * speed) * (dt * dt) / (dx * dx);
	mK1 = (damping * dt - 2.0f) / d;
	mK2 = (4.0f - 8.0f * e) / d;
	mK3 = (2.0f * e) / d;

	mPrevSolution.resize(m * n);
	mCurrSolution.resize(m * n);
	mNormals.resize(m * n);
	mTangentX.resize(m * n);

	
	float halfWidth = (n - 1) * dx * 0.5f;
	float halfDepth = (m - 1) * dx * 0.5f;
	for (int i = 0; i < m; ++i)
	{
		float z = halfDepth - i * dx;
		for (int j = 0; j < n; ++j)
		{
			float x = -halfWidth + j * dx;

			mPrevSolution[i * n + j] = XMFLOAT3(x, 0.0f, z);
			mCurrSolution[i * n + j] = XMFLOAT3(x, 0.0f, z);
			mNormals[i * n + j] = XMFLOAT3(0.0f, 1.0f, 0.0f);
			mTangentX[i * n + j] = XMFLOAT3(1.0f, 0.0f, 0.0f);
		}
	}
}

Waves::~Waves()
{
	
}

int Waves::RowCount()const
{
	return mNumRows;
}

int Waves::ColumnCount()const
{
	return mNumCols;
}

int Waves::VertexCount()const
{
	return mVertexCount;
}

int Waves::TriangleCount()const
{
	return mTriangleCount;
}

float Waves::Width()const
{
	return mNumCols * mSpatialStep;
}

float Waves::Depth()const
{
	return mNumRows * mSpatialStep;
}


void Waves::Update(float dt)
{
	static float t = 0;

	
	t += dt;

	
	if (t >= mTimeStep)
	{
		
		concurrency::parallel_for(1, mNumRows - 1, [this](int i)
			
			{
				for (int j = 1; j < mNumCols - 1; ++j)
				{
					
					
					
					

					
					
					

					mPrevSolution[i * mNumCols + j].y =
						mK1 * mPrevSolution[i * mNumCols + j].y +
						mK2 * mCurrSolution[i * mNumCols + j].y +
						mK3 * (mCurrSolution[(i + 1) * mNumCols + j].y +
							mCurrSolution[(i - 1) * mNumCols + j].y +
							mCurrSolution[i * mNumCols + j + 1].y +
							mCurrSolution[i * mNumCols + j - 1].y);
				}
			});

		
		
		
		std::swap(mPrevSolution, mCurrSolution);

		t = 0.0f; 

		
		
		
		concurrency::parallel_for(1, mNumRows - 1, [this](int i)
			
			{
				for (int j = 1; j < mNumCols - 1; ++j)
				{
					float l = mCurrSolution[i * mNumCols + j - 1].y;
					float r = mCurrSolution[i * mNumCols + j + 1].y;
					float t = mCurrSolution[(i - 1) * mNumCols + j].y;
					float b = mCurrSolution[(i + 1) * mNumCols + j].y;
					mNormals[i * mNumCols + j].x = -r + l;
					mNormals[i * mNumCols + j].y = 2.0f * mSpatialStep;
					mNormals[i * mNumCols + j].z = b - t;

					XMVECTOR n = XMVector3Normalize(XMLoadFloat3(&mNormals[i * mNumCols + j]));
					XMStoreFloat3(&mNormals[i * mNumCols + j], n);

					mTangentX[i * mNumCols + j] = XMFLOAT3(2.0f * mSpatialStep, r - l, 0.0f);
					XMVECTOR T = XMVector3Normalize(XMLoadFloat3(&mTangentX[i * mNumCols + j]));
					XMStoreFloat3(&mTangentX[i * mNumCols + j], T);
				}
			});
	}
}

void Waves::Disturb(int i, int j, float magnitude)
{
	
	(void)( (!!(i > 1 && i < mNumRows - 2)) || (_wassert(L"i > 1 && i < mNumRows - 2", L"C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.cpp", (unsigned)(157)), 0) );
	(void)( (!!(j > 1 && j < mNumCols - 2)) || (_wassert(L"j > 1 && j < mNumCols - 2", L"C:\\Users\\yivanli\\Desktop\\Picasso\\Picasso\\Source\\Waves.cpp", (unsigned)(158)), 0) );

	float halfMag = 0.5f * magnitude;

	
	mCurrSolution[i * mNumCols + j].y += magnitude;
	mCurrSolution[i * mNumCols + j + 1].y += halfMag;
	mCurrSolution[i * mNumCols + j - 1].y += halfMag;
	mCurrSolution[(i + 1) * mNumCols + j].y += halfMag;
	mCurrSolution[(i - 1) * mNumCols + j].y += halfMag;
}
